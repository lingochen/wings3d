/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./css/bubble.css":
/*!************************!*\
  !*** ./css/bubble.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/bubble.css?");

/***/ }),

/***/ "./css/button.css":
/*!************************!*\
  !*** ./css/button.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/button.css?");

/***/ }),

/***/ "./css/default.css":
/*!*************************!*\
  !*** ./css/default.css ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/default.css?");

/***/ }),

/***/ "./css/form.css":
/*!**********************!*\
  !*** ./css/form.css ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/form.css?");

/***/ }),

/***/ "./css/menu.css":
/*!**********************!*\
  !*** ./css/menu.css ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/menu.css?");

/***/ }),

/***/ "./css/sidebar.css":
/*!*************************!*\
  !*** ./css/sidebar.css ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/sidebar.css?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_default_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/default.css */ \"./css/default.css\");\n/* harmony import */ var _css_default_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_default_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_menu_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css/menu.css */ \"./css/menu.css\");\n/* harmony import */ var _css_menu_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_menu_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _css_button_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css/button.css */ \"./css/button.css\");\n/* harmony import */ var _css_button_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_button_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _css_form_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css/form.css */ \"./css/form.css\");\n/* harmony import */ var _css_form_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_form_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _css_bubble_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css/bubble.css */ \"./css/bubble.css\");\n/* harmony import */ var _css_bubble_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_css_bubble_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _css_sidebar_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../css/sidebar.css */ \"./css/sidebar.css\");\n/* harmony import */ var _css_sidebar_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_css_sidebar_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_camera */ \"./js/wings3d_camera.js\");\n/* harmony import */ var _wings3d_interact__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d_interact */ \"./js/wings3d_interact.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_i18n__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wings3d_i18n */ \"./js/wings3d_i18n.js\");\n/* harmony import */ var _js_plugins_cubeshape_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../js/plugins/cubeshape.js */ \"./js/plugins/cubeshape.js\");\n/* harmony import */ var _js_plugins_wavefront_obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../js/plugins/wavefront_obj.js */ \"./js/plugins/wavefront_obj.js\");\n// app.js\n//  for bundling and initialization\n//\n\n// import css, should bundle it to a different files.\n\n\n\n\n\n\n\n// import js\n\n\n\n\n\n\n\n// plugins\n\n\n\n\n_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"start\"]('glcanvas');\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/plugins/cubeshape.js":
/*!*********************************!*\
  !*** ./js/plugins/cubeshape.js ***!
  \*********************************/
/*! exports provided: createCube, createCubeDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createCube\", function() { return createCube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createCubeDialog\", function() { return createCubeDialog; });\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../wings3d_wingededge */ \"./js/wings3d_wingededge.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../wings3d_model */ \"./js/wings3d_model.js\");\n/*\n   n cube create. Use Dialog to create the cube.\n   todo: to support spherize, rotate, translate, putOnGround. currently only numberOfCuts and size is working.\n*/\n\n\n\n\n\n\n\nlet createCube, createCubeDialog;\ndocument.addEventListener('DOMContentLoaded', function() {\n   var _pvt = {previewCage: null};\n   _pvt.cubeParams = { numberOfCut: 1,\n                       spherize: false,\n                       size: {x: 2.0, y: 2.0, z: 2.0},\n                       rotate: {x: 0.0, y: 0.0, z: 0.0},\n                       translate: {x: 0.0, y: 0.0, z: 0.0},\n                       putOnGround: false,\n\n   };\n   _pvt.creationCount = 0;\n\n   _pvt.resetCubeParams = function() {\n      // reset.cubeParams.\n      _pvt.cubeParams.numberOfCut = 1;\n      _pvt.cubeParams.spherize = false;\n      _pvt.cubeParams.size.x = _pvt.cubeParams.size.y = _pvt.cubeParams.size.z = 2.0;\n      _pvt.cubeParams.rotate.x = _pvt.cubeParams.rotate.y = _pvt.cubeParams.rotate.z = 0.0;\n      _pvt.cubeParams.translate.x = _pvt.cubeParams.translate.y = _pvt.cubeParams.translate.z = 0.0;    \n      _pvt.cubeParams.putOnGround = false;\n   };\n\n   _pvt.cancelPreview = function() {\n      if (_pvt.previewCage !== null) {\n         // remove it from world.\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"removeFromWorld\"](_pvt.previewCage);\n         _pvt.previewCage.freeBuffer();\n         _pvt.previewCage = null;\n      } \n   };\n\n   _pvt.updatePreview = function() {\n      if (_pvt.previewCage !== null) {\n         // remove it from world.\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"removeFromWorld\"](_pvt.previewCage);\n         _pvt.previewCage.freeBuffer();\n         _pvt.previewCage = null;\n      }\n      createCube(_pvt.cubeParams.size, _pvt.cubeParams.numberOfCut, _pvt.cubeParams.translate, _pvt.cubeParams.rotate, _pvt.cubeParams.putOnGround);\n   };\n\n   createCube = function(size, numberOfCut, translate, rotate, onGround) {\n      // create, one \n      let preview = _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"putIntoWorld\"]();    //new WingedTopology; create WingedTopology(PreviewCage) and putIntoWorld.\n      let mesh = preview.geometry;\n      var map = {};\n      function addVertexUnique(pt) {\n         var x = pt[0], y = pt[1], z = pt[2];\n         var key = x.toFixed(6) + \",\" + y.toFixed(6) + \",\" + z.toFixed(6); // convert to fixed decimal, so no needs for (x-x1<epsilon)\n         if (!map.hasOwnProperty(key)) {\n            map[key] = mesh.addVertex(pt);\n         }\n         return map[key].index;\n      }\n      function makeFaces(getVertexFN) {\n         var offset = 0;\n         var vertexIndex = [];\n         var polygon = [];\n         for (let up = 0; up <= numberOfCut; ++up) {\n            for (let rt = 0; rt <= numberOfCut; ++rt) { // add vertex and get vertices index.\n               vertexIndex.push( addVertexUnique(getVertexFN(up, rt)) );\n            }\n            if (up > 0) {   // add polygon faces, ccw order\n               for (let i = 0 ; i<numberOfCut; ++i) {\n                  polygon.push( vertexIndex[offset+i] );\n                  polygon.push( vertexIndex[offset+i+1] );\n                  polygon.push( vertexIndex[offset+i+1+numberOfCut+1] );\n                  polygon.push( vertexIndex[offset+i+numberOfCut+1] );\n                  mesh.addPolygon(polygon);\n                  polygon.length = 0;\n               }\n               offset += numberOfCut+1;  // done, add offset \n            }\n         }\n      }\n      // get rotation\n      let angleQ = quat.create();\n      quat.fromEuler(angleQ, rotate.x, rotate.y, rotate.z);\n      const rotateM3 = mat3.create();\n      mat3.fromQuat(rotateM3, angleQ);\n\n      // setup start, end\n      const org = vec3.fromValues( -(size.x / 2.0), -(size.y / 2.0), -(size.z / 2.0));\n      const offset = vec3.fromValues(translate.x, translate.y, translate.z);\n      if (onGround) {\n         offset[1] = -org[1];\n      }\n      const x = vec3.fromValues(size.x, 0.0, 0.0);\n      const y = vec3.fromValues(0.0, size.y, 0.0);\n      const z = vec3.fromValues(0.0, 0.0, size.z);\n      vec3.transformMat3(org, org, rotateM3);\n      vec3.transformMat3(x, x, rotateM3);\n      vec3.transformMat3(y, y, rotateM3);\n      vec3.transformMat3(z, z, rotateM3);\n      const dest = vec3.create();\n\n      // creating step size for each cut\n      const stepX = [], stepY = [], stepZ = [];\n      for (let i = 0; i <= numberOfCut; ++i) {\n         const cut = i / numberOfCut;\n         const xStep = vec3.create();\n         vec3.scale(xStep, x, cut);\n         stepX.push( xStep );\n         const yStep = vec3.create();\n         vec3.scale(yStep, y, cut);\n         stepY.push( yStep );\n         const zStep = vec3.create();\n         vec3.scale(zStep, z, cut);\n         stepZ.push( zStep );\n      }\n      // right face (x-, -y+, -z)\n      vec3.add(dest, org, x);\n      makeFaces(function(up, rt) {\n         return vec3.fromValues(dest[0]-stepX[rt][0]+stepY[up][0]+offset[0], \n                                dest[1]-stepX[rt][1]+stepY[up][1]+offset[1], \n                                dest[2]-stepX[rt][2]+stepY[up][2]+offset[2]);\n      });\n\n      // bottom face (x-, -y, -z+)\n      makeFaces(function(up, rt){\n         return [dest[0]-stepX[up][0]+stepZ[rt][0]+offset[0], \n                 dest[1]-stepX[up][1]+stepZ[rt][1]+offset[1], \n                 dest[2]-stepX[up][2]+stepZ[rt][2]+offset[2]];\n      });\n\n      // front faces vertex (x, -y+, z-)\n      //vec3.add(dest, org, x);\n      vec3.add(dest, dest, z);\n      makeFaces(function(up, rt) {\n         return [dest[0]+stepY[up][0]-stepZ[rt][0]+offset[0], \n                 dest[1]+stepY[up][1]-stepZ[rt][1]+offset[1], \n                 dest[2]+stepY[up][2]-stepZ[rt][2]+offset[2]];\n      });\n\n      // left face (-x+, -y+, z)\n      vec3.add(dest, org, z);\n      makeFaces(function(up, rt) {\n         return [dest[0]+stepX[rt][0]+stepY[up][0]+offset[0], \n                 dest[1]+stepX[rt][1]+stepY[up][1]+offset[1], \n                 dest[2]+stepX[rt][2]+stepY[up][2]+offset[2]]; \n      });\n\n      // back face (-x, -y+, -z+)\n      makeFaces(function(up, rt){\n         return [org[0]+stepY[up][0]+stepZ[rt][0]+offset[0], \n                 org[1]+stepY[up][1]+stepZ[rt][1]+offset[1], \n                 org[2]+stepY[up][2]+stepZ[rt][2]+offset[2]];\n      });\n\n      // top face (x-, y, z-)\n      vec3.add(dest, org, x);\n      vec3.add(dest, dest, y);\n      vec3.add(dest, dest, z);\n      makeFaces(function(up, rt){\n         return [dest[0]-stepX[up][0]-stepZ[rt][0]+offset[0], \n                 dest[1]-stepX[up][1]-stepZ[rt][1]+offset[1], \n                 dest[2]-stepX[up][2]-stepZ[rt][2]+offset[2]];\n      });\n\n      _pvt.previewCage = preview;   //View.putIntoWorld(); already.\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"updateWorld\"]();\n   };\n\n   function submitCage() {\n         // accept previewCage to the world\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"undoQueue\"]( new _wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"CreatePreviewCageCommand\"](_pvt.previewCage) );\n         _pvt.previewCage.name = \"Cube\" + (_pvt.creationCount+1);\n         _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"log\"](\"createCube\", _pvt.previewCage);\n         _pvt.previewCage = null;\n         _pvt.creationCount++;\n   };\n\n   // insert a hidden form into document\n   var form = document.getElementById('createCubeForm');\n   if (form === null) {\n      form = document.createElement('form');\n      form.setAttribute('id', 'createCubeForm');\n      form.innerHTML = `\n         <span class=\"close\">&times;</span>\n         <h3>Cube Options</h3>\n         <fieldset> \n            <legend>Number of Cuts</legend>\n            <input name=\"numberOfCuts\" type=\"range\" min=\"1\" max=\"20\" value=\"1\" onchange=\"this.nextElementSibling.value=this.value\" />\n            <input name=\"numberOfCuts\" type=\"number\" min=\"1\" max=\"20\" value=\"1\" step=\"1\" onchange=\"this.previousElementSibling.value=this.value\" />\n         </fieldset>\n         <div>\n            <label>X <input type=\"number\" name=\"size_x\" value=\"2.0\" step=\"0.5\"></label><br>\n            <label>Y <input type=\"number\" name=\"size_y\" value=\"2.0\" step=\"0.5\"></label><br>\n            <label>Z <input type=\"number\" name=\"size_z\" value=\"2.0\" step=\"0.5\"></label>\n         </div>\n         <fieldset>\n            <legend>Spherize</legend>\n            <label><input type='radio' name='sphere' value='true' disabled>Yes</label>\n            <label><input type='radio' name='sphere' value='false' checked disabled>No<label>\n         </fieldset>\n         <fieldset>\n            <label>Rotate</label>\n            <span>\n               <label>X <input type=\"number\" name=\"rotate_x\" value=\"0.0\" step=\"1\"></label><br>\n               <label>Y <input type=\"number\" name=\"rotate_y\" value=\"0.0\" step=\"1\"></label><br>\n               <label>Z <input type=\"number\" name=\"rotate_z\" value=\"0.0\" step=\"1\"></label>    \n            </span>\n            <label>Move</label>\n            <span>\n               <label>X <input type=\"number\" name=\"translate_x\" value=\"0.0\" step=\"0.5\"></label><br>\n               <label>Y <input type=\"number\" name=\"translate_y\" value=\"0.0\" step=\"0.5\"></label><br>\n               <label>Z <input type=\"number\" name=\"translate_z\" value=\"0.0\" step=\"0.5\"></label>\n            </span>\n            <div>\n               <label><input type=\"checkbox\" name=\"ground\">Put on Ground</label>\n            </div>\n         </fieldset>\n          <button type=\"reset\" value=\"Reset\">Reset</button>\n          <button type=\"submit\" value=\"Ok\">Ok</button>\n      `;\n      // hide, then append into document.body.\n      form.style.display = 'none'; \n      form.style.position = 'absolute';\n      form.className += 'dialog';\n      document.body.appendChild(form);\n      // handlingEvent.\n      var close = form.getElementsByClassName(\"close\")[0];\n      close.addEventListener('click',function(e) {\n         form.style.display = 'none';\n         // remove object from world.\n         _pvt.cancelPreview();\n      });\n      // submit button.\n      form.addEventListener('submit', function(ev) {\n         ev.preventDefault();\n         form.style.display = 'none';\n         submitCage();\n      });\n      var cutHandler = function(ev) {\n         _pvt.cubeParams.numberOfCut = Number(ev.target.value);\n         _pvt.updatePreview();\n      };\n      // var inputs = form.getElementsByTagName('input');\n      var cut = document.querySelectorAll('#createCubeForm input[name=\"numberOfCuts\"]');\n      cut[0].addEventListener('change', cutHandler);\n      cut[1].addEventListener('change', cutHandler);\n      var size = document.querySelectorAll('#createCubeForm input[name^=\"size_\"]');\n      size[0].addEventListener('change', function(ev) { \n         _pvt.cubeParams.size.x = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      size[1].addEventListener('change', function(ev) { \n         _pvt.cubeParams.size.y = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      size[2].addEventListener('change', function(ev) {\n         _pvt.cubeParams.size.z = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      const translate = document.querySelectorAll('#createCubeForm input[name^=\"translate_\"]');\n      translate[0].addEventListener('change', function(ev) {\n         _pvt.cubeParams.translate.x = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      translate[1].addEventListener('change', function(ev) {\n         _pvt.cubeParams.translate.y = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      translate[2].addEventListener('change', function(ev) {\n         _pvt.cubeParams.translate.z = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      // putonGround\n      const ground = document.querySelectorAll('#createCubeForm input[name=\"ground\"]');\n      ground[0].addEventListener('change', function(ev) {\n         if (ground[0].checked) {\n            translate[1].disabled = true;\n            _pvt.cubeParams.putOnGround = true;\n         } else {\n            translate[1].disabled = false;\n            _pvt.cubeParams.putOnGround = false;\n         }\n         _pvt.updatePreview();\n      });\n      // rotation\n      const rotate = document.querySelectorAll('#createCubeForm input[name^=\"rotate_\"]');\n      rotate[0].addEventListener('change', function(ev) {\n         _pvt.cubeParams.rotate.x = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      rotate[1].addEventListener('change', function(ev) {\n         _pvt.cubeParams.rotate.y = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      rotate[2].addEventListener('change', function(ev) {\n         _pvt.cubeParams.rotate.z = Number(ev.target.value);\n         _pvt.updatePreview();\n      });\n      form.addEventListener('change', function(ev) {\n         ev.stopPropagation();\n         if (ev.target.name !== null) {\n            help(ev.target.name + \" = \" + ev.target.value);    \n         }\n      });\n      form.addEventListener('reset', function(ev) {\n         _pvt.resetCubeParams();\n         // setup the first one.\n         _pvt.updatePreview();\n      });\n   }\n\n   // attach to click event.\n   /*var menuItem = document.querySelector(\"#createCube\");\n   if (menuItem) {\n      menuItem.addEventListener(\"click\", function(ev) {\n         // get exact position,\n         var position = UI.getPosition(ev);\n         // run createCube dialog\n         createCubeDialog(position);\n         Wings3D.log(Wings3D.action.createCubeDialog);\n      })\n   }*/\n   const id = _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"action\"].createCube.name;\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](id, function(ev) {\n         _pvt.updatePreview();\n         submitCage();\n      });\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItemRMB\"](id, function(ev) {\n         // get exact position,\n         var position = _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"getPosition\"](ev);\n         // run createCube dialog\n         createCubeDialog(position);\n         _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"log\"](_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"action\"].createCubeDialog);\n      });\n   // preference optional dialog\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"action\"].createCubePref.name, function(ev) {\n         // get exact position,\n         var position = _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"getPosition\"](ev);\n         // run createCube dialog\n         createCubeDialog(position);\n         _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"log\"](_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"action\"].createCubeDialog);\n      });\n\n   //\n   createCubeDialog = function(mousePosition) {\n      // display dialog, shown at the mouse location.\n      form.style.display = 'block';\n      // position form.\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"positionDom\"](form, mousePosition);\n      _pvt.previewCage = null;\n      // reset dialog value.\n      form.reset();\n      // get sphere value.\n      // _pvt.cubeParams.spherize = form.querySelector('input[name=\"sphere\"]:checked').value;\n   };\n}, false);\n\n\n\n\n//# sourceURL=webpack:///./js/plugins/cubeshape.js?");

/***/ }),

/***/ "./js/plugins/wavefront_obj.js":
/*!*************************************!*\
  !*** ./js/plugins/wavefront_obj.js ***!
  \*************************************/
/*! exports provided: WavefrontObjImportExporter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WavefrontObjImportExporter\", function() { return WavefrontObjImportExporter; });\n/* harmony import */ var _wings3d_importexport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wings3d_importexport */ \"./js/wings3d_importexport.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wings3d_view */ \"./js/wings3d_view.js\");\n//\n// Wavefront Obj Loader and Writer.\n//\n//\n\n\n\n\nclass WavefrontObjImportExporter extends _wings3d_importexport__WEBPACK_IMPORTED_MODULE_0__[\"ImportExporter\"] {\n   constructor() {\n      super('Wavefront (.obj)...', 'Wavefront (.obj)...');\n   }\n\n   extension() {\n      return \"obj\";\n   }\n\n   _export(world) {      \n      let text = \"#wings3d-web wavefront export\\n\";\n      const fn = function(vertex) {\n         text += \" \" + (vertex.index+1);\n      };\n      for (const [index, cage] of world.entries()) {\n         const mesh = cage.geometry;\n         text += \"o \" + index.toString() + \"\\n\";\n         // now append the \"v x y z\\n\"\n         text += \"\\n#vertex total \" + mesh.vertices.size + \"\\n\";\n         for (let vertex of mesh.vertices) {\n            const vert = vertex.vertex;\n            text += \"v \" + vert[0] + \" \" + vert[1] + \" \" + vert[2] + \"\\n\";\n         }\n         // \"f index+1 index+1 index+1\"\n         text += \"\\n#face list total \" + mesh.faces.size + \"\\n\";\n         for (let polygon of mesh.faces) {\n            text += \"f\";\n            polygon.eachVertex(fn);\n            text += \"\\n\";\n         }\n      }\n      const blob = new Blob([text], {type: \"text/plain;charset=utf-8\"});\n\n      return blob;\n   }\n\n   _import(objText) {\n      // break the objText to lines we needs.\n      const linesMatch = objText.match(/^([vfogs])(?:\\s+(.+))$/gm);   //objText.match(/^v((?:\\s+)[\\d|\\.|\\+|\\-|e|E]+){3}$/gm);\n\n      if (linesMatch) {\n         for (let line of linesMatch) {\n            line = line.trim();            // how can we remove end of space in regex?\n            let split = line.split(/\\s+/);\n            let tag = split.shift();\n            if (typeof this[tag] === 'function') {\n               this[tag](split);\n            } else {\n               console.log(\"unexpected tag: \" + tag); // should not happened\n            }\n         }\n         // done reading, return the object.\n         return this.objs;\n      }\n   }\n\n   o(objName) {\n      this.objView = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"putIntoWorld\"]();\n      this.obj = this.objView.geometry;\n      this.objs.push( this.objView );\n\n      this.obj.clearAffected();\n      // assignedName\n      this.objView.name = objName;\n   }\n\n   g(groupNames) {\n      if (!this.objView) {\n         this.objView = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"putIntoWorld\"]();\n         this.obj = this.objView.geometry;\n         this.objs.push( this.objView );\n      }\n      // to be implemented later\n\n   }\n\n   s(groupNumber) {\n      // to be implemented later\n   }\n\n   v(vertex) {\n      // should we do error check?\n      const vert = this.obj.addVertex(vertex);\n      this.realVertices.push(vert.index);\n      this.vertexCount++;\n   }\n\n   f(index) {\n      const faceIndex = [];\n      for (let i of index) {\n         let split = i.split('/');\n         let idx = split[0] - 1;          // convert 1-based index to 0-based index.\n         if ( (idx >= 0) && (idx < this.obj.vertices.size)) {\n            faceIndex.push( this.realVertices[idx] );\n         } else {\n            console.log(\"face index out of bound: \" + idx);\n         }\n      }\n      let polygonIndex = this.obj.addPolygon(faceIndex);\n      if (polygonIndex === null) {\n         this.non_manifold.push( this.polygonCount );    // addup failure.\n      }\n      //if (!this.obj.sanityCheck()) {\n      //   console.log(\"polygon # \" + this.polygonCount + \" not sane\");\n      //}\n      this.polygonCount++;\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/plugins/wavefront_obj.js?");

/***/ }),

/***/ "./js/wings3d.js":
/*!***********************!*\
  !*** ./js/wings3d.js ***!
  \***********************/
/*! exports provided: start_halt, onReady, start, log, interposeLog, createMask, GROUND_GRID_SIZE, CAMERA_DIST, action, addActionConstant, bindAction, runAction, setInteraction, ezFetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start_halt\", function() { return start_halt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onReady\", function() { return onReady; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interposeLog\", function() { return interposeLog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createMask\", function() { return createMask; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GROUND_GRID_SIZE\", function() { return GROUND_GRID_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CAMERA_DIST\", function() { return CAMERA_DIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"action\", function() { return action; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addActionConstant\", function() { return addActionConstant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindAction\", function() { return bindAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"runAction\", function() { return runAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setInteraction\", function() { return setInteraction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ezFetch\", function() { return ezFetch; });\n/* harmony import */ var _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_gl */ \"./js/wings3d_gl.js\");\n/*\n//  wings3d.js\n//     The start module of Wings 3D. Port,\n//\n// Original Erlang Version from Bjorn Gustavsson's Wings 3D\n//\n// 12-11-2017: convert to es6 module.\n*/\n\n//import * as View from './wings3d_view';\n//import * as Interact from './wings3d_interact';\n\n//\n// onReady. \n//\nlet isDocumentReady = false;\nlet deferredList = [];\nfunction onReady(fn) {\n   // If the DOM is already ready\n   if ( isDocumentReady ) {\n      fn();\n   } else {\n     // Add the function to the wait list\n     deferredList.push( fn );\n   }\n   return this;\n };\n// The ready event handler and self cleanup method\nlet _canvasID = '';\nfunction onLoad(ev) {\n\tdocument.removeEventListener( \"DOMContentLoaded\", onLoad);\n\t//window.removeEventListener( \"load\", onLoad);\n\tinit(_canvasID);\n}\nfunction start(canvas) {\n   // automatically start\n   if (document.readyState != 'loading'){\n      init(canvas);\n   } else {\n      _canvasID = canvas;\n      document.addEventListener('DOMContentLoaded', onLoad );\n   }\n}\n\n//-- end of ready --------------\n\n// a few polyfill\nif (NodeList.prototype[Symbol.iterator] === undefined) {\n   NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; // Microsoft Edge not support yet.\n}\n\n\n// log, does nothing for now, debug build?\nlet interpose = []; \nfunction log(action, value) {\n   for (let logFn of interpose) {\n      logFn(action, value);\n   }\n};\nfunction interposeLog(logFn, insert) {\n   if (insert) {\n      interpose.push( logFn );\n   } else {\n      let index = interpose.indexOf(logFn);\n      if (index > -1) {\n         interpose.splice(index, 1);\n      }\n   }\n};\n\n// utility function\nfunction createMask() {  // from mozilla doc\n   let nMask = 0, nFlag = 0, nLen = arguments.length > 32 ? 32 : arguments.length;\n   for (nFlag; nFlag < nLen; nMask |= arguments[nFlag] << nFlag++);\n   return nMask;\n}\n\n// define constants\nconst GROUND_GRID_SIZE = 1;\nconst CAMERA_DIST = 8.0*GROUND_GRID_SIZE;\n\n//make_geom_window(GeomGL, St) ->\n    //Props = initial_properties(),        \n    //wings_wm:new(geom, GeomGL, Op),\n    //[wings_wm:set_prop(geom, K, V)|| {K,V} <- Props],\n    //wings_wm:set_dd(geom, geom_display_lists),\n    //set_drag_filter(geom),\n    //..wings_frame:register_win(GeomGL, geom, [top, {title, geom_title(geom)}]),\n    //GeomGL.\n\nfunction init(canvasID) {\n   // webgl context, handle first, and available.\n   Object(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"createWebGLContext\"])(canvasID);\n   // wings_text:init(), setting font\n   isDocumentReady = true;\n\n   // now run through the defered list.\n   for (let fn of deferredList) {\n      fn();\n   }\n/*    wings_pref:init(),\n    wings_hotkey:set_default(),\n    wings_pref:load(),\n    wings_lang:init(),\n    wings_plugin:init(),\n    wings_sel_cmd:init(),\n    wings_file:init(),\n\n    St0 = new_st(),\n    St1 = wings_sel:reset(St0),\n    St2 = wings_undo:init(St1),\n    //..St = wings_shape:create_folder_system(St2),\n\n    //..wings_image:init(wings_io:get_process_option()),\n    wings_color:init(),\n    wings_io:init(),\n*/\n   //camera.createCamera();\n   //Camera.init();\n//    wings_vec:init();\n\n   //view.createView();\n//   View.init();\n\n   //contextmenu.createMenuHandler(view, \"content\");\n//   Contextmenu.init(\"content\", \"popupmenu\");\n   //Buttonbar.createButtonBarHandler();\n//   Buttonbar.init();\n//   Interact.init();\n   //createGuideTour();\n /*   wings_u:caption(St),\n    wings_file:init_autosave(),\n    wings_pb:start_link(Frame),\n    wings_dialog:init(),\n    wings_job:init(),\n    wings_develop:init(),\n    wings_tweak:init(),\n\n//    open_file(File),\n*/\n      // prompt for quitting\n      window.addEventListener(\"beforeunload\", confirmation);\n\n      //my.ui.tutor.tours.about();\n   };\n\nfunction confirmation(ev) {\n   // check if not saved then ask if want to quit, if nothing then just quit.\n   const confirmMessage = \"Are you sure you want to quit?\";\n   ev.returnValue = confirmMessage;      // Gecko, Trident, Chrome 34+\n   return confirmMessage;                 // Gecko, WebKit, Chrome <34\n};\n\n\nfunction start_halt() {\n      // closed resource\n\n      // halt for other reason. probably won't happen in non-erlang environment\n};\n  /* my.new_st = function() {\n      Empty = gb_trees:empty(),\n      return #st{shapes=Empty,\n                 selmode=face,\n                 sel=[],\n                 ssels=Empty,\n                 mat=wings_material:default(),\n                 saved=true,\n                 onext=1,\n                 repeatable=ignore,\n                 ask_args=none,\n                 drag_args=none,\n                 def={ignore,ignore}\n                }\n   };*/\n\nlet interactFn;\nfunction setInteraction(interact) {\n   interactFn = interact;\n}\nconst lastMouseDown = [null, null, null];\nfunction handleContextmenu(ev) {\n   ev.preventDefault();\n   return false;\n}\nfunction handleMouseDown(ev) {\n   if (ev.button <= 2) {\n      lastMouseDown[ev.button] = ev.currentTarget;\n   } else {\n      console.log(\"Amazing: mouse button is \" + ev.button);\n   }\n   //ev.stopImmediatePropagation();\n};\nfunction handleMouseUp(ev) {\n   if (ev.button <= 2) {\n      let lastDownEvent = lastMouseDown[ev.button];\n      if (lastDownEvent) {\n         if (lastDownEvent === ev.currentTarget) {\n            // now we do proper clicking\n            runAction(ev.button, ev.currentTarget.id, ev);\n         }\n      }\n   }\n   // reset\n   lastMouseDown[0] = lastMouseDown[1] = lastMouseDown[2] = null;\n   //ev.stopImmediatePropagation();\n};\nfunction bindAction(menuItem, button, id, fn) {\n   if (action.hasOwnProperty(id)) {\n      if (!Array.isArray(action[id])) {\n         action[id] = [null, null, null];\n         if (menuItem) {\n            menuItem.addEventListener(\"mousedown\", handleMouseDown);\n            menuItem.addEventListener(\"mouseup\", handleMouseUp);\n            menuItem.addEventListener(\"contextmenu\", handleContextmenu);  // no ops.\n         }\n      }\n      action[id][button] = fn;\n   }\n};\nfunction runAction(button, id, event) {\n   if (action.hasOwnProperty(id)) {\n      const fn = action[id][button];\n      if (fn) {\n         if (interactFn) {\n            if (interactFn(id, event)) {\n               fn(event);\n            }\n         } else {\n            fn(event);\n         }\n      }\n   } else {\n      console.log(\"unrecognized action: \" + id);\n   }\n}\nfunction notImplemented(obj) {\n   console.log( obj.name + \" action is not implemented\");\n}\n// log action constant\nconst action = {\n   cameraModeEnter: () => {notImplemented(undefined);},\n   cameraModeExit: () => {notImplemented(undefined);},\n   cameraZoom: () => {notImplemented(undefined);},\n   contextMenu: () => {notImplemented(undefined);},\n   createCubeDialog: () => {notImplemented(undefined);},\n   // fileMenu\n   fileMenu: () => {notImplemented(undefined);},\n   importMenu: () => {notImplemented(undefined);},\n   exportMenu: () => {notImplemented(undefined);},\n   // view action, button bar\n   openSidebar: () => {notImplemented(undefined);},\n   toggleVertexMode: () => {notImplemented(undefined);},\n   toggleEdgeMode: () => {notImplemented(undefined);},\n   toggleFaceMode: () => {notImplemented(undefined);},\n   toggleBodyMode: () => {notImplemented(undefined);},\n   toggleMultiMode: () => {notImplemented(undefined);},\n   redoEdit: () => {notImplemented(undefined);},\n   undoEdit: () => {notImplemented(undefined);},\n   // preference Group\n   preferenceButton: ()=>{notImplemented(undefined);},\n   toggleOrtho: ()=> {notImplemented(undefined);},\n   toggleGround: ()=>{notImplemented(undefined);},\n   toggleAxes: ()=> {notImplemented(undefined);},\n   // createObject Menu\n   createCube: () => {notImplemented(undefined);},\n   createCubePref: () =>{notImplemented(undefined);},\n   createMaterial: () => {notImplemented(undefined);},\n   // outliner/geometory\n   toggleObjectSelect: () => {notImplemented(undefined);},\n   toggleObjectVisibility: () =>{notImplemented(undefined);},\n   toggleObjectLock: ()=>{notImplemented(undefined);},\n   toggleWireMode: ()=>{notImplemented(undefined);},\n   objectRename: ()=>{notImplemented(undefined);},\n   objectDelete: ()=>{notImplemented(undefined);},\n   objectDuplicate: ()=>{notImplemented(undefined);},\n   createGroup: ()=>{notImplemented(undefined);},\n   createGroupWorld: ()=>{notImplemented(undefined);},\n   importImageFileGUI: ()=>{notImplemented(undefined);},\n   // selection menu\n   selectMenu: () => {notImplemented(undefined);},\n   deselect: () => {notImplemented(undefined);},\n   more: () => {notImplemented(undefined);},\n   less: () => {notImplemented(undefined);},\n   similar: () => {notImplemented(undefined);},\n   all: () => {notImplemented(undefined);},\n   invert: () => {notImplemented(undefined);},\n   adjacent: () => {notImplemented(undefined);},\n   edgeLoopMenu: () => {notImplemented(undefined);},\n   edgeLoop1:  () => {notImplemented(undefined);},\n   nthEdgeLoopMenu: () => {notImplemented(undefined);},\n   edgeLoop2: () => {notImplemented(undefined);},\n   edgeLoop3: () => {notImplemented(undefined);},\n   edgeLoopN: () => {notImplemented(undefined);},\n   edgeRing1:  () => {notImplemented(undefined);},\n   nthEdgeRingMenu: () => {notImplemented(undefined);},\n   edgeRing2: () => {notImplemented(undefined);},\n   edgeRing3: () => {notImplemented(undefined);},\n   edgeRingN: () => {notImplemented(undefined);},\n   //menu action\n   bodyDelete: () => {notImplemented(undefined);},\n   bodyRename: () => {notImplemented(undefined);},\n   bodyDuplicateMoveMenu: () => {notImplemented(undefined);},\n   bodyDuplicateMoveX: () => {notImplemented(undefined);},\n   bodyDuplicateMoveY: () => {notImplemented(undefined);},\n   bodyDuplicateMoveZ: () => {notImplemented(undefined);},\n   bodyDuplicateMoveFree: () => {notImplemented(undefined);},\n   bodyMoveMenu: () => {notImplemented(undefined);},\n   bodyMoveX: () => {notImplemented(undefined);},\n   bodyMoveY: () => {notImplemented(undefined);},\n   bodyMoveZ: () => {notImplemented(undefined);},\n   bodyMoveFree: () => {notImplemented(undefined);},\n   bodyRotateMenu: () => {notImplemented(undefined);},\n   bodyRotateX: () => {notImplemented(undefined);},\n   bodyRotateY: () => {notImplemented(undefined);},\n   bodyRotateZ: () => {notImplemented(undefined);},\n   bodyRotateFree: () => {notImplemented(undefined);},\n   bodyInvert: () => {notImplemented(undefined);},\n   bodyCombine: () => {notImplemented(undefined);},\n   bodySeparate: () => {notImplemented(undefined);},\n   bodyFlipMenu: () => {notImplemented(undefined);},\n   bodyFlipX: () => {notImplemented(undefined);},\n   bodyFlipY: () => {notImplemented(undefined);},\n   bodyFlipZ: () => {notImplemented(undefined);},\n   bodyScaleUniform: ()=> {notImplemented(undefined);},\n   bodyScaleAxis: ()=> {notImplemented(undefined);},\n   bodyScaleAxisX: ()=> {notImplemented(undefined);},\n   bodyScaleAxisY: ()=> {notImplemented(undefined);},\n   bodyScaleAxisZ: ()=> {notImplemented(undefined);},\n   bodyScaleRadial: ()=> {notImplemented(undefined);},\n   bodyScaleRadialX: ()=> {notImplemented(undefined);},\n   bodyScaleRadialY: ()=> {notImplemented(undefined);},\n   bodyScaleRadialZ: ()=> {notImplemented(undefined);},\n   bodyPlaneCut: ()=> {notImplemented(undefined);},\n   bodyPlaneCutX: ()=> {notImplemented(undefined);},\n   bodyPlaneCutY: ()=> {notImplemented(undefined);},\n   bodyPlaneCutZ: ()=> {notImplemented(undefined);},\n   bodySlice: () => {notImplemented(undefined);},\n   bodySliceX: () => {notImplemented(undefined);},\n   bodySliceY: () => {notImplemented(undefined);},\n   bodySliceZ: () => {notImplemented(undefined);},\n   bodyWeld: () => {notImplemented(undefined);},\n   // edge\n   cutMenu: () => {notImplemented(undefined);},\n   cutLine2: () => {notImplemented(undefined);},\n   cutLine3: () => {notImplemented(undefined);},\n   cutLine4: () => {notImplemented(undefined);},\n   cutLine5: () => {notImplemented(undefined);},\n   cutLine10: () => {notImplemented(undefined);},\n   cutAsk: () => {notImplemented(undefined);},\n   cutAndConnect: () =>{notImplemented(undefined);},\n   edgeBevel: () =>{notImplemented(undefined);},\n   edgeDissolve: () =>{notImplemented(undefined);},\n   edgeCollapse: () =>{notImplemented(undefined);},\n   edgeMoveMenu: () => {notImplemented(undefined);},\n   edgeMoveX: () => {notImplemented(undefined);},\n   edgeMoveY: () => {notImplemented(undefined);},\n   edgeMoveZ: () => {notImplemented(undefined);},\n   edgeMoveFree: () => {notImplemented(undefined);},\n   edgeMoveNormal: () => {notImplemented(undefined);},\n   edgeRotateMenu: () => {notImplemented(undefined);},\n   edgeRotateX: () => {notImplemented(undefined);},\n   edgeRotateY: () => {notImplemented(undefined);},\n   edgeRotateZ: () => {notImplemented(undefined);},\n   edgeRotateFree: () => {notImplemented(undefined);},\n   edgeExtrudeMenu: () =>{notImplemented(undefined);}, // submenu\n   edgeExtrudeNormal: () =>{notImplemented(undefined);},\n   edgeExtrudeFree: () =>{notImplemented(undefined);},\n   edgeExtrudeX: () =>{notImplemented(undefined);},\n   edgeExtrudeY: () =>{notImplemented(undefined);},\n   edgeExtrudeZ: () =>{notImplemented(undefined);},\n   edgeCrease: () =>{notImplemented(undefined);},\n   edgeLoopCut: () =>{notImplemented(undefined);},\n   edgeCorner: () =>{notImplemented(undefined);},\n   edgeSlide: () =>{notImplemented(undefined);},\n   edgeFlatten: ()=> {notImplemented(undefined);},\n   edgeFlattenX: ()=> {notImplemented(undefined);},\n   edgeFlattenY: ()=> {notImplemented(undefined);},\n   edgeFlattenZ: ()=> {notImplemented(undefined);},\n   edgeScaleUniform: ()=> {notImplemented(undefined);},\n   edgeScaleAxis: ()=> {notImplemented(undefined);},\n   edgeScaleAxisX: ()=> {notImplemented(undefined);},\n   edgeScaleAxisY: ()=> {notImplemented(undefined);},\n   edgeScaleAxisZ: ()=> {notImplemented(undefined);},\n   edgeScaleRadial: ()=> {notImplemented(undefined);},\n   edgeScaleRadialX: ()=> {notImplemented(undefined);},\n   edgeScaleRadialY: ()=> {notImplemented(undefined);},\n   edgeScaleRadialZ: ()=> {notImplemented(undefined);},\n   edgeHardness: ()=> {notImplemented(undefined);},\n   edgeSoft: ()=> {notImplemented(undefined);},\n   edgeHard: ()=> {notImplemented(undefined);},\n   edgeInvert: ()=> {notImplemented(undefined);},\n   // face\n   faceExtrudeMenu: () =>{notImplemented(undefined);},\n   faceExtrudeX: () =>{notImplemented(undefined);},\n   faceExtrudeY: () =>{notImplemented(undefined);},\n   faceExtrudeZ: () =>{notImplemented(undefined);},\n   faceExtrudeFree: () =>{notImplemented(undefined);},\n   faceExtrudeNormal: () =>{notImplemented(undefined);},\n   faceDissolve: () =>{notImplemented(undefined);},\n   faceCollapse: () =>{notImplemented(undefined);},\n   faceMoveMenu: () =>{notImplemented(undefined);},\n   faceMoveX: () => {notImplemented(undefined);},\n   faceMoveY: () => {notImplemented(undefined);},\n   faceMoveZ: () => {notImplemented(undefined);},\n   faceMoveFree: () => {notImplemented(undefined);},\n   faceMoveNormal: () => {notImplemented(undefined);},\n   faceRotateMenu: () => {notImplemented(undefined);},\n   faceRotateX: () => {notImplemented(undefined);},\n   faceRotateY: () => {notImplemented(undefined);},\n   faceRotateZ: () => {notImplemented(undefined);},\n   faceRotateFree: () => {notImplemented(undefined);},\n   faceScaleUniform: () => {notImplemented(undefined);},\n   faceBridge: () => {notImplemented(undefined);},\n   faceInset: () => {notImplemented(undefined);},\n   faceBevel: () => {notImplemented(undefined);},\n   faceBump: () => {notImplemented(undefined);},\n   faceIntrude: () => {notImplemented(undefined);},\n   facePutOn: () => {notImplemented(undefined);},\n   faceLift: () => {notImplemented(undefined);},\n   faceMirror: () => {notImplemented(undefined);},\n   faceFlatten: () =>  {notImplemented(undefined);},\n   faceFlattenNormal: ()=> {notImplemented(undefined);},\n   faceFlattenX: () => {notImplemented(undefined);},\n   faceFlattenY: () =>  {notImplemented(undefined);},\n   faceFlattenZ: () =>  {notImplemented(undefined);},\n   faceScaleAxis: ()=> {notImplemented(undefined);},\n   faceScaleAxisX: ()=> {notImplemented(undefined);},\n   faceScaleAxisY: ()=> {notImplemented(undefined);},\n   faceScaleAxisZ: ()=> {notImplemented(undefined);},\n   faceScaleRadial: ()=> {notImplemented(undefined);},\n   faceScaleRadialX: ()=> {notImplemented(undefined);},\n   faceScaleRadialY: ()=> {notImplemented(undefined);},\n   faceScaleRadialZ: ()=> {notImplemented(undefined);},\n   facePlaneCut: ()=> {notImplemented(undefined);},\n   facePlaneCutX: ()=> {notImplemented(undefined);},\n   facePlaneCutY: ()=> {notImplemented(undefined);},\n   facePlaneCutZ: ()=> {notImplemented(undefined);},\n   // vertex\n   vertexConnect: () => {notImplemented(undefined);},\n   vertexDissolve: () => {notImplemented(undefined);},\n   vertexCollapse: () => {notImplemented(undefined);},\n   vertexMoveMenu: () => {notImplemented(undefined);},\n   vertexMoveX: () => {notImplemented(undefined);},\n   vertexMoveY: () => {notImplemented(undefined);},\n   vertexMoveZ: () => {notImplemented(undefined);},\n   vertexMoveFree: () => {notImplemented(undefined);},\n   vertexMoveNormal: () => {notImplemented(undefined);},\n   vertexRotateMenu: () => {notImplemented(undefined);},\n   vertexRotateX: () => {notImplemented(undefined);},\n   vertexRotateY: () => {notImplemented(undefined);},\n   vertexRotateZ: () => {notImplemented(undefined);},\n   vertexRotateFree: () => {notImplemented(undefined);},\n   vertexBevel: () => {notImplemented(undefined);},\n   vertexExtrudeMenu: () =>{notImplemented(undefined);}, // submenu\n   vertexExtrudeNormal: () =>{notImplemented(undefined);},\n   vertexExtrudeFree: () =>{notImplemented(undefined);},\n   vertexExtrudeX: () =>{notImplemented(undefined);},\n   vertexExtrudeY: () =>{notImplemented(undefined);},\n   vertexExtrudeZ: () =>{notImplemented(undefined);},\n   vertexWeld: () =>{notImplemented(undefined);},\n   vertexFlatten: ()=>  {notImplemented(undefined);},\n   vertexFlattenX: ()=>  {notImplemented(undefined);},\n   vertexFlattenY: ()=>  {notImplemented(undefined);},\n   vertexFlattenZ: ()=>  {notImplemented(undefined);},\n   vertexScaleUniform: ()=> {notImplemented(undefined);},\n   vertexScaleAxis: ()=> {notImplemented(undefined);},\n   vertexScaleAxisX: ()=> {notImplemented(undefined);},\n   vertexScaleAxisY: ()=> {notImplemented(undefined);},\n   vertexScaleAxisZ: ()=> {notImplemented(undefined);},\n   vertexScaleRadial: ()=> {notImplemented(undefined);},\n   vertexScaleRadialX: ()=> {notImplemented(undefined);},\n   vertexScaleRadialY: ()=> {notImplemented(undefined);},\n   vertexScaleRadialZ: ()=> {notImplemented(undefined);},\n   // guide tour\n   helpMenu: () => {notImplemented(undefined);},\n   about: () => {notImplemented(undefined);},\n   introduction: () => {notImplemented(undefined);},\n   basicCommands: () => {notImplemented(undefined);},\n   tableTutor: () => {notImplemented(undefined);},\n};\nfunction addActionConstant(id) {\n   action[id] = () => {notImplemented(this);}\n}\n\n//\n// @Params: pathToResource \n//\n// code from https://css-tricks.com/using-fetch/\nconst ezFetch = (function() {\n   return function(pathToResource) { \n      return fetch(pathToResource)\n      .then(handleResponse)\n      // to be supplied by user. -->\n      //.then(data => console.log(data))\n      //.catch(error => console.log(error));\n      // <---\n   }\n \n function handleResponse (response) {\n   let contentType = response.headers.get('content-type')\n   if (contentType.includes('application/json') || contentType.includes('application/jason')) { // tcl wub problems?\n     return handleJSONResponse(response)\n   } else if (contentType.includes('text/html')) {\n     return handleTextResponse(response)\n   } else {\n     // Other response types as necessary. I haven't found a need for them yet though.\n     throw new Error(`Sorry, content-type ${contentType} not supported`)\n   }\n }\n \n function handleJSONResponse (response) {\n   return response.json()\n     .then(json => {\n       if (response.ok) {\n         return json\n       } else {\n         return Promise.reject(Object.assign({}, json, {\n           status: response.status,\n           statusText: response.statusText\n         }))\n       }\n     })\n }\n function handleTextResponse (response) {\n   return response.text()\n     .then(text => {\n       if (response.ok) {\n         return json\n       } else {\n         return Promise.reject({\n           status: response.status,\n           statusText: response.statusText,\n           err: text\n         })\n       }\n     })\n }\n}());\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d.js?");

/***/ }),

/***/ "./js/wings3d_bodymads.js":
/*!********************************!*\
  !*** ./js/wings3d_bodymads.js ***!
  \********************************/
/*! exports provided: BodyMadsor, DeleteBodyCommand, DuplicateBodyCommand, RenameBodyCommand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BodyMadsor\", function() { return BodyMadsor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeleteBodyCommand\", function() { return DeleteBodyCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DuplicateBodyCommand\", function() { return DuplicateBodyCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenameBodyCommand\", function() { return RenameBodyCommand; });\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/* harmony import */ var _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_facemads */ \"./js/wings3d_facemads.js\");\n/* harmony import */ var _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_edgemads */ \"./js/wings3d_edgemads.js\");\n/* harmony import */ var _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_vertexmads */ \"./js/wings3d_vertexmads.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n//\n// bodymadsor. \n//\n\n\n   // for switching\n\n\n\n\n\n\n\n\n\n\nclass BodyMadsor extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"Madsor\"] {\n   constructor() {\n      super('Body');\n      const self = this;\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItemMode\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyDelete.name, function(ev) {\n            const command = new DeleteBodyCommand(self.getSelected());\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"]( command );\n            command.doIt(); // delete current selected.\n         }, this, 'Backspace');\n\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyRename.name, function(ev) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"runDialog\"]('#renameDialog', ev, function(form) {\n               const data = _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"extractDialogValue\"](form);\n               const command = new RenameBodyCommand(self.getSelected(), data);\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"]( command );\n               command.doIt();   // rename\n            }, function(form) {\n               const content = form.querySelector('div');\n               let labels = form.querySelectorAll('label');\n               for (let label of labels) {\n                  content.removeChild(label);\n               }\n               // add input name \n               let array = self.getSelected();\n               for (let cage of array) {\n                  const label = document.createElement('label');\n                  label.textContent = cage.name;\n                  const input = document.createElement('input');\n                  input.type = \"text\";\n                  input.name = cage.uuid;\n                  input.placeholder = cage.name;\n                  label.appendChild(input);\n                  content.appendChild(label);\n               }\n            });\n       });\n      const duplicateMove = [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyDuplicateMoveX, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyDuplicateMoveY, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyDuplicateMoveZ];\n      // movement for (x, y, z)\n      for (let axis=0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](duplicateMove[axis].name, function(ev) { //action.bodyDulipcateMoveX(Y,Z)\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseMove\"](new DuplicateMouseMoveAlongAxis(self, axis, self.getSelected()));\n            });\n      }\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyDuplicateMoveFree.name, function(ev) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseMove\"](new DuplicateMoveFreePositionHandler(self, self.getSelected()));\n         });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyInvert.name, (ev)=> {\n         const command = new InvertBodyCommand(this);\n         command.doIt();\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n        });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyCombine.name, (ev)=> {\n         const command = new CombineBodyCommand(this);\n         if (command.doIt()) {   // do we really have 2 + objects?\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n         }\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodySeparate.name, (ev)=> {\n         const command = new SeparateBodyCommand(this);\n         if (command.doIt()) {   // check if separable.\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n         }\n       });\n      const flip = [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyFlipX, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyFlipY, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyFlipZ];\n      // flip for (x, y, z)\n      for (let axis=0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](flip[axis].name, (ev) => { //action.bodyFlipX(Y,Z)\n            //View.undoQueue(new FlipBodyAxis(this, axis));\n            const command = new FlipBodyAxis(this, axis);\n            command.doIt();\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n          });\n      }\n      const axisVec = [[1,0,0], [0,1,0], [0,0,1]];\n      const slice = [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodySliceX, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodySliceY, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodySliceZ];\n      for (let axis = 0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](slice[axis].name, (ev) => {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"runDialog\"]('#sliceBodyDialog', ev, (form)=> {\n               const data = form.querySelector('input[name=\"amountRange\"');\n               if (data) {\n                  const number = parseInt(data.value, 10);\n                  if ((number != NaN) && (number > 0) && (number < 100)) { // sane input\n                     const command = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"GenericEditCommand\"](this, this.slice, [axisVec[axis], number], this.undoPlaneCut);\n                     if (command.doIt()) {\n                        const vertexMadsor = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"currentMode\"]();   // assurely it vertexMode\n                        vertexMadsor.andConnectVertex(command);\n                     } else { // should not happened, make some noise\n\n                     }\n                  }\n               }\n             });\n          });\n      }\n      // weld\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].bodyWeld.name, (ev)=> {\n         const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"GenericEditCommand\"](this, this.weld, undefined, this.undoWeld);\n         if (cmd.doIt()) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](cmd);\n         }\n       });\n   }\n\n   getSelected() {\n      const selection = [];\n      for (let cage of this.selectedCage()) {\n         selection.push(cage);\n      }\n      return selection;\n   }\n\n   snapshotPosition() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotBodyPosition);\n   }\n\n   snapshotTransformGroup() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotTransformBodyGroup);\n   }\n\n   combine(cageSelection) {\n      if (cageSelection === undefined) {\n         cageSelection = [];\n         for (let cage of this.selectedCage()) {\n            cageSelection.push( cage );\n         }\n      }\n      // needs least 2 selected cage2.\n      if (cageSelection.length >= 2) {\n         // now do merge operation.\n         const combine = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"makeCombineIntoWorld\"](cageSelection);\n         combine.name = cageSelection[0].name;\n         combine.selectBody();\n         return {combine: combine, oldSelection: cageSelection};\n      }\n      return null;\n   }\n   undoCombine(combine) {\n      if (combine) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](combine.combine);\n         for (let cage of combine.oldSelection) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](cage);  // restore oldCage\n         }\n      }\n   }\n\n   separate() {\n      const selection = [];\n      for (let cage of this.selectedCage()) {\n         let snapshot = cage.separate();\n         if (snapshot.length > 0) {\n            selection.push( {preview: cage, snapshot: snapshot} );\n         }\n      }\n      for (let separate of selection) {\n         // remove original\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](separate.preview);\n         // add the separates one.\n         for (let preview of separate.snapshot) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](preview);     // has to addToWorld after separate all selection, or we will mess up the iteration.\n         }\n      }\n      return selection;\n   }\n   undoSeparate(separateSelection) {\n      for (let separate of separateSelection) {\n         for (let preview of separate.snapshot) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](preview);\n         }\n         // addback the original one\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](separate.preview);\n      }\n   }\n\n   invert() {\n      for (let cage of this.selectedCage()) {\n         cage.invertBody();\n      }\n      // invert the draftBench's preview and update\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"updateWorld\"]();\n      this.hiliteView = null; // invalidate hilite\n   }\n\n   flipAxis(snapShotPivot, axis) {\n      this.doAll(snapShotPivot, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.flipBodyAxis, axis);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"updateWorld\"]();\n   }\n\n   planeCuttable(plane) {\n      return this.resultAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.planeCuttableFace, plane);\n   }\n   planeCut(plane) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.planeCutBody, plane);\n   }\n   undoPlaneCut(snapshots) { // undo of splitEdge.\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSplitOrBevelEdge);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreBodyMode\"](snapshots);\n   }\n\n   slice(planeNormal, numberOfPart) {\n      const snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.sliceBody, planeNormal, numberOfPart);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"](snapshots);\n      return snapshots;\n   }\n\n   weld(tolerance = 0.001) {\n      const extent = {min: vec3.fromValues(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), \n                      max: vec3.fromValues(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE)};\n      const selection = [];\n      // adds up all selected object's face\n      for (let cage of this.selectedCage()) {\n         cage.getBodySelection(selection, extent);\n      }\n      // sort by longest length.\n      let order = _wings3d_util__WEBPACK_IMPORTED_MODULE_8__[\"getAxisOrder\"](extent);\n      selection.sort( (a, b) => {\n         for (let i = 0; i < 3; ++i) {\n            let result = a.center[order[i]] - b.center[order[i]];\n            if (result !== 0.0) {\n               return result;\n            }\n         }\n         return (a.polygon.index - b.polygon.index);\n       });\n\n      // find weldable pair\n      const merged = _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].findOverlapFace(order, selection, tolerance); \n      // now find the contours of potential mergers.\n      const weldContours = _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].findWeldContours(merged);\n      if (weldContours !== false) {\n         // make holes of weldable polygons.\n         const holes = _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].weldHole(merged);\n         // combine cages\n         const combinedCages = [];\n         const combined = new Map;\n         for (let cages of weldContours.combineCages) {\n            const result = this.combine(cages);\n            combined.set(cages, result);\n            combinedCages.push( result );\n         }\n         // now weld the contours\n         const mergeCage = _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].weldBody(combined, weldContours);\n         // goto vertexMode\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"](combinedCages);\n\n         // return undo info\n         return [{holes: holes, weldContours: mergeCage, combinedCages: combinedCages}];\n      }\n      // unable to weld\n      return [];\n   }\n   undoWeld(snapshots) {\n      const weld = snapshots[0]; // have to enclose in a array.\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreBodyMode\"]();\n      // splice with inner\n      _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].undoWeldBody(weld.weldContours);\n      // undo combine\n      for (let combine of weld.combinedCages) {\n         this.undoCombine(combine);\n      }\n      // restore holes\n      _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].undoWeldHole(weld.holes);\n   }\n\n   centroid() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.bodyCentroid);\n   }\n\n   dragSelect(cage, hilite, selectArray, onOff) {\n      if (hilite.edge !== null) {\n       // if (cage.dragSelectFace(this.currentEdge, onOff)) {\n       //     selectArray.push(this.currentEdge);\n       // }\n      }\n   }\n\n   // select, hilite\n   selectStart(preview, hilite) {\n      // check not null, shouldn't happened\n      if (hilite.cage !== null) {\n         var onOff = preview.selectBody();\n         return new DragBodySelect(this, preview, hilite.edge, onOff);\n      }    \n   }\n\n   selectBody(snapshots) { // use for unselect by similarSelection.\n      for (let cage of snapshots) {\n         cage.selectBody();\n      }\n   }\n\n   similarSelection() {\n      // first compute selected body's metric\n      const snapshot = new Set;\n      for (let cage of this.selectedCage()) {\n         const size = cage._getGeometrySize();\n         const metric = size.vertex*3 + size.edge*2 + size.face;\n         snapshot.add(metric);\n      }\n      const restore = [];\n      // now check if some of the unselected bodys match selected body.\n      for (let cage of this.notSelectedCage()) {\n         const size = cage._getGeometrySize();\n         const metric = size.vertex*3 + size.edge*2 + size.face;\n         if (snapshot.has(metric)) {\n            cage.selectBody();\n            restore.push(cage);\n         }\n      }\n      if (restore.length > 0) {\n         return {undo: this.selectBody, snapshots: restore};   // restore all \n      }\n      return false;\n   }\n\n   adjacentSelection() {\n      return false;   // does nothing.\n   }\n\n   moreSelection() {\n      return false;      // does nothing.\n   }\n\n   _resetSelection(cage) {\n      cage._resetSelectBody();\n   }\n\n   _restoreSelection(cage, snapshot) {\n      cage.restoreBodySelection(snapshot);\n   }\n\n   toggleFunc(toMadsor) {\n//      this.hiliteView = null;\n//      this.hideOldHilite();\n//      this.hiliteView = null;\n      var redoFn;\n      var snapshots;\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromBodyToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromBodyToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_2__[\"EdgeMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromBodyToEdgeSelect);\n      } else {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreMultiMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromBodyToMultiSelect);\n      }\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"ToggleModeCommand\"](redoFn, _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreBodyMode\"], snapshots));\n   }\n\n   restoreMode(toMadsor, snapshots) {\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromBodyToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromBodyToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_2__[\"EdgeMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromBodyToEdgeSelect);\n      } else {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromBodyToMultiSelect);\n      }\n   }\n}\n\n\nclass DragBodySelect extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"DragSelect\"] {\n   constructor(madsor, cage, halfEdge, onOff) {\n      super(madsor, cage, halfEdge, onOff);\n   }\n\n   finish() {\n      return new BodySelectCommand(this.select);\n   }\n}\n\nclass BodySelectCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(select) {\n      super();\n      this.select = select;\n   }\n\n   doIt() {\n      for (var [cage, halfEdges] of this.select) {\n         if (halfEdges.length > 0) {\n            cage.selectBody();\n         }\n      }\n   }\n\n   undo() {\n      this.doIt();   // selectEdge, flip/flop, so\n   }\n\n}\n\nclass DeleteBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(previewCages) {\n      super();\n      this.previewCages = previewCages;\n   }\n\n   doIt() {\n      this.undoCage = [];\n      for (let previewCage of this.previewCages) {\n         this.undoCage.push( [previewCage, previewCage.parent] );\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](previewCage);\n      }\n   }\n\n   undo() {\n      for (let [previewCage, parent] of this.undoCage) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](previewCage, parent);\n      }\n   }\n}\n\nclass RenameBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(previewCages, data) {\n      super();\n      this.previewCages = previewCages;\n      this.newName = data;\n      this.oldName = new Map;\n   }\n\n   doIt() {\n      for (let cage of this.previewCages) {\n         if (this.newName.hasOwnProperty(cage.uuid)) {\n            if (!this.oldName.has(cage)) {\n               this.oldName.set(cage, cage.name);\n            }\n            cage.name = this.newName[cage.uuid];\n            geometryStatus(\"Object new name is \" + cage.name);\n         }\n      }\n   }\n\n   undo() {\n      for (let [cage, oldName] of this.oldName) {\n         cage.name = oldName;\n         geometryStatus(\"Object restore name to \" + cage.name);\n      }  \n   }\n}\n\n\nclass DuplicateBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(originalCages) {\n      super();\n      this.originalCages = originalCages;\n      this.duplicateCages = [];\n      for (let cage of originalCages) {\n         let duplicate = _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].duplicate(cage);\n         this.duplicateCages.push( duplicate );\n      }\n   }\n\n   _toggleOriginalSelected() {\n      for (let cage of this.originalCages) {\n         cage.selectBody();\n      }\n   }\n\n   doIt() {\n      for (let cage of this.duplicateCages) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](cage);\n         cage.selectBody();\n      }\n      this._toggleOriginalSelected();\n   }\n\n   undo() {\n      for (let cage of this.duplicateCages) {\n         cage.selectBody();                  // deselection before out\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](cage);\n      }\n      this._toggleOriginalSelected();        // reselected the original\n   }\n}\n\nclass DuplicateMouseMoveAlongAxis extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MouseMoveAlongAxis\"] {\n   constructor(madsor, axis, originalCages) {\n      const duplicateBodyCommand = new DuplicateBodyCommand(originalCages);\n      duplicateBodyCommand.doIt();\n      super(madsor, axis);\n      this.duplicateBodyCommand = duplicateBodyCommand;\n   }\n\n   doIt() {\n      this.duplicateBodyCommand.doIt();\n      super.doIt();     // movement.\n   }\n\n   undo() {\n      super.undo();\n      this.duplicateBodyCommand.undo();\n   }\n}\n\nclass DuplicateMoveFreePositionHandler extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveFreePositionHandler\"] {\n   constructor(madsor, originalCages) {\n      const duplicateBodyCommand = new DuplicateBodyCommand(originalCages);\n      duplicateBodyCommand.doIt();\n      super(madsor);\n      this.duplicateBodyCommand = duplicateBodyCommand;\n   }\n\n   doIt() {\n      this.duplicateBodyCommand.doIt();\n      super.doIt();     // movement.\n      return true;\n   }\n\n   undo() {\n      super.undo();\n      this.duplicateBodyCommand.undo();\n   }\n}\n\nclass InvertBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      this.madsor.invert();\n      return true;\n   }\n\n   undo() {\n      this.madsor.invert();\n   }   \n}\n\nclass CombineBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      this.combine = this.madsor.combine();\n      if (this.combine) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   undo() {\n      this.madsor.undoCombine(this.combine);\n      this.combine = null; // release memory\n   } \n};\n\n\nclass SeparateBodyCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      this.separate = this.madsor.separate();\n      return (this.separate.length > 0);\n   }\n\n   undo() {\n      this.madsor.undoSeparate(this.separate);\n      this.separate = null; // release memory\n   } \n};\n\n\nclass FlipBodyAxis extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor, axis) {\n      super();\n      this.madsor = madsor;\n      this.axis = axis;\n      this.pivot = madsor.centroid();\n   }\n\n   doIt() {\n      this.madsor.flipAxis(this.pivot, this.axis);\n      return true;\n   }\n\n   undo() {\n      this.madsor.flipAxis(this.pivot, this.axis);\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_bodymads.js?");

/***/ }),

/***/ "./js/wings3d_boundingvolume.js":
/*!**************************************!*\
  !*** ./js/wings3d_boundingvolume.js ***!
  \**************************************/
/*! exports provided: BoundingSphere, LooseOctree, Plane, Ray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundingSphere\", function() { return BoundingSphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LooseOctree\", function() { return LooseOctree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ray\", function() { return Ray; });\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/*   require glmatrix\n//\n// LooseOctree and BoundingSphere.\n*/\n\n\n\n\n\n\nconst BoundingSphere = function(polygon, center, radius) {\n   this.center = center;\n   this.radius = radius;\n   if (radius) {\n      this.radius2 = radius*radius;\n   }\n   this.polygon = polygon;\n   this.octree = null;\n};\n\nBoundingSphere.prototype.isLive = function() {\n   return (this.polygon.isVisible && this.polygon.isLive());\n};\n\nBoundingSphere.prototype.isIntersect = function(ray) {\n   return _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"intersectRaySphere\"](ray, this);\n};\n\nBoundingSphere.prototype.setSphere = function(sphere) {\n   this.center = sphere.center;\n   this.radius = sphere.radius;\n   this.radius2 = sphere.radius*sphere.radius;\n   if (this.octree) {\n      this.octree._move(this);\n   }\n};\n\nBoundingSphere.prototype.getBVHRoot = function() {\n   return this.octree.bvh.bvh.root;\n};\n\nBoundingSphere.computeSphere = function(polygon, center) {  // vec3\n   // get all the polygon's vertex. compute barycentric.\n   center.fill(0.0);\n   var ret = {center: center, radius: 0.0};\n   polygon.eachVertex( function(vertex) {\n      vec3.add(ret.center, ret.center, vertex.vertex);\n   });\n   vec3.scale(ret.center, ret.center, 1.0/polygon.numberOfVertex);\n   // get the furthest distance. that the radius.\n   polygon.eachVertex( function(vertex) {\n      var distance = vec3.distance(ret.center, vertex.vertex);\n      if (distance > ret.radius) {\n         ret.radius = distance;\n      }\n   });\n   return ret;\n};\n\n\n// simple minded bounding sphere builder.\nBoundingSphere.create = function(polygon, center) {\n   var sphere = BoundingSphere.computeSphere(polygon, center);\n   return new BoundingSphere(polygon, sphere.center, sphere.radius);\n}\nBoundingSphere.allocate = function(polygon) {\n   return new BoundingSphere(polygon);\n}\n\n\n// loose octree for ease of implementation, and adequate performance. AABB tree, OBB tree can wait if needed.\n// http://www.tulrich.com/geekstuff/partitioning.html by Thatcher Ulrich\nclass LooseOctree {  // this is really node\n   constructor(bvh, bound, level) {\n      this.bvh = bvh;\n      this.level = level;\n      this.node = [];\n      if (bound) {\n         this.bound = {center: vec3.clone(bound.center), halfSize: vec3.clone(bound.halfSize)};\n      }\n      //\n   }\n\n   *[Symbol.iterator]() {\n      yield this;\n      if (this.leaf) {\n         for (let i = 0; i < 8; ++i) {\n            const node = this.leaf[i];\n            if (node) {\n               yield* node;\n            }\n         }\n      }\n   }\n\n   getHalfSize() {\n      return this.bound.halfSize;\n   }\n\n   getBound(bound) {\n      vec3.copy(bound.center, this.bound.center);\n      vec3.copy(bound.halfSize, this.bound.halfSize);\n   }\n\n   getLooseBound(bound) {\n      vec3.copy(bound.center, this.bound.center);\n      vec3.scale(bound.halfSize, this.bound.halfSize, LooseOctree.kLOOSENESS);\n   }\n\n   getExtent(extent, looseNess = 1.0) {\n      for (let axis=0; axis < 3; ++axis) {\n         const length = this.bound.halfSize[axis]*looseNess;   \n         extent.min[axis] = this.bound.center[axis]-length;\n         extent.max[axis] = this.bound.center[axis]+length;\n      } \n   }\n\n   getLooseExtent(extent) {\n      this.getExtent(extent, LooseOctree.kLOOSENESS); // looseOctree's extent is 2x bigger.\n   }\n\n   static getOctant(sphere, bound) {\n      let index = 0;\n      const octant = [1, 2, 4];        // octant mapping\n      for (let axis = 0; axis < 3; ++axis) {\n         bound.halfSize[axis] /= 2;\n         if (sphere.radius > bound.halfSize[axis]) {  // does not fit in the children's bound\n            return -1;\n         } else if (sphere.center[axis] < bound.center[axis]) {\n            index += octant[axis];     // |= octant[axis] faster?\n            bound.center[axis] -= bound.halfSize[axis];\n         } else {\n            bound.center[axis] += bound.halfSize[axis];\n         }\n      }\n      return index;\n   }\n\n   check(duplicateSet) {\n      if (this.node) {\n         for (let sphere of this.node) {\n            if (duplicateSet.has(sphere)) {\n               console.log(\"octree problems\");\n            } else {\n               duplicateSet.add(sphere);\n            }\n         }\n      } else {\n         for (let i = 0; i < 8; ++i) {\n            const octreeNode = this.leaf[i];\n            if (octreeNode) {\n               octreeNode.check(duplicateSet);\n            }\n         }\n         for (let i = 8; i < this.leaf.length; ++i) {\n            const sphere = this.leaf[i];\n            if (duplicateSet.has(sphere)) {\n               console.log(\"octree problems\");\n            } else {\n               duplicateSet.add(sphere);\n            }\n         }\n      }\n   }\n\n   free() {\n      if (this.node) {\n         for (let sphere of this.node) {\n            sphere.octree = null;\n         }\n      } else {\n         for (let i = 0; i < 8; ++i) {\n            const octreeNode = this.leaf[i];\n            if (octreeNode) {\n               octreeNode.free();\n            }\n         }\n         for (let i = 8; i < this.leaf.length; ++i) {\n            const sphere = this.leaf[i];\n            sphere.octree = null;\n         }\n      }\n   }\n\n   // only expand when this.node.length > kTHRESHOLD. and this.leaf will double as this.node.\n   insert(sphere, bound) {\n      if (this.node) { // keep pushing.\n         this.node.push(sphere);\n         sphere.octree = this;\n         if (this.node.length >= LooseOctree.kTHRESHOLD) {  // now expand to children node if possible\n            this.leaf = [null, null, null, null, null, null, null, null];  // now setup leaf octant\n            let newBound = {center: vec3.create(), halfSize: vec3.create()};\n            let ret;\n            const node = this.node;\n            delete this.node;\n            for (let sphere of node) {  // redistribute to children or self.\n               vec3.copy(newBound.center, bound.center);\n               vec3.copy(newBound.halfSize, bound.halfSize);\n               ret = this.insert(sphere, newBound);\n            }\n            return ret;\n         }\n      } else {// not leaf node.\n         let index = LooseOctree.getOctant(sphere, bound);\n         if (index >= 0) {  // descent to children\n            let child = this.leaf[index];\n            if (child === null) {\n               child = new LooseOctree(this.bvh, bound, this.level+1);\n               this.leaf[index] = child;\n            }\n            return child.insert(sphere, bound);  \n         }\n         // larger than child size, so insert here.\n         this.leaf.push(sphere);\n         sphere.octree = this;\n      }\n      return this;\n   }\n\n   _move(sphere) {   // sphere size or center changed, check for moving to different node.\n      if (!this.isInside(sphere)) {\n         this._remove(sphere);\n         this.bvh.moveSphere(sphere);\n      }\n   }\n\n   _remove(sphere) {\n      if (sphere.octree === this) {\n         if (this.node) {\n            this.node.splice(this.node.indexOf(sphere), 1);\n         } else {\n            this.leaf.splice(this.leaf.indexOf(sphere), 1);\n         }\n         sphere.octree = null;\n      } else {\n         console.log(\"LooseOctree _remove error\");\n      }\n   }\n\n   isInside(sphere) {\n      for (let axis = 0; axis < 3; ++axis) {\n         let length = this.bound.halfSize[axis];\n         if ( (length < sphere.radius) || \n              (this.bound.center[axis]+length) < sphere.center[axis] ||\n              (this.bound.center[axis]-length) > sphere.center[axis]) {\n            return false;\n         }\n      }\n      return true;\n   }\n\n\n   * intersectExtent(shape) {   // act as generator\n      const extent = {min: vec3.create(), max: vec3.create()};\n      this.getLooseExtent(extent);\n      if (shape.intersectAAExtent(extent)) {\n         yield* this._extentIntersect(shape, extent);\n      }\n   }\n   //\n   // Revelles' algorithm, \"An efficient parametric algorithm for octree traversal\". <= todo\n   * _extentIntersect(shape, extent) {\n      if (this.node) {\n         for (let sphere of this.node) {\n            if (shape.intersectSphere(sphere)) {\n               yield sphere;\n            }\n         }\n      } else {\n         for (let i = 8; i < this.leaf.length; ++i) {\n            const sphere = this.leaf[i];\n            if (shape.intersectSphere(sphere)) {\n               yield sphere;\n            }\n         }\n         // check children, this is the hard part of Revelle's algorithm.\n         for (let i = 0; i < 8; ++i) {\n            const child = this.leaf[i];\n            if (child) {\n               child.getLooseExtent(extent);\n               if (shape.intersectAAExtent(extent)) {\n                  yield* child._extentIntersect(shape, extent);\n               }\n            }\n         }\n      }\n   }\n\n   // bound = {center, halfSize};\n   * intersectBound(shape) {\n      const bound = {center: vec3.create(), halfSize: vec3.create()};\n      this.getLooseBound(bound);\n      if (shape.intersectAABB(bound)) {\n         yield* this._boundIntersect(shape, bound);\n      }\n   }\n   * _boundIntersect(shape, bound) {\n      if (this.node) {\n         for (let sphere of this.node) {\n            if (shape.intersectSphere(sphere)) {\n               yield sphere;\n            }\n         }\n      } else {\n         for (let i = 8; i < this.leaf.length; ++i) {\n            const sphere = this.leaf[i];\n            if (shape.intersectSphere(sphere)) {\n               yield sphere;\n            }\n         }\n         // check children, this is the hard part of Revelle's algorithm.\n         for (let i = 0; i < 8; ++i) {\n            const child = this.leaf[i];\n            if (child) {\n               child.getLooseBound(bound);\n               if (shape.intersectAABB(bound)) {\n                  yield* child._boundIntersect(shape, bound);\n               }\n            }\n         }\n      }\n   }\n}\nLooseOctree.kTHRESHOLD = 88;    // read somewhere, 8-15 is a good number for octree node. expand to child only when node.length >= kTHRESHOLD\nLooseOctree.kLOOSENESS = 1.5;    // cannot change. because isInside depend on this property.\n\n\n\nclass Plane {\n   constructor(normal, pt) {\n      this.normal = vec3.clone(normal);\n      vec3.normalize(this.normal, this.normal);    // make sure.\n      this.pt = vec3.clone(pt);\n      this.distance = vec3.dot(this.normal, this.pt); // dot(n, pt) = k form.\n   }\n\n   closestPoint(out, point) { // projection to plane\n      _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"closestPointToPlane\"](out, point, this);\n   }\n\n   intersectAABB(box) {\n      return _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"intersectPlaneAABB\"](this, box);\n   }\n\n   intersectSphere(sphere) {\n      return _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"intersectPlaneSphere\"](this, sphere);\n   }\n}\n\n\nclass Ray {\n   constructor(origin, dir) {\n      this.origin = origin;\n      this.direction = dir;\n      this.invDir = vec3.fromValues(1/dir[0], 1/dir[1], 1/dir[2]);   //1/0 still work for our purpose.\n   }\n\n   intersectSphere(sphere) {\n      return _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"intersectRaySphere\"](this, sphere);\n   }\n\n   intersectAAExtent(extent) {\n      return _wings3d_util__WEBPACK_IMPORTED_MODULE_0__[\"intersectRayAAExtent\"](this, extent);\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_boundingvolume.js?");

/***/ }),

/***/ "./js/wings3d_camera.js":
/*!******************************!*\
  !*** ./js/wings3d_camera.js ***!
  \******************************/
/*! exports provided: pref, view, getMouseMoveHandler, aimZoom, rotate, wheelRotate, wheelZoom, zoomStepAlt, zoomStep, zoom, pan, keyPan, keyPanLeftArrow, keyPanRightArrow, keyPanUpArrow, keyPanDownArrow, wheelPan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pref\", function() { return pref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"view\", function() { return view; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMouseMoveHandler\", function() { return getMouseMoveHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"aimZoom\", function() { return aimZoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wheelRotate\", function() { return wheelRotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wheelZoom\", function() { return wheelZoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoomStepAlt\", function() { return zoomStepAlt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoomStep\", function() { return zoomStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoom\", function() { return zoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pan\", function() { return pan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyPan\", function() { return keyPan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyPanLeftArrow\", function() { return keyPanLeftArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyPanRightArrow\", function() { return keyPanRightArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyPanUpArrow\", function() { return keyPanUpArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyPanDownArrow\", function() { return keyPanDownArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wheelPan\", function() { return wheelPan; });\n/* harmony import */ var _wings3d_undo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_undo.js */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d.js */ \"./js/wings3d.js\");\n/*\n**\n**\n**     This module handles camera moves (rotation, zooming, and panning).\n**\n**  Original Erlang Version:  Bjorn Gustavsson\n*/\n\n\n\n\n\nclass CameraMouseMoveHandler extends _wings3d_undo_js__WEBPACK_IMPORTED_MODULE_0__[\"MouseMoveHandler\"] {\n   constructor() {\n      super();\n      this.saveView = { origin: [0, 0, 0], };\n      copyCam(this.saveView, view);\n   }\n\n   handleMouseMove(ev) {\n      // if middle button down, pan \n      if (ev.buttons == 4) {\n         pan(ev.movementX, 0);\n      } else {\n         // rotated\n         rotate(ev.movementX, ev.movementY);\n         //help(e.button + \",\" + e.buttons);\n      }\n   }\n\n   doIt() {\n      // no redo, undo for now\n      //debugLog(\"exitCameraMode\", {ok: this.camera});\n   }\n\n   undo() {\n      // restore camera's value.\n      copyCam(view, this.saveView);\n      //debugLog(\"exitCameraMode\", {cancel: this.camera});\n   }\n}\n\n// module variable.\n   let pref = {\n         cameraMode: \"WingsCam\",\n         numButtons: 3,\n         camRotationSpeed: 0.5,\n         panSpeed: 25,\n         panSpeedArrowKeys: 50,\n         wheelAdds: false,\n         whScrollInfo: true,\n         whPanSpeed: 50,\n         whRotationSpeed: 0.15,\n         highLightZoomAim: false,\n         // additional pref\n         wheelZoom: true,\n         wheelZoomFactorAlt: 0.0005,\n         wheelZoomFactor: 0.005\n      };\n   let view = (function(){\n         let camera = {\n            origin: [0.0, 0.0, 0.0],\n            azimuth: -45.0, elevation: 25.0,\n            distance: _wings3d_js__WEBPACK_IMPORTED_MODULE_1__[\"CAMERA_DIST\"],\n            panX: 0.0, panY: 0.0,\n            fov: 45.0,\n            zNear: 0.1, zFar: 1000.0\n         };\n         return {\n            alongAxis: false,\n            isModified: false,\n            inverseCameraVectors: function() {\n               var cam = mat4.create();\n               // fromTranslation, identity * vec3. modelView rest.\n               mat4.fromTranslation(cam, vec3.fromValues(-camera.panX, -camera.panY, camera.distance));\n               mat4.rotateX(cam, cam, -camera.elevation * Math.PI / 180);\n               mat4.rotateY(cam, cam, -camera.azimuth * Math.PI / 180);\n               mat4.translate(cam, cam, -camera.origin);\n               // x===right, y===up, z===forward.\n               var ret = {x: [cam[0], cam[1], cam[2]], \n                          y: [cam[4], cam[5], cam[6]], \n                          z: [cam[8], cam[9], cam[10]]\n                         };\n               vec3.normalize(ret.x, ret.x);\n               vec3.normalize(ret.y, ret.y);\n               vec3.normalize(ret.z, ret.z);\n               return ret;\n            }, \n            get origin() { return camera.origin; },\n            set origin(org) { \n               if ( camera.origin[0] != org[0] || camera.origin[1] != org[1] || camera.origin[2] != org[2]) {\n                  camera.origin[0] = org[0];\n                  camera.origin[1] = org[1];\n                  camera.origin[2] = org[2];\n                  this.isModified = true;\n               }\n            },\n            get azimuth() { return camera.azimuth; },\n            set azimuth(azi) {\n               if (azi != camera.azimuth) {\n                  camera.azimuth = azi;\n                  this.isModified = true;\n               }\n            },\n            get elevation() { return camera.elevation; },\n            set elevation(elv) {\n               if (camera.elevation != elv) {\n                  camera.elevation = elv;\n                  this.isModified = true;\n               }\n            },\n            get distance() { return camera.distance; },\n            set distance(dist) {\n               if (camera.distance != dist) {\n                  _wings3d_js__WEBPACK_IMPORTED_MODULE_1__[\"log\"](_wings3d_js__WEBPACK_IMPORTED_MODULE_1__[\"action\"].cameraZoom, dist - camera.distance);\n                  camera.distance = dist;\n                  this.isModified = true;\n               }\n            },\n            get panX() { return camera.panX; },\n            set panX(px) {\n               if (camera.panX != px) {\n                  camera.panX = px;\n                  this.isModified = true;\n               }\n            },\n            get panY() { return camera.panY; },\n            set panY(py) {\n               if (camera.panY != py) {\n                  camera.panY = py;\n                  this.isModified = true;\n               }\n            },\n            get fov() { return camera.fov; },\n            set fov(fv) {\n               if (camera.fov != fv) {\n                  camera.fov = fv;\n                  this.isModified = true;\n               }\n            },\n            get zNear() { return camera.zNear; },\n            set zNear(near) {\n               if (camera.zNear != near) {\n                  camear.zNear = near;\n                  this.isModified = true;\n               }\n            },\n            get zFar() { return camera.zFar; },\n            set zFar(far) {\n               if (camera.zFar != far) {\n                  camera.zFar = far;\n                  this.isModified = true;\n               }\n            },\n          };\n      }());\n\n// utility function\n   function copyCam(save, source) {\n      save.origin[0] = source.origin[0];\n      save.origin[1] = source.origin[1];\n      save.origin[2] = source.origin[2];\n      save.azimuth = source.azimuth;\n      save.elevation = source.elevation;\n      save.distance = source.distance;\n      save.panX = source.panX;\n      save.panY = source.panY;\n      save.fov = source.fov;\n      save.zNear = source.zNear;\n      save.zFar = source.zFar;\n   };\n\n   function init() {\n/*    case {wings_pref:get_value(num_buttons),wings_pref:get_value(camera_mode)} of\n\t   {3,_} -> ok\n\t   {_,nendo} -> ok;\n\t   {_,blender} -> ok;\n      {_,_} -> wings_pref:set_value(camera_mode, nendo) */\n   };\n\n   function getMouseMoveHandler() {\n      const ret = new CameraMouseMoveHandler();\n      return ret;\n   };\n\n/*\n%%%\n%%% Common utilities.\n%%%h\n\ngeneric_event(redraw, _Camera, #state{st=St, func=none}) ->\n    wings:redraw(St),\n    keep;\ngeneric_event(redraw, _Camera, #state{func=Redraw}) when is_function(Redraw) ->\n    Redraw(),\n    keep;\n\ngeneric_event(#mousebutton{button=4,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?SHIFT_BITS =/= 0 andalso Mod band ?ALT_BITS =/= 0 ->\n    whrotate(0.5,0.0);\ngeneric_event(#mousebutton{button=5,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?SHIFT_BITS =/= 0 andalso Mod band ?ALT_BITS =/= 0 ->\n    whrotate(-0.5,0.0);\ngeneric_event(#mousebutton{button=4,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?SHIFT_BITS =/= 0 ->\n    whrotate(0.0,0.5);\ngeneric_event(#mousebutton{button=5,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?SHIFT_BITS =/= 0 ->\n    whrotate(0.0,-0.5);\n\ngeneric_event(#mousebutton{button=4,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?CTRL_BITS =/= 0 andalso Mod band ?ALT_BITS =/= 0 ->\n    whpan(0.05,0.0);\ngeneric_event(#mousebutton{button=5,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?CTRL_BITS =/= 0 andalso Mod band ?ALT_BITS =/= 0 ->\n    whpan(-0.05,0.0);\ngeneric_event(#mousebutton{button=4,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?CTRL_BITS =/= 0 ->\n    whpan(0.0,0.05);\ngeneric_event(#mousebutton{button=5,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?CTRL_BITS =/= 0 ->\n    whpan(0.0,-0.05);\n\ngeneric_event(#mousebutton{button=4,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?ALT_BITS =/= 0 ->\n    zoom_step_alt(-1);\ngeneric_event(#mousebutton{button=4,state=?SDL_RELEASED}, #st{}=St, none) ->\n%% Matching 'none' stops zoom aim from being activated during a drag sequence.\n%% Zoom aim warps the mouse to the screen's centre, and this can cause a crash\n%% in since drag events also depend on cursor position.\n    aim_zoom(-1, St);\ngeneric_event(#mousebutton{button=4,state=?SDL_RELEASED}, _Camera, _Redraw) ->\n    zoom_step(-1);\ngeneric_event(#mousebutton{button=5,mod=Mod,state=?SDL_RELEASED}, _Camera, _Redraw)\n  when Mod band ?ALT_BITS =/= 0 ->\n    zoom_step_alt(1);\ngeneric_event(#mousebutton{button=5,state=?SDL_RELEASED}, _, none) ->\n%% Matching 'none' stops zoom aim from being activated during a drag sequence\n    zoom_step(1);\ngeneric_event(#mousebutton{button=5,state=?SDL_RELEASED}, _Camera, _Redraw) ->\n    zoom_step(1);\n\ngeneric_event(_, _, _) -> keep.\n\n*/\n   function aimZoom(dir, St0) {\n      /*\n        if (pref.highLightZoomAim) {\n        #view{origin=OriginB}=Before = wings_view:current(),\n        {{_,Cmd},_} = wings:highlight_aim_setup(St0),\n        wings_view:command(Cmd,St0),\n        #view{origin=OriginA} = wings_view:current(),\n        O = e3d_vec:zero(),\n        if OriginA =:= O, Cmd =:= aim ->\n              wings_view:set_current(Before),\n              zoom_step(Dir);\n            OriginA =:= OriginB ->\n              zoom_step(Dir);\n            true ->\n              Client = wings_wm:this(),\n              {X0,Y0} = wings_wm:win_size(Client),\n              {X,Y} = {X0 div 2, Y0 div 2},\n              wings_io:warp(X,Y),\n              zoom_step(Dir)\n      } else {\n         zoomStep(dir);\n      } */\n   };\n\n   function rotate(dx, dy) {\n      //if (allowRotation()) {\n\t      view.azimuth += dx * pref.camRotationSpeed;\n         view.elevation += dy * pref.camRotationSpeed;\n      //}\n   };\n\n   function wheelRotate(dx, dy) {\n      if (pref.wheelZoom && pref.wheelAdds) {\n         var s = 2 * pref.wheelRotationSpeed;\n         view.azimuth = view.azimuth + (dx * s);\n         view.elevation = view.elevation + (dy * s);\n         view.alongAxis = false;\n      }\n      // return keep;\n   };\n\n\n   function wheelZoom(factor, dir) {\n      var delta = Math.max(Math.abs(view.distance), 0.2) * (dir * factor);\n      view.distance += delta;\n      //return keep;\n   };\n\n   function zoomStepAlt(dir) {\n      if (pref.wheelZoom) {\n\t\t   wheelZoom(pref.wheelZoomFactorAlt, dir);\n      } \n      //return keep;\n   };\n\n\n   function zoomStep(dir) {\n      if (pref.wheelZoom) {\n         wheelZoom(pref.wheelZoomFactor, dir);\n      }\n      //return keep;\n   };\n\n   function zoom(delta) {\n      view.distance = view.distance + (Math.max(Math.abs(view.distance), 0.2) * delta / 80);\n   };\n\n   function pan(dx, dy) {\n      const s = view.distance * (1/20)/(101-pref.panSpeed);\n      view.panX += (dx*s);\n      view.panY += (dy*s);\n   };\n\n   function keyPan(dx, dy) {\n      const s = view.distance * (pref.panSpeedArrowKeys/100);\n      view.panX += (dx * s);\n      view.panY += (dy * s);\n   };\n   function keyPanLeftArrow() {\n      keyPan(0.05, 0.0);\n   };\n   function keyPanRightArrow() {\n      keyPan(-0.05, 0.0);\n   }\n   function keyPanUpArrow() {\n      keyPan(0, 0.05);\n   };\n   function keyPanDownArrow() {\n      keyPan(0, -0.05);\n   }\n\n   function wheelPan(dx0, dy0) {\n      if (pref.wheelZoom && pref.wheelAdds) {\n         const s = view.distance * (pref.wheelPanSpeed/100);\n         view.panX += (dx * s);\n         view.panY -= (dy * s);\n      }\n      // keep\n   };\n\n   // handle mouse and keyboard event.\n\n/*\nstop_camera(#camera{ox=Ox,oy=Oy}) ->\n    wings_wm:release_focus(),\n    case wings_io:ungrab(Ox, Oy) of\n\tstill_grabbed ->\n\t    wings_wm:later(view_changed);\n\tno_grab ->\n\t    wings_wm:dirty()\n    end,\n    update_sel(fun show_sel_fun/2),\n    pop.\n\ncamera_mouse_range(X1, Y1, #camera{x=OX,y=OY, xt=Xt0, yt=Yt0}=Camera) ->\n%%    io:format(\"Camera Mouse Range ~p ~p~n\", [{X0,Y0}, {OX,OY,Xt0,Yt0}]),\n    XD0 = (X1 - OX),\n    YD0 = (Y1 - OY),\n    {XD,YD} = wings_pref:lowpass(XD0 + Xt0, YD0 + Yt0),\n\n    if\n\tXD0 =:= 0, YD0 =:= 0 ->\n\t    {0.0,0.0,Camera#camera{xt=0,yt=0}};\n\ttrue ->\n\t    wings_io:warp(OX, OY),\n\t    {XD/?CAMDIV, YD/?CAMDIV, Camera#camera{xt=XD0, yt=YD0}}\n    end.\n\nview_hotkey(Ev, Camera, #state{st=St}) ->\n    case wings_hotkey:event(Ev,St) of\n\tnext -> keep;\n\t{view,smooth_proxy} -> keep;\n\t{view,quick_preview} -> keep;\n\t{view,Cmd} -> \n\t    wings_view:command(Cmd, St),\n\t    keep;\t\n\t_Other -> %% Hotkey pressed, Quit camera mode\n\t    wings_wm:later(Ev),\n\t    stop_camera(Camera)\n    end.\n\nmessage(Message) ->\n    wings_wm:message(Message),\n    wings_wm:message_right([]).\n    \ngrab() ->\n    wings_io:grab(),\n    wings_wm:grab_focus(),\n    update_sel(fun hide_sel_fun/2).\n\nhide_sel_fun(#dlo{sel=Sel}=D, _) ->\n    D#dlo{sel={call,none,Sel}}.\n\nshow_sel_fun(#dlo{sel={call,none,Sel}}=D, _) ->\n    D#dlo{sel=Sel};\nshow_sel_fun(D, _) -> D.\n\nallow_rotation() ->\n    wings_wm:get_prop(allow_rotation).\n\nupdate_sel(Fun) ->\n    case wings_pref:get_value(hide_sel_in_camera_moves) of\n\tfalse -> ok;\n\ttrue -> wings_dl:map(Fun, [])\n    end.\n\nformat([{Mod,But,Msg}|T]) ->\n    wings_msg:join(wings_msg:mod_format(Mod, But, Msg), format(T));\nformat([]) -> []. \n*/\n\n\n\n_wings3d_js__WEBPACK_IMPORTED_MODULE_1__[\"onReady\"](init);\n\n//# sourceURL=webpack:///./js/wings3d_camera.js?");

/***/ }),

/***/ "./js/wings3d_draftbench.js":
/*!**********************************!*\
  !*** ./js/wings3d_draftbench.js ***!
  \**********************************/
/*! exports provided: DraftBench, CheckPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DraftBench\", function() { return DraftBench; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CheckPoint\", function() { return CheckPoint; });\n/* harmony import */ var _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_gl */ \"./js/wings3d_gl.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/* harmony import */ var _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_boundingvolume */ \"./js/wings3d_boundingvolume.js\");\n/* harmony import */ var _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_wingededge */ \"./js/wings3d_wingededge.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n//\n// strategy:\n//    use GPU as much as possible. multiple passes for drawing. we have more than enough GPU power.\n//\n//    update as little as possible on cpu side. \n//\n// todo: done.\n//    first pass: draw line (select, unselected) first (using triangles). \n//\n//    second pass: draw polygon (selected, unseleced) using slightly optimized index.\n//\n//    third pass?: draw vertex.\n//\n//    last pass: draw hilite (line, polygon, or vertex).\n//\n\n\n\n\n\n\n\n\n\n/**\n * \n * @param {*} theme \n * @param {*} prop \n * @param {*} defaultSize\n * \n * internal data. isAltered (index rebuilt). isModified(reupload data to gpu) \n */\nconst DraftBench = function(theme, prop, defaultSize = 2048) {  // should only be created by View\n   _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_4__[\"MeshAllocator\"].call(this, defaultSize); // constructor.\n  \n   this.lastPreviewSize = { vertices: 0, edges: 0, faces: 0};\n   this.boundingSpheres = [];\n   this.hilite = {index: null, indexLength: 0, numberOfTriangles: 0};  // the hilite index triangle list.\n   this.numberOfTriangles = 0;\n\n   this.preview = {centroid: {}, isAltered: false};\n   this.preview.shaderData = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderData();\n   //this.preview.shaderData.setUniform4fv(\"faceColor\", [0.5, 0.5, 0.5, 1.0]);\n   //this.preview.shaderData.setUniform4fv(\"selectedColor\", [1.0, 0.0, 0.0, 1.0]);\n   var layoutVec = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"ShaderData\"].attribLayout();\n   var layoutFloat = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"ShaderData\"].attribLayout(1);\n   this.preview.shaderData.createAttribute('position', layoutVec, _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].STATIC_DRAW);\n   this.preview.shaderData.createAttribute('barycentric', layoutVec, _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].STATIC_DRAW);\n   this._resizeBoundingSphere(0);\n   this._resizePreview(0, 0);\n   this.setTheme(theme, prop);\n\n   // previewEdge\n   this.preview.edge = {};\n   this.preview.edge.isAltered = false;\n   this.preview.edge.indexCount = 0;\n   this.preview.edge.hilite = {indexCount: 0, wEdge: null};\n   this.preview.edge.hardness = {isAltered: false, indexCount: 0};\n   this.preview.edge.wireOnly = {isAltered: false, indexCount: 0};\n\n   // previewVertex\n   this.preview.vertex = {isModified: false, isAltered: false, min: Number.MAX_SAFE_INTEGER, max: Number.MIN_SAFE_INTEGER};\n   this.preview.shaderData.createAttribute('vertexState', layoutFloat, _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].DYNAMIC_DRAW);\n   this._resizePreviewVertex();\n   // body state.\n   this.previewBody = {hilite: false};\n   // shown plane normal\n   this.previewPlane = {};\n   this.previewPlane.shaderData = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderData();\n   this.previewPlane.shaderData.setUniform4fv(\"faceColor\", [1.0, 0.0, 0.0, 1.0]);\n   this.previewPlane.shaderData.createAttribute('position', layoutVec, _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].STATIC_DRAW);\n   this.previewPlane.rectangle = new Float32Array(3*4);  // \n   this.previewPlane.shaderData.resizeAttribute('position', Float32Array.BYTES_PER_ELEMENT*3*4);\n   this.previewPlane.pts = [];\n   for (let i = 0; i < 4; ++i) {\n      this.previewPlane.pts[i] = this.previewPlane.rectangle.subarray(i*3, (i+1)*3);\n   }\n};\n\n// temp structure\nDraftBench.theme = {edgeColor: [0.0, 0.0, 0.0, 1.0],\n                    hardEdgeColor: [1.0, 0.5, 0.0, 1.0],\n                    selectedColor: [0.65, 0.0, 0.0, 1.0],\n                    selectedHilite: [0.7, 0.7, 0.0, 1.0],\n                    unselectedHilite: [0.0, 0.65, 0.0, 1.0],\n                    vertexColor: [0.0, 0.0, 0.0, 1.0],\n                    maskedVertexColor: [0.5, 1.0, 0.0, 0.8],\n                    faceColor: [0.7898538076923077, 0.8133333333333334, 0.6940444444444445],\n                    sculptMagnetColor: [0.0, 0.0, 1.0, 0.1],\n                    tweakMagnetColor: [0.0, 0.0, 1.0, 0.06],\n                    tweakVectorColor: [1.0, 0.5, 0.0],\n                  };\nDraftBench.pref = {vertexSize: 4.0,\n                   selectedVertexSize: 5.0,\n                   maskedVertexSize: 8.0,\n                   edgeWidth: 2.0,\n                   selectedEdgeWidth: 2.0,\n                   hardEdgeWidth: 2.0,\n                  };\n// temp structure for \nDraftBench.CONST = (function() {\n   const constant = {};\n\n   constant.EDGEWIDTH = 1.1;\n   constant.BARYCENTRIC = new Float32Array(3);\n   constant.BARYCENTRIC[0] = 1.0;\n   constant.BARYCENTRIC[1] = 0.0;\n   constant.BARYCENTRIC[2] = 1.0;\n   return constant;\n}());\n\n\n// draftBench inherited from MeshAllocator, so we canintercept freeXXX and allocXXX call easier. It also makes logical sense.\nDraftBench.prototype = Object.create(_wings3d_wingededge__WEBPACK_IMPORTED_MODULE_4__[\"MeshAllocator\"].prototype);\n\n\n/**\n * \n */\nDraftBench.prototype.setTheme = function(theme, pref) {\n   Object.entries(theme).forEach(([key, value]) => {\n      // put the hext value to shader\n      this.preview.shaderData.setUniform4fv(key, _wings3d_util__WEBPACK_IMPORTED_MODULE_2__[\"hexToRGBA\"](value));\n      DraftBench.theme[key] = _wings3d_util__WEBPACK_IMPORTED_MODULE_2__[\"hexToRGBA\"](value);     // to be deleted\n    });\n   // set pref\n   Object.entries(pref).forEach(([key, value]) => {\n      DraftBench.pref[key] = value;\n    });\n   // manual update\n   const manualKeys = ['vertexSize', 'selectedVertexSize', 'maskedVertexSize'];\n   for (let key of manualKeys) {\n      this.preview.shaderData.setUniform1f(key, pref[key]);\n   }\n};\n\n// free webgl buffer.\nDraftBench.prototype.freeBuffer = function() {\n   this.preview.shaderData.freeAllAttributes();\n   this.preview.shaderData =  null;\n   this.previewEdge.shaderData.freeAllAttributes();\n   this.previewEdge.shaderData = null;\n};\n\n/**\n * vertex.isAltered = true; needs to recompute index.\n */\nDraftBench.prototype.alterVertex = function() {\n   this.preview.vertex.isAltered = true;\n}\n\n/** \n * visiblility change. update vertex/edge/polygon state.\n */\nDraftBench.prototype.alterPreview = function() {\n   this.preview.isAltered = true;\n   this.preview.edge.isAltered = true;\n   this.preview.edge.wireOnly.isAltered = true;\n   this.preview.vertex.isAltered = true;\n}\n\nDraftBench.prototype.updatePreview = function() {\n   this._resizeBoundingSphere();\n   this._resizePreview();\n   this._resizePreviewVertex();\n   this._updatePreviewSize();\n   this._updateAffected(this.affected);\n   // compute index\n   //this._computePreviewIndex();\n};\n\n\nDraftBench.prototype._resizeBoundingSphere = function() {\n   let oldSize = this.lastPreviewSize.faces\n   let size = this.faces.length - oldSize;\n   if (size > 0) {   // we only care about growth for now\n      if (oldSize > 0) {\n         if (this.preview.centroid.buf.data.length < (this.preview.centroid.buf.len+(size*3))) {\n            // needs to resize, and copy\n            const buf = new ArrayBuffer(this.faces.length * 3 * Float32Array.BYTES_PER_ELEMENT * 2);\n            const centroid = {buf: {buffer: buf, data: new Float32Array(buf), len: 0} };\n            // \n            centroid.buf.data.set(this.preview.centroid.buf.data);  // copy old data\n            for (let sphere of this.boundingSpheres) {\n               sphere.center = new Float32Array(centroid.buf.buffer, Float32Array.BYTES_PER_ELEMENT*centroid.buf.len, 3); \n               centroid.buf.len += 3;             \n            }\n            this.preview.centroid.buf = centroid.buf;\n         }\n      } else {\n         const buf = new ArrayBuffer(this.faces.length * 3 * Float32Array.BYTES_PER_ELEMENT * 2); // twice the current size\n         this.preview.centroid.buf = {buffer: buf, data: new Float32Array(buf), len: 0};\n         // assign a boundingsphere for each polygon.\n         //this.boundingSpheres = new Array(this.faces.length);\n         //this.boundingSpheres.length = 0;\n      }\n      // create New, should not have deleted sphere to mess up things\n      const centroid = this.preview.centroid;   // \n      for (let i = oldSize; i < this.faces.length; ++i) {\n         const polygon = this.faces[i];\n         const sphere = this.boundingSpheres[i];\n         let center = sphere.center;\n         if (!center) {\n            center = new Float32Array(centroid.buf.buffer, Float32Array.BYTES_PER_ELEMENT*centroid.buf.len, 3);\n            centroid.buf.len += 3;\n         }\n         //polygon.index = i; // recalibrate index for free.\n         //this.boundingSpheres.push( BoundingSphere.create(polygon, center) );\n         sphere.setSphere( _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_3__[\"BoundingSphere\"].computeSphere(polygon, center) );\n      }\n      // vertices is geometry data + centroid data.\n   }\n};\n\nDraftBench.prototype._resizePreview = function() {\n   let oldSize = this.lastPreviewSize.vertices;\n   let oldCentroidSize = this.lastPreviewSize.faces;\n\n   const size = this.vertices.length - oldSize;\n   const centroidSize = this.faces.length - oldCentroidSize;\n   if ((size > 0) || (centroidSize > 0)) {\n      const model = this;\n      let length = model.buf.data.length;\n      let centroidLength = model.preview.centroid.buf.data.length;\n      if (oldSize > 0) {\n         if (length > model.preview.barycentric.length) {\n            // create new length\n            model.preview.barycentric = new Float32Array(length);\n            let selected = new Uint8Array(length/3);\n            selected.set(model.preview.selected);\n            model.preview.selected = selected;\n         }\n         if (centroidLength > model.preview.centroid.barycentric.length) {\n            model.preview.centroid.barycentric = new Float32Array(centroidLength);\n         }\n      } else { // brand new\n         // created array\n         model.preview.barycentric = new Float32Array(length);\n         model.preview.selected = new Uint8Array(length/3);\n         model.preview.selectedCount = 0;\n         model.preview.realSelectedCount = 0;\n      \n         model.preview.centroid.barycentric = new Float32Array(centroidLength);\n      }\n      model.preview.barycentric.set(DraftBench.CONST.BARYCENTRIC);\n      model.preview.selected.fill(0, oldSize);\n      model.preview.centroid.barycentric.fill(1.0);\n      // upload the data to webgl\n      length = this.buf.len;\n      centroidLength = this.preview.centroid.buf.len;\n      model.preview.shaderData.resizeAttribute('position', (length+centroidLength)*4);\n      model.preview.shaderData.uploadAttribute('position', 0, this.buf.data.subarray(0, length));\n      model.preview.shaderData.uploadAttribute('position', length*4, this.preview.centroid.buf.data.subarray(0, centroidLength));\n      model.preview.shaderData.resizeAttribute('barycentric', (length+centroidLength)*4);\n      model.preview.shaderData.uploadAttribute('barycentric', 0, this.preview.barycentric.subarray(0, length));\n      model.preview.shaderData.uploadAttribute('barycentric', length*4, this.preview.centroid.barycentric.subarray(0, centroidLength));\n      // invalidate hilite\n      model.hilite.indexLength = 0;\n      this.preview.isAltered = true;\n   }\n      \n   // compute index\n   if (this.preview.isAltered) {\n      this._computePreviewIndex();\n   }\n};\n\nDraftBench.prototype._computePreviewIndex = function() {\n   this.numberOfTriangles = this.faces.reduce( function(acc, element) {\n      return acc + element.numberOfVertex; // -2; for half the vertex\n   }, 0);\n   this.preview.indexLength = this.numberOfTriangles * 3;\n   this.preview.realIndexLength = this.preview.indexLength;\n};\n\nDraftBench.prototype._computeFaceHiliteIndex = function(polygon, offset) {\n   if (this.hilite.numberOfTriangles < polygon.numberOfVertex) {\n      this.hilite.numberOfTriangles = polygon.numberOfVertex;\n      this.hilite.index = new Uint32Array(this.hilite.numberOfTriangles*3);\n   }\n   if (offset === undefined) {\n      offset = 0;\n   }\n   let index = polygon.index;\n   let indicesLength = 0;\n   let barycentric = this.vertices.length + polygon.index;\n   for (let hEdge of polygon.hEdges()) {\n      const vertex = hEdge.origin;\n      if (indicesLength > 0) {\n         this.hilite.index[offset+indicesLength++] = vertex.index;\n         this.hilite.index[offset+indicesLength++] = barycentric;\n      }\n      this.hilite.index[offset+indicesLength++] = vertex.index;\n   }\n   // last triangle using the first vertices\n   this.hilite.index[offset+indicesLength++] = this.hilite.index[offset];\n   this.hilite.index[offset+indicesLength++] = barycentric;\n\n   this.hilite.indexLength = offset+indicesLength;\n   // copy to gpu\n   this.preview.shaderData.setIndex('faceHilite', this.hilite.index);\n};\n\nDraftBench.prototype._computeGroupHiliteIndex = function(faceGroup) {\n   let numberOfTriangles = 0;\n   for (let polygon of faceGroup) {\n      numberOfTriangles += polygon.numberOfVertex;\n   }\n   if (this.hilite.numberOfTriangles < numberOfTriangles) {\n      this.hilite.numberOfTriangles = numberOfTriangles;\n      this.hilite.index = new Uint32Array(this.hilite.numberOfTriangles*3);\n   }\n   this.hilite.indexLength = 0;\n   for (let polygon of faceGroup) {\n      this._computeFaceHiliteIndex(polygon, this.hilite.indexLength);\n   }\n};\n\n\nDraftBench.prototype._resizePreviewVertex = function() {\n   const oldSize = this.lastPreviewSize.vertices;\n   const length = this.vertices.length;\n   const size = length - oldSize;\n   if (size > 0) {\n      const preview = this.preview.vertex;\n      const color = new Float32Array(length);\n      if (oldSize > 0) {\n         color.set(preview.color);\n      }\n      color.fill(0.0, oldSize);\n      preview.color = color;\n      //this.preview.vertex.isModified = true;\n      this.preview.vertex.isAltered = true;\n      // \n      this.preview.shaderData.resizeAttribute('vertexState', length*4);\n      this.preview.shaderData.uploadAttribute('vertexState', 0, preview.color);\n   }\n\n};\n\n\nDraftBench.prototype._updatePreviewSize = function() {\n   this.lastPreviewSize.vertices = this.vertices.length;\n   this.lastPreviewSize.edges = this.edges.length;\n   this.lastPreviewSize.faces = this.faces.length;\n};\n\n\nDraftBench.prototype._updateAffected = function(affected) {\n   if (affected.vertices.size > 0) {\n      for (let vertex of affected.vertices) {\n         this._updateVertex(vertex, affected);\n      }\n   }\n   if (affected.faces.size > 0) {\n      for (let face of affected.faces) {\n         this._updatePreviewFace(face);\n      }\n      // update index\n\n   }\n\n   this.clearAffected();\n};\n\nDraftBench.prototype._updateVertex = function(vertex, affected) {\n   if (vertex.isLive()) {\n      // first the simple case, update the vertexPreview,\n      this.preview.shaderData.uploadAttribute('position', vertex.vertex.byteOffset, vertex.vertex);\n   }\n};\n\nDraftBench.prototype._updatePreviewFace = function(polygon) {\n   // recompute boundingSphere centroid, and if numberOfVertex changed, needs to recompute index.\n   if ((polygon.index < this.boundingSpheres.length) && polygon.isLive()) { // will be get recompute on resize\n      polygon.update();\n      const sphere = this.boundingSpheres[ polygon.index ];\n      sphere.setSphere( _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_3__[\"BoundingSphere\"].computeSphere(sphere.polygon, sphere.center) ); \n      // update center\n      const index = this.vertices.length+polygon.index;\n      this.preview.shaderData.uploadAttribute('position', index*3*4, sphere.center);\n   }\n};\n\n\n\nDraftBench.prototype.hiliteFace = function(polygon, isHilite) {\n   if (isHilite) {   // show\n      this.hilite.color = DraftBench.theme.unselectedHilite;\n      if ((this.preview.selected[polygon.index] & 1) === 1) {\n         this.hilite.color = DraftBench.theme.selectedHilite;\n      }\n      this.preview.selected[polygon.index] |= 2;\n      this._computeFaceHiliteIndex(polygon);\n   } else { // hide\n      this.hilite.indexLength = 0;\n      this.preview.selected[polygon.index] &= ~2;\n   }\n};\n\nDraftBench.prototype.hiliteBody = function(faceGroup, isHilite) {\n   if (isHilite) { // show\n      let checkColor = true;\n      this.hilite.color = DraftBench.theme.unselectedHilite;\n      for (let polygon of faceGroup) {\n         if (checkColor && ((this.preview.selected[polygon.index] & 1) === 1)) {\n            this.hilite.color = DraftBench.theme.selectedHilite;  // unnecessary assignment\n            checkColor = false;\n         }\n         this.preview.selected[polygon.index] |= 2;\n      }\n      this._computeGroupHiliteIndex(faceGroup);\n   } else { // hide \n      this.hilite.indexLength = 0;\n      for (let polygon of faceGroup) { // clear flag\n         this.preview.selected[polygon.index] &= ~2;\n      }\n   }\n};\n\n\n/**\n * polygon drawing routines. draw selected polygon first then draw unselected one. \n * \n * @param {gl} - drawing context.\n */\nDraftBench.prototype.draw = function(gl, madsor) {\n   // draw selected polygon first if application\n   // first check index modification\n   if (this.preview.isAltered) {\n      const selection = new Uint32Array(this.preview.selectedCount);\n      let k = 0;\n      const index = new Uint32Array(this.preview.indexLength-this.preview.selectedCount);\n      let j = 0;\n      for (let cage of madsor.visibleWireCage(false)) {  // wire only cage was drawn before.\n         for (let polygon of cage.geometry.faces) {\n            if (polygon.isVisible()) {\n               const i = polygon.index;\n               const center = i + this.vertices.length;\n               if (this.preview.selected[i] & 1) {\n                  k = polygon.buildIndex(selection, k, center);\n               } else {\n                  j = polygon.buildIndex(index, j, center);\n               }\n            }\n         }\n      }\n      this.preview.realSelectedCount = k;\n      this.preview.realIndexLength = j+k;\n      this.preview.shaderData.setIndex('face', index);\n      this.preview.shaderData.setIndex('selectedFace', selection);\n      this.preview.isAltered = false;\n   }\n   \n   // draw faceSelected if not empty\n   let bindPosition = false;\n   if (this.preview.realSelectedCount > 0) {\n      gl.bindAttribute(this.preview.shaderData, ['position', 'barycentric']);\n      this.preview.shaderData.setUniform4fv('color', DraftBench.theme.edgeColor);\n      this.preview.shaderData.setUniform1f('lineWidth', DraftBench.pref.edgeWidth);\n      bindPosition = true;\n      this.preview.shaderData.setUniform4fv('faceColor', DraftBench.theme.selectedColor);\n      gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n      gl.bindIndex(this.preview.shaderData, 'selectedFace');\n      gl.drawElements(gl.TRIANGLES, this.preview.realSelectedCount, gl.UNSIGNED_INT, 0);\n   }\n   const indexLength = this.preview.realIndexLength - this.preview.realSelectedCount;\n   if (indexLength > 0) {  // draw normal polygon\n      if (!bindPosition) {\n         gl.bindAttribute(this.preview.shaderData, ['position', 'barycentric']);\n         this.preview.shaderData.setUniform4fv('color', DraftBench.theme.edgeColor);\n         this.preview.shaderData.setUniform1f('lineWidth', DraftBench.pref.edgeWidth);\n         bindPosition = true;\n      }\n      this.preview.shaderData.setUniform4fv('faceColor', DraftBench.theme.faceColor);\n      gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n      gl.bindIndex(this.preview.shaderData, 'face');\n      gl.drawElements(gl.TRIANGLES, indexLength, gl.UNSIGNED_INT, 0);\n   }\n};\n\n\n// draw hilite polygon. not offset\nDraftBench.prototype.drawHilite = function(gl) {\n   if (this.hilite.indexLength == 0) {\n      return;\n   }\n   try {\n      // set hilite color and hilite index\n      this.preview.shaderData.setUniform4fv(\"faceColor\", this.hilite.color);\n      gl.bindAttribute(this.preview.shaderData, ['position']);\n      gl.bindUniform(this.preview.shaderData, ['faceColor']);\n      gl.bindIndex(this.preview.shaderData, 'faceHilite');\n      gl.drawElements(gl.TRIANGLES, this.hilite.indexLength, gl.UNSIGNED_INT, 0);\n      // restore color\n      this.preview.shaderData.setUniform4fv(\"faceColor\", DraftBench.theme.faceColor);\n   } catch (e) {\n      console.log(e);\n   }\n};\n\n// draw vertex, select color, \nDraftBench.prototype.drawVertex = function(gl, madsor) {\n   // drawing using vertex array\n   try {\n      if (this.preview.vertex.isModified) {  // upload min  - max\n         this.preview.vertex.isModified = false;\n         if (this.preview.vertex.min <= this.preview.vertex.max) {\n            const i = this.preview.vertex.min;\n            const j = this.preview.vertex.max;\n            const points = this.preview.vertex.color.subarray(i, j+1);\n            this.preview.shaderData.uploadAttribute('vertexState', i*Float32Array.BYTES_PER_ELEMENT, points);\n            this.preview.vertex.max = -1;\n            this.preview.vertex.min = Number.MAX_SAFE_INTEGER;\n         }\n      }\n      // rebuild index.\n      if (this.preview.vertex.isAltered) {\n         const length = this.vertices.length;\n         const index = new Uint32Array(length);\n         let j = 0;\n         for (let cage of madsor.visibleCage()) {\n            for (let vertex of cage.geometry.vertices) {\n               index[j++] = vertex.index;\n            }\n         }\n         this.preview.shaderData.setIndex('vertex', index);\n         this.preview.vertex.indexLength = j;\n      }\n      // \n      gl.bindAttribute(this.preview.shaderData, ['position', 'vertexState']);\n      gl.bindUniform(this.preview.shaderData, ['vertexSize', 'selectedVertexSize', 'maskedVertexSize',\n                                               'vertexColor', 'selectedColor', 'unselectedHilite', 'selectedHilite', 'maskedVertexColor']);\n      gl.bindIndex(this.preview.shaderData, 'vertex');\n      gl.drawElements(gl.POINTS, this.preview.vertex.indexLength, gl.UNSIGNED_INT, 0);\n   } catch (e) {\n      console.log(e);\n   }\n};\n\n/**\n * \n */\nDraftBench.prototype.drawHardEdgeEtc = function(gl, isEdgeMode, madsor) {\n   let isBinded = false;\n   // draw hard edge if applicable.\n   if (this.preview.edge.hardness.indexCount > 0) {\n      if (this.preview.edge.hardness.isAltered) {\n         const index = new Uint32Array(this.preview.edge.hardness.indexCount);\n         let j = 0;\n         for (let cage of madsor.visibleCage()) {\n            for (let wEdge of cage.geometry.edges) {\n               if (wEdge.state & 4) {  // yes, hardEdge\n                  j = wEdge.buildIndex(index, j, this.vertices.length);\n               }\n            }\n         }\n         this.preview.shaderData.setIndex('hardEdge', index);\n         this.preview.edge.hardness.realIndexCount = j;\n         this.preview.edge.hardness.isAltered = false;\n      }\n      if (this.preview.edge.hardness.realIndexCount > 0) {\n      isBinded = true;\n      // draw HardEdge\n      gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_1__[\"selectedColorLine\"]);\n      gl.bindTransform();\n      gl.bindAttribute(this.preview.shaderData, ['position', 'barycentric']);\n      let lineWidth = DraftBench.CONST.EDGEWIDTH;\n      if (isEdgeMode) {\n         lineWidth = DraftBench.pref.hardEdgeWidth;\n      }\n      this.preview.shaderData.setUniform1f(\"lineWidth\", lineWidth);\n      this.preview.shaderData.setUniform4fv(\"color\", DraftBench.theme.hardEdgeColor);\n      this.preview.shaderData.setUniform4fv('faceColor', DraftBench.theme.faceColor);\n      gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n      gl.bindIndex(this.preview.shaderData, 'hardEdge');\n      gl.drawElements(gl.TRIANGLES, this.preview.edge.hardness.realIndexCount, gl.UNSIGNED_INT, 0);  // draw 1 line.\n      }\n   }\n   // recompute wireMode edge index if applicable\n   if (this.preview.edge.wireOnly.isAltered) {\n      let indexCount = 0 ;\n      for (let cage of madsor.visibleWireCage(true)) { // looking for wireMode cage only\n         indexCount += cage.geometry.edges.size;\n      }\n      this.preview.edge.wireOnly.indexCount = indexCount * 6;  // draw 2 triangle for each edge.\n      if (indexCount > 0) {\n         // now compute the wireOnly polygon\n         const index = new Uint32Array(this.preview.edge.wireOnly.indexCount);\n         let j = 0;\n         for (let cage of madsor.visibleWireCage(true)) {\n            for (let wEdge of cage.geometry.edges) {\n               if (wEdge.state === 0) {  // we only draw normal edge\n                  j = wEdge.buildIndex(index, j, this.vertices.length);\n               }\n            }\n         }\n         // wireOnly Edge\n         this.preview.shaderData.setIndex('wireEdge', index);\n         this.preview.edge.wireOnly.indexCount = j;\n      }\n      this.preview.edge.wireOnly.isAltered = false;\n   }\n   // draw wireMode edge if applicable\n   if (this.preview.edge.wireOnly.indexCount > 0) {\n      if (!isBinded) {  // bind program and data\n         gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_1__[\"selectedColorLine\"]);\n         gl.bindTransform();\n         gl.bindAttribute(this.preview.shaderData, ['position', 'barycentric']);\n         this.preview.shaderData.setUniform4fv('faceColor', DraftBench.theme.faceColor);\n      }\n      this.preview.shaderData.setUniform4fv(\"color\", DraftBench.theme.edgeColor);\n      this.preview.shaderData.setUniform1f(\"lineWidth\", DraftBench.CONST.EDGEWIDTH);\n      gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n      gl.bindIndex(this.preview.shaderData, 'wireEdge');\n      gl.drawElements(gl.TRIANGLES, this.preview.edge.wireOnly.indexCount, gl.UNSIGNED_INT, 0);  // draw 1 line.\n   }\n}\n\n/** \n * draw select, hilite, and (normal) edge\n * @param {gl} - drawing context\n */\nDraftBench.prototype.drawEdge = function(gl, madsor) {\n   gl.bindAttribute(this.preview.shaderData, ['position', 'barycentric']);\n   this.preview.shaderData.setUniform1f(\"lineWidth\", DraftBench.pref.selectedEdgeWidth);\n\n   // draw hilite first\n   if (this.preview.edge.hilite.wEdge) {\n      let hiliteColor = DraftBench.theme.unselectedHilite;\n      const wEdge = this.preview.edge.hilite.wEdge;\n      if (wEdge.state & 1) { // selected?\n         hiliteColor = DraftBench.theme.selectedHilite;\n      }\n      this.preview.shaderData.setUniform4fv(\"color\", hiliteColor);\n      gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n      gl.bindIndex(this.preview.shaderData, 'edgeHilite');\n      gl.drawElements(gl.TRIANGLES, this.preview.edge.hilite.indexCount, gl.UNSIGNED_INT, 0);  // draw 1 line.\n   }\n\n   // 2nd) draw selected\n   if (this.preview.edge.indexCount > 0) { // draw selected edge\n      if (this.preview.edge.isAltered) {  // rebuild selected index, might as well rebuilt hardEdge.\n         const selected = new Uint32Array( this.preview.edge.indexCount );\n         const hard = new Uint32Array( this.preview.edge.hardness.indexCount );\n         let j = 0;\n         let k = 0;\n         for (let cage of madsor.visibleCage()) {\n            for (let wEdge of cage.geometry.edges) {\n               if (wEdge.state & 1) {   // selected, draw both side\n                  j = wEdge.buildIndex(selected, j, this.vertices.length);\n               } else if (wEdge.state & 4) { // might as well check for hardEdge simultaneously\n                  k = wEdge.buildIndex(hard, k, this.vertices.length);\n               }\n            }\n         }\n         // set the new selected.\n         this.preview.shaderData.setIndex('edgeSelected', selected);\n         this.preview.edge.realIndexCount = j;\n         this.preview.edge.isAltered = false;\n         if (this.preview.edge.hardness.isAltered) {\n            this.preview.shaderData.setIndex('hardEdge', hard);\n            this.preview.edge.hardness.realIndexCount = k;\n            this.preview.edge.hardness.isAltered = false;\n         }\n      }\n      // now draw\n      if (this.preview.edge.realIndexCount > 0) {\n         this.preview.shaderData.setUniform4fv('color', DraftBench.theme.selectedColor);\n         gl.bindUniform(this.preview.shaderData, ['color', 'faceColor', 'lineWidth']);\n         gl.bindIndex(this.preview.shaderData, 'edgeSelected');\n         gl.drawElements(gl.TRIANGLES, this.preview.edge.realIndexCount, gl.UNSIGNED_INT, 0);  // draw selected lines\n      }\n   }\n};\n\nDraftBench.prototype.drawPlane = (function() {\n   const diagonal = vec3.create();   // a diagonal [1,0,1] normalize vector\n   const up = vec3.fromValues(0, 1, 0);\n   const rotate = quat.create();\n   const transform = mat4.create();\n   const halfSize = vec3.create();\n   \n   return function(gl, plane) {   // the real function\n      vec3.copy(halfSize, plane.halfSize);\n      vec3.normalize(halfSize, halfSize);\n      vec3.cross(diagonal, halfSize, up);\n      vec3.normalize(diagonal, diagonal);\n      // find rotation between planeNormal and Axis alignment\n      quat.rotationTo(rotate, diagonal, plane.normal);//, diagonal);\n      mat4.fromQuat(transform, rotate);\n      //vec3.transformMat4(halfSize, plane.halfSize, transform);\n      vec3.copy(halfSize, plane.halfSize);\n      // setup halfSize, \n      vec3.negate(this.previewPlane.pts[0], halfSize);\n      let pt = this.previewPlane.pts[1];\n      pt[0] = halfSize[0];\n      pt[1] = -halfSize[1];\n      pt[2] = halfSize[2];\n      vec3.copy(this.previewPlane.pts[2], halfSize);\n      vec3.negate(this.previewPlane.pts[3], pt);\n      // update position.\n      for (let i = 0; i < 4; ++i) {\n         const pt = this.previewPlane.pts[i];\n         vec3.transformMat4(pt, pt, transform);\n         vec3.add(pt, plane.center, pt);\n      }\n      // upload result\n      this.previewPlane.shaderData.uploadAttribute('position', 0, this.previewPlane.rectangle);\n      if (plane.hilite) {  // set color\n         this.previewPlane.shaderData.setUniform4fv(\"faceColor\", [0.0, 1.0, 0.0, 1.0]);\n      } else {\n         this.previewPlane.shaderData.setUniform4fv(\"faceColor\", [0.1, 0.1, 0.1, 1.0]);\n      }\n      // draw the rectangle plane\n      gl.disable(gl.CULL_FACE);\n      gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_1__[\"solidColor\"]);\n      gl.bindTransform();\n      gl.bindAttribute(this.previewPlane.shaderData, ['position']);\n      gl.bindUniform(this.previewPlane.shaderData, ['faceColor']);\n      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n      gl.disableShader();\n      gl.enable(gl.CULL_FACE);\n   };\n})();\n\n\nDraftBench.prototype.selectGroup = function(selection, isOn) {\n   for (let polygon of selection) {\n      this.selectFace(polygon, isOn);\n   }\n};\n\n\nDraftBench.prototype.resetBody = function(bodyGroup) {\n   this.selectGroup(bodyGroup, false);    // turn group off.\n};\n\n\n\nDraftBench.prototype.hiliteVertex = function(vertex, show) {\n   // select polygon set color,\n   if (show) {\n      this.setVertexColor(vertex, 0.5);\n   } else {\n      this.setVertexColor(vertex, -0.5);\n   }\n};\n\nDraftBench.prototype.setVertexColor = function(vertex, color) {\n   // selected color\n   const j = vertex.index;  \n   this.preview.vertex.color[j] += color;\n      if (j < this.preview.vertex.min) {\n         this.preview.vertex.min = j;\n      }\n      if (j > this.preview.vertex.max) {\n         this.preview.vertex.max = j;\n      }\n      this.preview.vertex.isModified = true;\n      //this.preview.vertex.min = this.preview.vertex.max = j;\n};\n\nDraftBench.prototype.resetSelectVertex = function() {\n   // zeroout the edge seleciton.\n   this.preview.vertex.isModified = false;\n   this.preview.vertex.color.fill(0.0);\n   this.preview.shaderData.uploadAttribute('vertexState', 0, this.preview.vertex.color);\n};\n\nDraftBench.prototype.hiliteEdge = function(hEdge, onOff) {\n   // select polygon set color,\n   if (onOff) {\n      const wEdge = hEdge.wingedEdge;\n      this.preview.edge.hilite.wEdge = wEdge;\n      const index = new Uint32Array( 6 ); // both edge. max 2 triangle.\n      wEdge.buildIndex(index, 0, this.vertices.length);\n      this.preview.shaderData.setIndex('edgeHilite', index);   // update index.\n      this.preview.edge.hilite.indexCount = 6;\n   } else {\n      this.preview.edge.hilite.wEdge = null;\n      this.preview.edge.hilite.indexCount = 0;\n   }\n}\n\n/**\n * toggle selection of wEdge\n * @param {WingedEdge} wEdge - target wEdge\n * @param {boolean} onOff - on/off toggle.\n */\nDraftBench.prototype.selectEdge = function(wEdge, onOff) {\n   if (onOff) {\n      if ((wEdge.state & 1) === 0) {\n         wEdge.state |= 1;\n         this.preview.edge.indexCount += 6;\n      }\n   } else {\n      if ((wEdge.state & 1) === 1) {\n         wEdge.state &= ~1;\n         this.preview.edge.indexCount -= 6;\n      }\n   }\n   this.preview.edge.isAltered = true;\n};\n\n\nDraftBench.prototype.resetSelectEdge = function() {\n   // zeroout the edge seleciton.\n   for (let wEdge of this.edges) {\n      wEdge.state = 0;\n   }\n   this.preview.edge.isAltered = false;\n   this.preview.edge.indexCount = 0;\n};\n\n\nDraftBench.prototype.updateCentroid = function(snapshot) {\n   // done, update shader data, should we update each vertex individually?\n   const centroids = this.preview.centroid.buf.data.subarray(0, this.preview.centroid.buf.len)\n   this.preview.shaderData.uploadAttribute('position', this.buf.len*4, centroids);\n};\n\n\nDraftBench.prototype.updatePosition = function() {\n   // todo: we really should update as little as possible.\n   const vertices = this.buf.data.subarray(0, this.buf.len);\n   this.preview.shaderData.uploadAttribute('position', 0, vertices);\n};\n\n\nDraftBench.prototype.selectFace = function(polygon, toggleOn) {\n   if (toggleOn) {\n      if ((this.preview.selected[polygon.index] & 1) === 0) {\n         this.preview.selectedCount += polygon.numberOfVertex * 3;\n         this.preview.selected[polygon.index] |= 1;\n         this.preview.isAltered = true;\n         if (this.preview.selected[polygon.index] & 2) { // now we are both hilite and selected\n            this.hilite.color = DraftBench.theme.selectedHilite;\n         }\n      }\n   } else {\n      if ((this.preview.selected[polygon.index] & 1) === 1) {\n         this.preview.selectedCount -= polygon.numberOfVertex * 3;\n         this.preview.selected[polygon.index] &= ~1;\n         this.preview.isAltered = true;\n         if (this.preview.selected[polygon.index] & 2) { // now we are both hilite and unselected\n            this.hilite.color = DraftBench.theme.unselectedHilite;\n         }\n      }\n   }\n};\n\nDraftBench.prototype.resetSelectFace = function() {\n   this.preview.selected.fill(0);            // reset all polygon to non-selected \n   this.preview.selectedCount = 0;\n   this.preview.realSelectedCount = 0;\n   this.preview.isAltered = true;\n};\n\n\n/**\n * set bitmask on 3rd position. off meant soft, on meant hard\n * @param {WingedEdge} wEdge - target edge\n * @param {number} operand - 0=soft, 1=hard, 2=invert.\n */\nDraftBench.prototype.setHardness = function(wEdge, operand) {\n   if (operand === 0)  {   // set soft\n      if (wEdge.state & 4) { // make sure it hard\n         wEdge.state &= ~4;  // clear hardness bit\n         this.preview.edge.hardness.isAltered = true;\n         this.preview.edge.hardness.indexCount -= 6;\n         return true;\n      }\n   } else if (operand === 1) {   // set hard\n      if ((wEdge.state & 4) === 0) { // make sure it soft\n         wEdge.state |= 4;   // set hardness bit\n         this.preview.edge.hardness.isAltered = true;\n         this.preview.edge.hardness.indexCount += 6;\n         return true;\n      }\n   } else { // invert\n      if (wEdge.state & 4) { // it hard, turn to soft\n         return this.setHardness(wEdge, 0);\n      } else { // wEdge is soft turn to hard\n         return this.setHardness(wEdge, 1);\n      }\n   }\n   return false;\n};\n\n\nclass CheckPoint extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_5__[\"EditCommand\"] { // do we really needs to inherited form EditCommand?\n   CheckPoint(draftBench, editCommand) {\n      this.command = editCommand;\n      this.draftBench = draftBench;\n      // map the (vertices, edges, faces) value.\n      this.vertices = [];\n      for (let vertex of draftBench.vertices) {\n         // outEdge index, need real pt?\n         if (vertex.isLive()) {\n            this.vertices.push( vertex.outEdge.wingedEdge.index );\n         } else {\n            this.vertices.push( -1 );\n         }\n      }\n      this.edges = [];\n      for (let wEdge of draftBench.edges) {\n         // left->next index, right->next index, origin index, dest index.\n         if (wEdge.isLive()) {\n            this.edges.push( wEdge.left.next.index, wEdge.right.next.index, wEdge.left.origin.index, wEdge.right.origin.index);\n         } else {\n            this.edges.push( -1, -1, -1, -1 );\n         }\n      }\n      this.faces = [];\n      for (let polygon of draftBench.faces) {\n         // halfEdge index.\n         if (polygon.isLive()) {\n            this.faces.push( polygon.halfEdge.index );\n         } else {\n            this.faces.push( -1 );\n         }\n      }\n   }\n\n   doIt() {\n      return this.command.doIt();\n   }\n\n   undo() {\n      this.command.undo();\n      // now check draftBench and our saved value.\n      // use index because draftBench could have more faces(all dead) than our Saved one due to expansion.\n      for (let i = 0; i < this.faces.length; ++i) {   // check polygon first, most like to have problems\n         const polygon = this.draftBench.faces[i];\n         if (polygon.isLive()) {\n            if (polygon.halfEdge.index != this.faces[i]) {\n               geometryStatus(\"CheckPoint failed. non matching polygon halfEdge\");\n               return;\n            }\n         } else {\n            if (this.faces[i] != -1) {\n               geometryStatus(\"CheckPoint failed. extra face\");\n               return\n            }\n         }\n      }\n      for (let i = 0; i < this.vertices.lenth; ++i ) {   // check vertex next because of simplicity.\n         const vertex = this.draftBench.vertices[i];\n         if (vertex.isLive()) {\n            if (vertex.outEdge.wingedEdge.index != this.vertices[i]) {\n               geometryStatus(\"CheckPoint failed. non-matching vertex outEdge\");\n               return;\n            }\n         } else {\n            if (this.vertices[i] != -1) {\n               geometryStatus(\"CheckPoint failed. extra vertex\");\n               return;\n            }\n         }\n      }\n      // check edges\n      for (let i = 0; i < this.edges.length; i+=4) {\n         const wEdge = this.draftBench.edges[i];\n         if (wEdge.isAlive()) {\n            if (wEdge.left.next.index != this.edges[i] || wEdge.right.next.index != [i+1] ||\n                 wEdge.left.origin.index != this.edges[i+2] || wEdge.right.origin.index != this.edges[i+3]) {\n               geometryStatus(\"CheckPoint failed. non matching wEdge\");\n               return;\n            }\n         } else {\n            if (this.edges[i] != -1) {\n               geometryStatus(\"CheckPoint failed. extra wEdge\");\n               return;\n            }\n         }\n      }\n   }\n};\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_draftbench.js?");

/***/ }),

/***/ "./js/wings3d_edgemads.js":
/*!********************************!*\
  !*** ./js/wings3d_edgemads.js ***!
  \********************************/
/*! exports provided: EdgeMadsor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeMadsor\", function() { return EdgeMadsor; });\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/* harmony import */ var _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_facemads */ \"./js/wings3d_facemads.js\");\n/* harmony import */ var _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_bodymads */ \"./js/wings3d_bodymads.js\");\n/* harmony import */ var _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_vertexmads */ \"./js/wings3d_vertexmads.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/**\n//    This module contains most edge command and edge utility functions.\n//\n//    \n**/\n\n   // for switching\n\n\n\n\n\n\n\n\n\n// \nclass EdgeMadsor extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"Madsor\"] {\n   constructor() {\n      super('Edge');\n      // cut commands\n      const self = this;\n      for (let numberOfSegments of [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutLine2, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutLine3, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutLine4, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutLine5, _wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutLine10]) {\n         const name = numberOfSegments.name;\n         const count = name.substring('cutLine'.length);\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](name, function(ev) {\n               self.cutEdge(count);\n            });\n      }\n      // cutEdge Dialog, show form when click\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutAsk.name, function(ev) {\n            // position then show form;\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"runDialog\"](\"#cutLineDialog\", ev, function(form) {\n               const data = form.querySelector('input[name=\"Segments\"');\n               if (data) {\n                  const number = parseInt(data.value, 10);\n                  if ((number != NaN) && (number > 0) && (number < 100)) { // sane input\n                     self.cutEdge(number);\n                  }\n               }\n            });\n        });\n      // cutAndConnect\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].cutAndConnect.name, function(ev) {\n            self.cutAndConnect();\n         });\n      // Dissolve\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItemMode\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeDissolve.name, function(ev) {\n            const dissolve = self.dissolve();\n            if (dissolve.length > 0) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](new DissolveEdgeCommand(self, dissolve));\n            } else {\n               // should not happened.\n            }\n         }, this, 'Backspace');\n      // Collapse\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeCollapse.name, function(ev) {\n            const command = new CollapseEdgeCommand(self);\n            if (command.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n            } else {\n               // should not happened.\n            }\n         });\n      // Crease\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeCrease.name, (ev) => {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"attachHandlerMouseMove\"](new CreaseEdgeHandler(this));\n      });\n\n      // EdgeLoop.\n      for (let [numberOfSegments, hotkey] of [[_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeLoop1,\"l\"], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeLoop2,undefined], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeLoop3,undefined]]) {\n         const name = numberOfSegments.name;\n         const count = name.substring('edgeLoop'.length);        \n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](name, function(ev) {\n            const command = new EdgeLoopCommand(self, count);\n            if (command.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n            } else { // should not happened, make some noise\n\n            }\n         }, hotkey);\n      }\n      // EdgeLoop Nth., show form when click\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeLoopN.name, function(ev) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"runDialog\"]('#cutLineDialog', ev, function(form) {\n            const data = form.querySelector('input=[name=\"Segments\"');\n            if (data) {\n               const number = parseInt(data.value, 10);\n               if ((number != NaN) && (number > 0) && (number < 100)) { // sane input\n                  const command = new EdgeLoopCommand(self, number);\n                  if (command.doIt()) {\n                     _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n                  } else { // should not happened, make some noise\n                  }\n               }\n            }\n          });\n       });\n      // EdgeRing\n      for (let [numberOfSegments, hotkey] of [[_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeRing1,\"g\"], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeRing2,undefined], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeRing3,undefined]]) {\n         const name = numberOfSegments.name;\n         const count = name.substring('edgeRing'.length);\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](name, function(ev) {\n            const command = new EdgeRingCommand(self, count);\n            if (command.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n            } else { // should not happened, make some noise\n      \n            }\n         }, hotkey);\n      }\n      // EdgeRing Nth\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeRingN.name, function(ev) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"runDialog\"]('#cutLineDialog', ev, function(form) {\n            const data = form.querySelector('input[name=\"Segments\"');\n            if (data) {\n               const number = parseInt(data.value, 10);\n               if ((number != NaN) && (number > 0) && (number < 100)) { // sane input\n                  const command = new EdgeRingCommand(self, number);\n                  if (command.doIt()) {\n                     _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n                  } else { // should not happened, make some noise\n                  }\n               }\n            }\n          });\n       });\n       // loopCut\n       _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeLoopCut.name, (ev) => {\n         const command = new LoopCutCommand(this);\n         if (command.doIt()) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](command);\n         } else { // geometry status. no LoopCut available.\n\n         }\n        });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeCorner.name, (ev) => {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"attachHandlerMouseMove\"](new EdgeCornerHandler(this));\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeSlide.name, (ev) => {\n         const handler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveBidirectionHandler\"](this, new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"GenericEditCommand\"](this, this.slide));\n         handler.doIt();\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"attachHandlerMouseMove\"](handler);\n        });\n      // Hardness\n      for (let [hardness, operand] of [[_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeSoft, 0], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeHard, 1], [_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].edgeInvert, 2]]) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_6__[\"bindMenuItem\"](hardness.name, (ev)=> {\n            const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"GenericEditCommand\"](this, this.hardness, [operand], this.undoHardness);\n            if (cmd.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](cmd);\n            } else { // geometry status. no hardEdge to turn to softEdge.\n\n            }\n          });\n      }\n   }\n\n   // get selected Edge's vertex snapshot. for doing, and redo queue. \n   snapshotPosition() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotEdgePosition);\n   }\n\n   snapshotPositionAndNormal() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotEdgePositionAndNormal);\n   }\n\n   snapshotTransformGroup() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotTransformEdgeGroup);\n   }\n\n   loopCut() {\n      const snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.loopCut);\n      for (let snapshot of snapshots) {\n         for (let preview of snapshot.snapshot.separateCages) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"addToWorld\"](preview);\n            preview.selectBody();\n         }\n      }\n      return snapshots;\n   }\n\n   undoLoopCut(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoLoopCut);\n      for (let snapshot of snapshots) {   // we have to remove later because of removeFromWorld will set invisible flag on polygon.\n         for (let preview of snapshot.snapshot.separateCages) {\n            //preview.selectBody();\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"removeFromWorld\"](preview);\n         }\n      }\n   }\n\n   bevel() {\n      const snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.bevelEdge);\n      // change to facemode.\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreFaceMode\"](snapshots);\n      return snapshots;\n   }\n\n   undoBevel(snapshots, selection) {\n      this.restoreSelectionPosition(snapshots);\n      this.collapseEdge(snapshots);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreEdgeMode\"](selection);\n   }\n\n   crease() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.creaseEdge);\n   }\n\n   extrude() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.extrudeEdge);\n   }\n\n   undoExtrude(contourEdges) {\n      this.doAll(contourEdges, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoExtrudeEdge);\n   }\n\n   cutEdge(numberOfSegments) {\n      const cutEdge = new CutEdgeCommand(this, numberOfSegments);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](cutEdge);\n      cutEdge.doIt();\n   }\n\n   cutAndConnect() {\n      const cutEdge = new CutEdgeCommand(this, 2);\n      cutEdge.doIt();\n      const vertexMadsor = _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"currentMode\"]();   // assurely it vertexMode\n      vertexMadsor.andConnectVertex(cutEdge);\n   }\n\n   cut(numberOfSegments) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.cutEdge, numberOfSegments);\n   }\n\n   edgeLoop(nth) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.edgeLoop, nth);\n   }\n\n   edgeRing(nth) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.edgeRing, nth);\n   }\n   collapseEdge(snapshots) {  // undo of splitEdge.\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSplitOrBevelEdge);\n   }\n\n   // dissolve edge\n   dissolve() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.dissolveSelectedEdge);\n   }\n   reinsertDissolve(dissolveEdgesArray) {\n      this.doAll(dissolveEdgesArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.reinsertDissolveEdge);\n   }\n\n   // collapse edge\n   collapse() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSelectedEdge);\n   }\n\n   restoreEdge(collapseEdgesArray) {\n      this.doAll(collapseEdgesArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreCollapseEdge);\n   }\n\n   corner() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.cornerEdge);\n   }\n\n   undoCorner(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoCornerEdge);\n   }\n\n   hardness(state) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.hardnessEdge, state);\n   }\n\n   undoHardness(snapshots, state) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoHardness, state);\n   }\n\n   slide() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.slideEdge);\n   }\n\n   flatten(axis) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.flattenEdge, axis);\n   }\n\n   dragSelect(cage, hilite, selectArray, onOff) {\n      if (hilite.edge !== null) {\n        if (cage.dragSelectEdge(hilite.edge, onOff)) {\n            selectArray.push(hilite.edge);\n        }\n      }\n   }\n\n   // select, hilite\n   selectStart(cage, hilite) {\n      if (hilite.edge !== null) {\n         var onOff = cage.selectEdge(hilite.edge);\n         return new DragEdgeSelect(this, cage, hilite.edge, onOff);\n      }\n      return null;\n   }\n\n   isEdgeSelectable() { return true; }\n\n   _resetSelection(cage) {\n      cage._resetSelectEdge();\n   }\n\n   _restoreSelection(cage, snapshot) {\n      cage.restoreEdgeSelection(snapshot);\n   }\n\n   toggleFunc(toMadsor) {\n      var redoFn;\n      var snapshots;\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreFaceMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromEdgeToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreVertexMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromEdgeToVertexSelect); \n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreBodyMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromEdgeToBodySelect);\n      } else {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreMultiMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromEdgeToMultiSelect);   \n      }\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"undoQueue\"](new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"ToggleModeCommand\"](redoFn, _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreEdgeMode\"], snapshots));\n   }\n\n   restoreMode(toMadsor, snapshots) {\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromEdgeToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromEdgeToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromEdgeToBodySelect);\n      } else {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromEdgeToMultiSelect);      \n      }\n   }\n\n   drawExtra(gl, draftBench) {\n      //if (this.currentEdge) {\n         //gl.useShader(ShaderProg.solidColor);\n         gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_8__[\"selectedColorLine\"]);\n         gl.bindTransform();\n         draftBench.drawEdge(gl, this);\n         gl.disableShader();\n      //}\n   }\n\n   previewShader(gl) {\n      gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_8__[\"edgeSolidWireframe\"]);\n   }\n}\n\nclass DragEdgeSelect extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"DragSelect\"] {\n   constructor(madsor, cage, halfEdge, onOff) {\n      super(madsor, cage, halfEdge, onOff);\n   }\n\n   finish() {\n      return new EdgeSelectCommand(this.select);\n   }\n}\n\n\nclass EdgeSelectCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(select) {\n      super();\n      this.select = select;\n   }\n\n   doIt() {\n      for (var [cage, halfEdges] of this.select) {\n         for (var i = 0; i < halfEdges.length; ++i) {\n            cage.selectEdge(halfEdges[i]);\n         }\n      }\n   }\n\n   undo() {\n      this.doIt();   // selectEdge, flip/flop, so\n   }\n}\n\n\n//class CutEdgeMoveCommand extends MouseMoveHandler {\n//}\n\n\nclass CutEdgeCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor, numberOfSegments) {\n      super();\n      this.madsor = madsor;\n      this.numberOfSegments = numberOfSegments;\n      this.selectedEdges = madsor.snapshotSelection();\n   }\n\n   doIt() {\n      const snapshots = this.madsor.cut(this.numberOfSegments);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreVertexMode\"](snapshots);    // abusing the api?\n      this.snapshots = snapshots;\n   }\n\n   undo() {\n      // restoreToEdgeMode\n      this.madsor.collapseEdge(this.snapshots);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreEdgeMode\"](this.selectedEdges);\n   }\n}\n\n\nclass DissolveEdgeCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor, dissolveEdges) {\n      super();\n      this.madsor = madsor;\n      this.dissolveEdges = dissolveEdges;\n   }\n\n   doIt() {\n      this.madsor.dissolve(); // return data should be the same as previous one\n   }\n\n   undo() {\n      this.madsor.reinsertDissolve(this.dissolveEdges);\n   }\n}\n\n\nclass CollapseEdgeCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      const collapse = this.madsor.collapse();\n      if (collapse.length > 0) {\n         this.collapse = collapse;\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreVertexMode\"](this.collapse);\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   undo() {\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"currentMode\"]().resetSelection();\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreEdgeMode\"]();\n      this.madsor.restoreEdge(this.collapse);\n   }\n}\n\n// Crease\nclass CreaseEdgeHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"MoveableCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n      this.contourEdges = madsor.crease();\n      this.moveHandler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveAlongNormal\"](madsor);\n   }\n\n   doIt() {\n      this.contourEdges = this.madsor.crease(this.contourEdges);\n      super.doIt();     // = this.madsor.moveSelection(this.movement, this.snapshots);\n   }\n\n   undo() {\n      super.undo(); //this.madsor.restoreSelectionPosition(this.snapshots);\n      this.madsor.undoExtrude(this.contourEdges);\n   }\n}\n// end of Crease\n\nclass EdgeLoopCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor, nth) {\n      super();\n      this.madsor = madsor;\n      this.nth = nth;\n      this.selectedEdges = madsor.snapshotSelection();\n   }\n\n   doIt() {\n      const loopSelection = this.madsor.edgeLoop(this.nth);\n      return (loopSelection.length > 0);\n   }\n\n   undo() {\n      this.madsor.resetSelection();\n      this.madsor.restoreSelection(this.selectedEdges);\n   }\n}\n\nclass EdgeRingCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor, nth) {\n      super();\n      this.madsor = madsor;\n      this.nth = nth;\n      this.selectedEdges = madsor.snapshotSelection();\n   }\n\n   doIt() {\n      const loopSelection = this.madsor.edgeRing(this.nth);\n      return (loopSelection.length > 0);\n   }\n\n   undo() {\n      this.madsor.resetSelection();\n      this.madsor.restoreSelection(this.selectedEdges);\n   } \n}\n\nclass LoopCutCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      this.loopCut = this.madsor.loopCut();\n      if (this.loopCut.length > 0) {   // change to body Mode.\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreBodyMode\"]();\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   undo() {\n      if (this.loopCut.length > 0) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_7__[\"restoreEdgeMode\"]();\n         this.madsor.undoLoopCut(this.loopCut);\n      }\n   }\n}\n\nclass EdgeCornerHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"MoveableCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n      this.cornerEdges = madsor.corner();\n      this.moveHandler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveAlongNormal\"](madsor, false, this.cornerEdges);\n   }\n\n   doIt() {\n      this.cornerEdges = this.madsor.corner();\n      super.doIt();\n   }\n\n   undo() {\n      // super.undo();  // not need, because movement was deleted\n      this.madsor.undoCorner(this.cornerEdges);\n   }\n\n}\n\n\n\n//# sourceURL=webpack:///./js/wings3d_edgemads.js?");

/***/ }),

/***/ "./js/wings3d_facemads.js":
/*!********************************!*\
  !*** ./js/wings3d_facemads.js ***!
  \********************************/
/*! exports provided: FaceMadsor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceMadsor\", function() { return FaceMadsor; });\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/* harmony import */ var _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_edgemads */ \"./js/wings3d_edgemads.js\");\n/* harmony import */ var _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_bodymads */ \"./js/wings3d_bodymads.js\");\n/* harmony import */ var _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_vertexmads */ \"./js/wings3d_vertexmads.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/**\n//    This module contains most face command and face utility functions.\n//\n//    \n**/\n\n   // for switching\n\n\n\n\n\n\n\n\n\nclass FaceMadsor extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"Madsor\"] {\n   constructor() {\n      super('Face');\n      var self = this;\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItemMode\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceDissolve.name, function(ev) {\n            const command = new DissolveFaceCommand(self);\n            if (command.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n            } else {\n               geometryStatus('Selected Face not dissolveable');\n            }\n         }, this, 'Backspace');\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceCollapse.name, function(ev) {\n            const command = new CollapseFaceCommand(self);\n            command.doIt();\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n         });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceBridge.name, (ev) => {\n         let bridgeFaces = this.getBridgeFaces();\n         if (bridgeFaces.length === 2) {\n            const dest = bridgeFaces[0];\n            const origin = bridgeFaces[1];\n            if (dest.face.numberOfVertex == origin.face.numberOfVertex) {\n               let merge;\n               let bridge;\n               if (dest.preview !== origin.preview) {\n                  // merge dest and origin.\n                  merge = new MergePreviewCommand(dest.preview, origin.preview);\n                  merge.doIt();\n                  bridge = new BridgeFaceCommand(merge.getCombine(), dest.face, origin.face);\n               } else {\n                  bridge = new BridgeFaceCommand(dest.preview, dest.face, origin.face);\n               }\n               bridge.doIt();\n               if (merge) {\n                  _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueueCombo\"]([merge, bridge]);\n               } else {\n                  _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](bridge);\n               }\n            }\n         }\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceInset.name, (ev) => {\n         if (this.hasSelection()) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseMove\"](new InsetFaceHandler(this));\n         } else {\n            geometryStatus('No selected face');\n         }\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceBump.name, (ev) => {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseMove\"](new BumpFaceHandler(this));\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceIntrude.name, (ev) => {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseMove\"](new IntrudeFaceHandler(this));\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceLift.name, (ev) => {\n         const snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotTransformFaceGroup);\n         if (snapshots.length === 1) {\n            const snapshot = snapshots[0];\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseSelect\"](new LiftFaceHandler(this, snapshot.preview));\n         } else {\n            // helpBar(\"Lift works only in one Cage\");\n         }\n        });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].facePutOn.name, (ev)=> {\n         let snapshot = [];\n         for (let preview of this.selectedCage()) {\n            if (preview.selectionSize() == 1) {\n               snapshot.push( preview );\n            }\n          }\n         if (snapshot.length == 1) {\n            const putOn = new PutOnCommand(this, snapshot[0]);\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseSelect\"](putOn);\n         } else {\n            geometryStatus(\"You can only PutOn one face\");\n         }\n        });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceMirror.name, (ev) => {\n         const command = new MirrorFaceCommand(this);\n         command.doIt();\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](command);\n       });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_7__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_8__[\"action\"].faceFlattenNormal.name, (_ev) => {\n         const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"GenericEditCommand\"](this, this.flatten);\n         if (cmd.doIt()) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](cmd);\n         }\n       });\n   }\n\n   // get selected Face's vertex snapshot. for doing, and redo queue. \n   snapshotPosition() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotFacePosition);\n   }\n\n   snapshotPositionAndNormal() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotFacePositionAndNormal);\n   }\n\n   snapshotTransformGroup() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotTransformFaceGroup);\n   }\n\n   bevel() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.bevelFace);\n   }\n\n   undoBevel(snapshots, selection) {\n      this.restoreSelectionPosition(snapshots);\n      // collapse extrudeEdge\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSplitOrBevelEdge);\n      // rehilite selectedFace\n      this.resetSelection();\n      this.restoreSelection(selection);\n   }\n\n   bump() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.bumpFace);\n   }\n\n   undoBump(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoExtrudeEdge);\n   }\n\n   // extrude Face\n   extrude() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.extrudeFace);\n   }\n\n   undoExtrude(extrudeEdgesContoursArray) {\n      this.doAll(extrudeEdgesContoursArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseExtrudeEdge);\n   }\n\n   collapseEdgeNew(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseExtrudeEdge);\n   }\n\n   // face dissolve mode\n   dissolve() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.dissolveSelectedFace);\n   }\n   undoDissolve(dissolveArray) {\n      this.doAll(dissolveArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoDissolveFace);\n   }\n\n   // face collapse \n   collapse() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSelectedFace);\n   }\n   undoCollapse(collapseArray) {\n      this.doAll(collapseArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoCollapseFace);\n   }\n\n   // intrude, \n   intrude() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.intrudeFace);\n   }\n   undoIntrude(snapshots) {\n      return this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoIntrudeFace);\n   }\n\n   // bridge\n   getBridgeFaces() {\n      const snapshot = [];\n      for (let cage of this.selectedCage()) {\n         const selection = cage.snapshotSelection();\n         for (let selected of selection) {\n            snapshot.push( {preview: cage, face: selected} );\n         }\n      }\n      return snapshot;\n   }\n\n   // Inset\n   inset() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.insetFace);\n   }\n\n   mirror() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.mirrorFace);\n   }\n\n   undoMirror(snapshots) {\n      return this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoMirrorFace);\n   }\n\n   flatten(axis) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.flattenFace, axis);\n   }\n\n   planeCuttable(plane) {\n      return this.resultAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.planeCuttableFace, plane);\n   }\n   planeCut(plane) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.planeCutFace, plane);\n   }\n   undoPlaneCut(snapshots) { // undo of splitEdge.\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSplitOrBevelEdge);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"](snapshots);\n   }\n\n   dragSelect(cage, hilite, selectArray, onOff) {\n      if (hilite.face !== null) {\n        if (cage.dragSelectFace(hilite.face, onOff)) {\n            selectArray.push(hilite.face);\n        }\n      }\n   }\n\n   // select, hilite\n   selectStart(preview, hilite) {\n      // check not null, shouldn't happened\n      if (hilite.face !== null) {\n         var onOff = preview.selectFace(hilite.face);\n         return new DragFaceSelect(this, preview, hilite.face, onOff);\n      }    \n   }\n\n   isFaceSelectable() { return true; }\n\n   _resetSelection(cage) {\n      cage._resetSelectFace();\n   }\n\n   _restoreSelection(cage, snapshot) {\n      cage.restoreFaceSelection(snapshot);\n   }\n   \n   toggleFunc(toMadsor) {\n      var redoFn;\n      var snapshots;\n      if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_1__[\"EdgeMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromFaceToEdgeSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromFaceToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreBodyMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromFaceToBodySelect);\n      } else {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreMultiMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromFaceToMultiSelect);\n      }\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"ToggleModeCommand\"](redoFn, _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"], snapshots));\n   }\n\n   restoreMode(toMadsor, snapshots) {\n      if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_1__[\"EdgeMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromFaceToEdgeSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromFaceToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         this.doaAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromFaceToBodySelect);\n      } else {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromFaceToMultiSelect);\n      }\n   }\n}\n\n\nclass DragFaceSelect extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"DragSelect\"] {\n   constructor(madsor, cage, halfEdge, onOff) {\n      super(madsor, cage, halfEdge, onOff);\n   }\n\n   finish() {\n      return new FaceSelectCommand(this.select);\n   }\n}\n\n\nclass FaceSelectCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(select) {\n      super();\n      this.select = select;\n   }\n\n   doIt() {\n      for (var [cage, halfEdges] of this.select) {\n         for (var i = 0; i < halfEdges.length; ++i) {\n            cage.selectFace(halfEdges[i]);\n         }\n      }\n   }\n\n   undo() {\n      this.doIt();   // selectEdge, flip/flop, so\n   }\n}\n\n\nclass DissolveFaceCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      const dissolve = this.madsor.dissolve();\n      if (dissolve.length > 0) {\n         this.dissolve = dissolve;\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   undo() {\n      this.madsor.undoDissolve(this.dissolve);\n   }\n}\n\nclass CollapseFaceCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      const collapse = this.madsor.collapse();\n      if (collapse.length > 0) {\n         this.collapse = collapse;\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"](this.collapse);\n         return true;\n      } else {\n         return false;\n      }\n   }\n\n   undo() {\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"currentMode\"]().resetSelection();\n      this.madsor.undoCollapse(this.collapse);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"](this.collapse);\n   }   \n}\n\n\n//\n// current limitation, no interobject bridge yet.\n//\nclass BridgeFaceCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(cage, target, source) {\n      super();\n      this.cage = cage;\n      this.target = target;\n      this.source = source;\n   }\n\n   doIt() {\n      // should be ready for bridging. \n      this.bridge = this.cage.bridge(this.target, this.source);\n   }\n\n   undo() {\n      this.cage.undoBridge(this.bridge);\n      this.cage.restoreFaceSelection(this.bridge);\n   }\n}\n\nclass MergePreviewCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(targetCage, sourceCage) {\n      super();\n      this.targetCage = targetCage;\n      this.sourceCage = sourceCage;\n   }\n\n   getCombine() {\n      return this.combine;\n   }\n\n   doIt() {\n      this.combine = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"makeCombineIntoWorld\"]([this.targetCage, this.sourceCage]);\n      this.combine.name = this.targetCage.name;\n      return true;\n   }\n\n   undo() {\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"removeFromWorld\"](this.combine);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](this.targetCage);\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"addToWorld\"](this.sourceCage);\n   }\n}\n\n\nclass InsetFaceHandler extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MovePositionHandler\"] {\n   constructor(madsor) {\n      super(madsor);\n      //this.selectedFaces = madsor.snapshotSelection();\n      this.movement = 0;\n      this.doIt();   // init.\n   }\n\n   doIt() {\n      this.snapshots = this.madsor.inset();   // should we test for current snapshots and prev snapshots?\n      this.madsor.moveSelection(this.snapshots, this.movement);\n      // get limit\n      this.vertexLimit = Number.MAX_SAFE_INTEGER;\n      for (let obj of this.snapshots) {\n         this.vertexLimit = Math.min(this.vertexLimit, obj.snapshot.vertexLimit);\n      } \n   }\n\n   //_updateMovement(ev) {  // change back when we all move to moveSelection\n   handleMouseMove(ev) {\n      let move = this._calibrateMovement(ev.movementX);\n      if ((this.movement+move) > this.vertexLimit) {\n         move = this.vertexLimit - this.movement;\n      } else if ((this.movement+move) < 0) {\n         move = 0 - this.movement;\n      }\n      this.movement += move;\n      this.madsor.moveSelection(this.snapshots, move);\n      return move;\n   }\n\n   undo() {\n      //this.madsor.restoreSelectionPosition(this.snapshots);  // do we realy needs this. since we are destroying it.\n      this.madsor.collapseEdgeNew(this.snapshots);\n      //this.snapshots = undefined;\n   }\n}\n\n// Bump\nclass BumpFaceHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"MoveableCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n      this.bump = madsor.bump();\n      this.moveHandler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveAlongNormal\"](madsor);\n   }\n\n   doIt() {\n      this.bump = this.madsor.bump(this.bump);\n      super.doIt();     // = this.madsor.moveSelection(this.snapshots, this.movement);\n   }\n\n   undo() {\n      super.undo(); //this.madsor.restoreSelectionPosition(this.snapshots);\n      this.madsor.undoBump(this.bump);\n   }\n}\n\n// Intrude\nclass IntrudeFaceHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"MoveableCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n      this.intrude = madsor.intrude();\n      this.moveHandler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MoveAlongNormal\"](madsor, true);\n   }\n\n   doIt() {\n      this.intrude = this.madsor.intrude();\n      super.doIt();     // = this.madsor.moveSelection(this.snapshots, this.movement);\n      return true;\n   }\n\n   undo() {\n      super.undo(); //this.madsor.restoreSelectionPosition(this.snapshots);\n      this.madsor.undoIntrude(this.intrude);\n   }\n}\n\n\nclass LiftFaceHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditSelectHandler\"] {  // also moveable\n   constructor(madsor, preview) {\n      super(false, true, false);\n      this.madsor = madsor;\n      this.preview = preview;\n      //this.snapshot = snapshot;\n      // find contours\n      this.contours = this.preview.getSelectedFaceContours();\n      \n   }\n\n   hilite(hilite, currentCage) {  // no needs for currentCage\n      if ((currentCage === this.preview) && hilite.edge) {\n         return  this.contours.edges.has(hilite.edge.wingedEdge);\n      }\n      return false;\n   }\n\n   select(hilite) {\n      if (hilite.edge && (this.contours.edges.has(hilite.edge.wingedEdge))) {\n         // compute axis and center.\n         this.axis = vec3.create();\n         vec3.sub(this.axis, hilite.edge.destination().vertex, hilite.edge.origin.vertex);\n         this.hiliteEdge = hilite.edge;\n         // lift\n         this.lift = this.preview.liftFace(this.contours, hilite.edge);\n         // now ready for rotation.\n         this.moveHandler = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"MouseRotateAlongAxis\"](this.madsor, this.axis, hilite.edge.origin.vertex);\n         return true;\n      }\n      return false;\n   }\n\n   doIt() {\n      this.lift = this.preview.liftFace(this.contours, this.hiliteEdge);\n      super.doIt();\n      return true;\n   }\n\n   undo() {\n      super.doIt();  // this really not needede.\n      // collapseFace\n      this.preview.collapseExtrudeEdge(this.lift.extrudeEdges);\n   }\n}\n\n//\nclass PutOnCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditSelectHandler\"] {\n   constructor(madsor, preview) {\n      super(true, true, true);\n      this.madsor = madsor;\n      this.preview = preview;\n      this.snapshot = preview.snapshotPositionAll();\n   }\n\n   hilite(_hilite, currentCage) {\n      // show that hilite.vertex is actually ok or not, by changing mouse cursor.\n      if (currentCage === this.preview) { // not good, we can only put on other object\n         return false;\n      }\n      return true;\n   }\n\n   select(hilite, _currentCage) { // return true for accepting, false for continue doing things.\n      if (hilite.vertex) {\n         this.vertex = hilite.vertex;\n         this.doIt();\n         return true;\n      } else if (hilite.edge) {\n         this.edge = hilite.edge;\n         this.doIt();\n         return true;\n      } else if (hilite.face) {\n         this.face = hilite.face;\n         this.doIt();\n         return true;\n      }\n      // cannot possibly reach here.\n      return false;\n   }\n\n   doIt() {\n      if (this.vertex) {\n         this.preview.putOnVertex(this.vertex);\n      } else if (this.edge) {\n         this.preview.putOnEdge(this.edge);\n      } else if (this.face) {\n         this.preview.putOnFace(this.face);\n      } else {\n         return false;  // should not happened.\n      }\n      return true;\n   }\n\n   undo() {\n      this.preview.restoreMoveSelection(this.snapshot);\n   }\n}\n\n\nclass MirrorFaceCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      this.mirror = this.madsor.mirror();\n   }\n\n   undo() {\n      this.madsor.undoMirror(this.mirror);\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_facemads.js?");

/***/ }),

/***/ "./js/wings3d_gl.js":
/*!**************************!*\
  !*** ./js/wings3d_gl.js ***!
  \**************************/
/*! exports provided: createWebGLContext, ShaderData, ShaderProgram, gl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createWebGLContext\", function() { return createWebGLContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderData\", function() { return ShaderData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderProgram\", function() { return ShaderProgram; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gl\", function() { return gl; });\n/*\n//\n//     Append a few utilities and convenience functions. now to es6 module.\n//\n*/\n\n\nlet gl = null;\nfunction createWebGLContext(canvasID, attrib) {\n   var _pvt = {currentShader: null};\n\n   // initialization\n   var canvas = document.getElementById(canvasID);\n   if (!canvas) {\n      return null;\n   }\n      \n   attrib = typeof attrib !== 'undefined' ? attrib : { depth: true, stencil: true, antialias: true };\n//   gl = canvas.getContext(\"webgl2\", attrib);\n//   if (!gl) {\n      gl = canvas.getContext(\"webgl\", attrib) || canvas.getContext(\"experimental-webgl\", attrib);\n      if (gl) {\n         // init_extensions(), init_restrictions()\n         let ext = gl.getExtension(\"OES_standard_derivatives\"); // webgl2 is standard.\n         if (ext === null) {\n            console.log(\"No OES_standard_derivatives\");\n            return null;   \n         }\n         ext = gl.getExtension(\"OES_element_index_uint\");\n         if (ext === null) {\n            console.log(\"No OES_element_index_uint\");\n            return null;\n         }\n         console.log(\"WebGL 1 init with extension\");\n      } else {\n         alert(\"Unable to initialize WebGL\");\n         return null;\n      }\n//   } else {\n//      console.log(\"WebGL 2 init successful\");\n//   }\n\n\n   // make sure webgl framebuffer size matched real canvas size.\n   gl.resizeToDisplaySize = function() {\n      var canvas = gl.canvas;\n      var displayWidth = canvas.clientWidth;\n      var displayHeight = canvas.clientHeight;\n      if (canvas.width != displayWidth ||\n          canvas.height != displayHeight) {\n         canvas.width = displayWidth;\n         canvas.height = displayHeight;     \n         gl.viewport(0, 0, displayWidth, displayHeight);\n         return true;\n      }\n      return false;\n   };\n   gl.resizeToDisplaySize();\n\n   // setup variables\n   gl.projection = mat4.create();\n   gl.modelView = mat4.create();\n\n   // binder\n   _pvt.transform = {\n      projection: function(gl, loc) {\n         gl.uniformMatrix4fv(loc, false, gl.projection);\n      },\n      worldView: function(gl, loc) {\n         gl.uniformMatrix4fv(loc, false, gl.modelView);\n      },\n   };\n\n   // utility functions\n   // move from wings3d.wm.\n   // return int32array[0,0, width, height] ...etc.\n   gl.getViewport = function() {\n      return gl.getParameter(gl.VIEWPORT);\n   };\n   // project() transform objectSpace vert to screenSpace,\n   //   return vec4. vec4[3] == 0 meant failure, problems with input projection.\n   gl.project = function(objx, objy, objz, modelview, projection) {\n      //Transformation vectors\n      var input = vec4.fromValues(objx, objy, objz, 1.0);\n          out = vec4.create();\n      //Modelview transform\n      vec4.transformMat4(out, input, modelView);\n      //Projection transform, \n      vec4.transformMat4(input, out, projection);\n      if(input[3] == 0.0) {//The w value\n         return input;\n      }\n      //Perspective division\n      input[0] /= input[3];\n      input[1] /= input[3];\n      input[2] /= input[3];\n      var viewport = gl.getViewport();\n      //screenCoordinate, Map x, y to range 0-1\n      out[0]=(input[0]*0.5+0.5)*viewport[2]+viewport[0];\n      out[1]=(input[1]*0.5+0.5)*viewport[3]+viewport[1];\n      //This is only correct when glDepthRange(0.0, 1.0)\n      out[2]=input[2]*0.5 + 0.5;\t//Between 0 and 1\n      out[3]=1.0;             // out[w] determined success or failure.\n      return out;\n  };\n\n   gl.unProject = function(winx, winy, winz, modelview, projection, viewport) {\n      //Transformation matrices\n      var final = mat4.create(),\n          input = vec4.create(),\n          out = vec4.create();\n      //Calculation for inverting a matrix, compute projection x modelview\n      //and store in A[16]\n      mat4.multiply(final, projection, modelview);\n      //Now compute the inverse of matrix A\n      if(mat4.invert(final, final)==null) {\n         out[3]=0.0;\n         return out;\n      }\n      var viewport = gl.getViewport();\n      //Transformation of normalized coordinates between -1 and 1\n      input[0]=(winx-viewport[0])/viewport[2]*2.0 - 1.0;\n      input[1]=(winy-viewport[1])/viewport[3]*2.0 - 1.0;\n      input[2]=2.0*winz-1.0;\n      input[3]=1.0;\n      //Objects coordinates\n      vec4.transformMat4(out, input, final);\n      if(out[3]==0.0) {\n         return out;\n      }\n      out[0]/=out[3];\n      out[1]/=out[3];\n      out[2]/=out[3];\n      out[3] =1.0;\n      return out;\n   };\n   gl.transformVertex = function(vertex4) {\n       var out = vec4.create();\n       return vec4.transformMat4(out, vec4.transformMat4(out, vertex4, gl.modelView), gl.projection);\n   };\n\n   // shader, programs.\n   gl.compileGLSL = function(vshader, fshader) {\n      // compile vertex and fragment shader\n      var vertexShader = gl.loadShader(gl.VERTEX_SHADER, vshader);\n      if (!vertexShader) {\n         console.log(\"failed to compile vertex shader\");\n         return null;\n      }\n      var fragmentShader = gl.loadShader(gl.FRAGMENT_SHADER, fshader);\n      if (!fragmentShader) {\n         console.log(\"failed to compile fragment shader\");\n         return null;\n      }\n\n      // get program, attach, link\n      var progHandle = gl.createProgram();\n      gl.attachShader(progHandle, vertexShader);\n      gl.attachShader(progHandle, fragmentShader);\n      gl.linkProgram(progHandle);\n\n      // check for error\n      var linked = gl.getProgramParameter(progHandle, gl.LINK_STATUS);\n      if (!linked) {\n         var error = gl.getProgramInfoLog(progHandle);\n         console.log('failed to link program: ' + error);\n         gl.deleteProgram(progHandle);\n         gl.deleteShader(fragmentShader);\n         gl.deleteShader(vertexShader);\n         return null;\n      }\n      return progHandle;\n   };\n\n   gl.loadShader = function(shaderType, shaderSource) {\n      // createShader always work unless shaderType is wrong?\n      var shaderHandle = gl.createShader(shaderType);\n\n      // loading shaderSource then compile shader.\n      gl.shaderSource(shaderHandle, shaderSource);\n      gl.compileShader(shaderHandle);\n\n      // check for successful compilation.\n      var compiled = gl.getShaderParameter(shaderHandle, gl.COMPILE_STATUS);\n      if (!compiled) {\n         var error = gl.getShaderInfoLog(shaderHandle);\n         console.log('failed to compile shader: ' + error);\n         gl.deleteShader(shaderHandle);\n         return null;\n      }\n      return shaderHandle;\n   };\n\n   gl.createShaderProgram = function(vShader, fShader) {\n      var progHandle = gl.compileGLSL(vShader, fShader);\n      if (progHandle) {\n         var info;\n         var attribute = {};\n         var numCount = gl.getProgramParameter(progHandle, gl.ACTIVE_ATTRIBUTES);\n         for (var i = 0; i < numCount; ++i) {\n            info = gl.getActiveAttrib(progHandle, i);\n            if (!info){\n               console.log(\"Something wrong, getActiveAttrib failed\");\n               return null;\n            }\n            attribute[info.name] = {loc: gl.getAttribLocation(progHandle, info.name), type: info.type};\n         }\n         var uniform = {};\n         var transform = {world: null, worldView: null, worldViewProjection: null, view: null, projection: null};\n         numCount = gl.getProgramParameter(progHandle, gl.ACTIVE_UNIFORMS);\n         for (i = 0; i < numCount; ++i) {\n            info  = gl.getActiveUniform(progHandle, i);\n            if (!info) {\n               console.log(\"Something wrong, getActiveUniform failed\");\n               return null;\n            }\n            // check if it belongs to transform?\n            if (transform.hasOwnProperty(info.name)) {\n               transform[info.name] = gl.getUniformLocation(progHandle, info.name);\n            } else {\n               // check for array suffix?\n               uniform[info.name] = {loc: gl.getUniformLocation(progHandle, info.name),\n                                     size: info.size, type: info.type};\n            }\n         }\n         return new ShaderProgram(progHandle, transform, attribute, uniform);\n      }\n      \n   };\n\n   // return buffer Handle.\n   gl.createBufferHandle = function(typedArray, type = gl.ARRAY_BUFFER, draw = gl.STATIC_DRAW) {\n      if (ArrayBuffer.isView(typedArray)) {\n         var handle = gl.createBuffer();\n         gl.bindBuffer(type, handle);\n         gl.bufferData(type, typedArray, draw);\n         gl.bindBuffer(type, null);\n         return handle;\n      } else {\n         console.log(\"not typedArray\");\n         return null;\n      }\n   };\n\n   gl.setBufferAndAttrib = function(handle, position, size=3) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, handle);\n      gl.vertexAttribPointer(position, size, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(position);\n   };\n   \n   gl.bindAttributeToProgram = function(progLoc, attrib) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, attrib.handle);\n      gl.vertexAttribPointer(progLoc, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n      gl.enableVertexAttribArray(progLoc);\n   };\n\n   /**\n    * bind index to current drawing.\n    * @param {shaderData} - gpu data.\n    * @param {string} - name of index\n    */\n   gl.bindIndex = function(data, name) {\n      const handle = data.index[name];\n      if (handle) {\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, handle);\n      }\n   };\n\n   /**\n    * bind attribute to current program\n    * @param {shaderData} - gpu data\n    * @param {array of strings} - the name of attributes to binds to program.\n    */\n   gl.bindAttribute = function(data, names) {\n      _pvt.currentShader.bindAttribute(gl, data.attribute, names);\n   };\n\n   /**\n    * bind uniform to current program\n    * @param {shaderData} - gpu data.\n    * @param {array of strings} - the name of uniforms to bind to program\n    */\n   gl.bindUniform = function(data, names) {\n      _pvt.currentShader.bindUniform(gl, data.uniform, names);\n   }\n/*   gl.bindShaderData = function(data, useIndex=true) {\n      // using current setShader, set shader, set indexbuffer\n      _pvt.currentShader.bindAttribute(gl, data.attribute);\n      _pvt.currentShader.bindUniform(gl, data.uniform);\n      if (useIndex && typeof(data.index)!==\"undefined\" && data.index !== null) {\n         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, data.index.handle);\n      }\n   }; */\n\n   gl.bindTransform = function() {\n      // current shader, set current transform\n      _pvt.currentShader.bindTransform(gl, _pvt.transform);\n   };\n   gl.pushTransform = function(matrix) {\n\n   };\n   gl.popTransform = function() {\n      // restore transform\n   };\n   gl.useShader = function(shader) {\n      _pvt.currentShader = shader;\n      gl.useProgram(shader.progHandle);\n   };\n   gl.disableShader = function() {\n      // disable vertex attribute array\n      if (_pvt.currentShader) {\n         _pvt.currentShader.disableVertexAttributeArray(gl);\n      }\n   };\n\n   gl.drawVertex =  function(drawObject) {\n      gl.bindTransform();\n      gl.bindShaderData(drawObject.shaderData, false);\n      drawObject.drawVertex(gl);\n   };\n\n   gl.drawSelect = function(drawObject) {\n      gl.bindTransform();\n      drawObject.bindSelectorShaderData(gl);\n      drawObject.drawSelect(gl);\n   };\n\n   gl.createShaderData = function() {\n      return new ShaderData();\n   };\n\n   return gl;\n};\n\n\n//\n// define ShaderProgram, ShaderData.\n//\n\n/**input to ShaderProgram.\n */\nconst ShaderData = function() {\n   this.attribute = {};\n   this.uniform = {};\n   this.index = {};\n};\n\nShaderData.attribLayout = function(attribSize=3, attribType=gl.FLOAT, normalized=false, stride=0, offset=0) {\n   return {size: attribSize, type: attribType, normalized: normalized, stride: stride, offset: offset};\n}\n\n\nShaderData.prototype.setupAttribute = function(name, layout, buffer, usage) {\n   this.createAttribute(name, layout, usage);\n   this.resizeAttribute(name, buffer.byteLength);\n   this.uploadAttribute(name, 0, buffer);\n}\n\nShaderData.prototype.createAttribute = function(name, layout, usage) {\n   if (!this.attribute[name]) {\n      var handle = gl.createBuffer();\n      this.attribute[name] = {handle: handle,\n                              byteLength: 0,\n                              usage: usage,\n                              size: layout.size,\n                              type: layout.type,\n                              normalized: layout.normalized,\n                              stride: layout.stride,\n                              offset: layout.offset\n                             };\n   } else {\n      console.log(\"Shader Data: \" + name + \" already initialized\");\n   }\n};\n\nShaderData.prototype.resizeAttribute = function(name, byteLength) {//, usage) {\n   var attrib = this.attribute[name];\n   if (attrib && attrib.byteLength != byteLength) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, attrib.handle);\n      gl.bufferData(gl.ARRAY_BUFFER, byteLength, attrib.usage);\n      attrib.byteLength = byteLength;\n   }\n};\n\nShaderData.prototype.deleteAttribute = function(name) {\n   var attribute = this.attribute[name];\n   if (attribute) {\n      gl.deleteBuffer(attribute.handle);\n      this.attribute[name] = null;\n   }\n};\n\nShaderData.prototype.freeAllAttributes = function() {\n   var removeList = [];\n   for (var key in this.attribute) {\n      removeList.push(key);\n   }\n   for (var i = 0; i < removeList.length; ++i) {\n      this.deleteAttribute(removeList[i]);\n   }\n};\n\n\nShaderData.prototype.uploadAttribute = function(name, byteOffset, typedArray)  {\n   var attrb = this.attribute[name];\n   if (attrb) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, attrb.handle);\n      gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, typedArray);\n   } else {\n      console.log(\"Shader Data: \" + name + \" not initialized\");\n   }\n};\n\n\n/** \n * index is used for drawElement\n * @param {string} - index name\n * @param {typedArray} - array of unsigned int\n */\nShaderData.prototype.setIndex = function(name, index) {\n   let handle = this.index[name];\n   if (handle) {\n      gl.deleteBuffer(handle);\n      this.index[name] = undefined;\n   }\n   if (index) {\n      this.index[name] = gl.createBufferHandle(index, gl.ELEMENT_ARRAY_BUFFER);\n   }\n};\n\nShaderData.prototype.setUniform1f = function(name, float) {\n   this.uniform[name] = {value: new Float32Array(1), binder: ShaderData.uniform1fFn};\n   this.uniform[name].value = float;\n};\n\nShaderData.uniform1fFn = function(gl, loc, value) {\n   gl.uniform1f(loc, value);\n};\n\nShaderData.prototype.setUniform3fv = function(name, arry3) {   // 3fv === vec3\n   this.uniform[name] = {value: new Float32Array(arry3), binder: ShaderData.uniform3fvFn};\n};\n\nShaderData.uniform3fvFn = function(gl, loc, value) {\n   gl.uniform3fv(loc, value);\n}; \n\nShaderData.prototype.setUniform4fv = function(name, arry4) {\n   this.uniform[name] = {value: new Float32Array(arry4), binder: ShaderData.uniform4fvFn};\n};\n\nShaderData.uniform4fvFn = function(gl, loc, value) {\n   gl.uniform4fv(loc, value);\n};\n\n// a few predefine var. \n//        attributes: [\"position\", \"normal\", \"uv\"],\n//        uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\"] ? how about inverse?\nvar ShaderProgram = function(progHandle, transform, attribute, uniform) {\n   this.progHandle = progHandle;\n   this.transform = transform;\n   this.attribute = attribute;\n   this.uniform = uniform;\n};\n\nShaderProgram.prototype.disableVertexAttributeArray = function(gl) {\n   for (var key in this.attribute) {\n      if (this.attribute.hasOwnProperty(key)) {\n         gl.disableVertexAttribArray(this.attribute[key].loc);\n      }\n   }\n};\n\nShaderProgram.prototype.bindAttribute = function(gl, attribute, names) {\n   try {\n      for (let key of names) {\n         if (attribute.hasOwnProperty(key) && this.attribute.hasOwnProperty(key)) {   // don't need to check this.attribute' inherited property, cannot possibley exist\n            const attrb = attribute[key];\n            gl.bindAttributeToProgram(this.attribute[key].loc, attrb);\n         } else {\n            // don't have property. console.log?\n            //console.log(\"shaderData don't have shader attribute: \" + key);\n         }\n      }\n   }\n   catch (e) {\n      console.log(e);\n   }\n};\n\nShaderProgram.prototype.bindUniform = function(gl, uniform, names) {\n   try {\n   for (let key of names) {\n      if (uniform.hasOwnProperty(key) && this.uniform.hasOwnProperty(key)) {\n         var uni = uniform[key];\n         uni.binder(gl, this.uniform[key].loc, uni.value);\n      } else {\n         // don't have property. console.log?\n         //console.log(\"shaderData don't have shader uniform: \" + key);\n      }\n   }\n   }\n   catch (e) {\n      console.log(e);\n   }\n};\n\nShaderProgram.prototype.bindTransform = function(gl, transform) {\n   try {\n     for (var key in this.transform) {\n      if (transform.hasOwnProperty(key)) {\n         var binder = transform[key];\n         binder(gl, this.transform[key]);\n      }\n   } \n   }\n   catch (e) {\n      console.log(e);\n   }\n};\n\nShaderProgram.prototype.getTypeByName = function(type) {\n/*\t  var FLOAT = 0x1406;\n\t  var FLOAT_VEC2 = 0x8B50;\n\t  var FLOAT_VEC3 = 0x8B51;\n\t  var FLOAT_VEC4 = 0x8B52;\n\t  var INT = 0x1404;\n\t  var INT_VEC2 = 0x8B53;\n\t  var INT_VEC3 = 0x8B54;\n\t  var INT_VEC4 = 0x8B55;\n\t  var BOOL = 0x8B56;\n\t  var BOOL_VEC2 = 0x8B57;\n\t  var BOOL_VEC3 = 0x8B58;\n\t  var BOOL_VEC4 = 0x8B59;\n\t  var FLOAT_MAT2 = 0x8B5A;\n\t  var FLOAT_MAT3 = 0x8B5B;\n\t  var FLOAT_MAT4 = 0x8B5C;\n\t  var SAMPLER_2D = 0x8B5E;\n\t  var SAMPLER_CUBE = 0x8B60;\n\t  var SAMPLER_3D = 0x8B5F;\n\t  var SAMPLER_2D_SHADOW = 0x8B62;\n\t  var FLOAT_MAT2x3 = 0x8B65;\n\t  var FLOAT_MAT2x4 = 0x8B66;\n\t  var FLOAT_MAT3x2 = 0x8B67;\n\t  var FLOAT_MAT3x4 = 0x8B68;\n\t  var FLOAT_MAT4x2 = 0x8B69;\n\t  var FLOAT_MAT4x3 = 0x8B6A;\n\t  var SAMPLER_2D_ARRAY = 0x8DC1;\n\t  var SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\n\t  var SAMPLER_CUBE_SHADOW = 0x8DC5;\n\t  var UNSIGNED_INT = 0x1405;\n\t  var UNSIGNED_INT_VEC2 = 0x8DC6;\n\t  var UNSIGNED_INT_VEC3 = 0x8DC7;\n\t  var UNSIGNED_INT_VEC4 = 0x8DC8;\n\t  var INT_SAMPLER_2D = 0x8DCA;\n\t  var INT_SAMPLER_3D = 0x8DCB;\n\t  var INT_SAMPLER_CUBE = 0x8DCC;\n\t  var INT_SAMPLER_2D_ARRAY = 0x8DCF;\n\t  var UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\n\t  var UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\n\t  var UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\n\t  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\n\t  var TEXTURE_2D = 0x0DE1;\n\t  var TEXTURE_CUBE_MAP = 0x8513;\n\t  var TEXTURE_3D = 0x806F;\n\t  var TEXTURE_2D_ARRAY = 0x8C1A;*/\n\n};\n\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_gl.js?");

/***/ }),

/***/ "./js/wings3d_guidetutor.js":
/*!**********************************!*\
  !*** ./js/wings3d_guidetutor.js ***!
  \**********************************/
/*! exports provided: tours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tours\", function() { return tours; });\n/* harmony import */ var _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_interact */ \"./js/wings3d_interact.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/*\n//\n// introductory tutorials. \n/// later expand to our own tutorial format and editor?\n//\n*/\n\n\n\n\nconst tours = {};\n\nfunction createGuideTour() {\n   //tutor.addStep();\n\n   tours.about = () => {\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"cancel\"]();\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Welcome\", \"\", \"<p>Wings3D4Web is a web implementation of Wings3D modeller</p>\" +\n       \"<p>Use Help's interactive learning aid</p>\" +\n       \"<p>Or goto <a target='_blank' href='http://www.wings3d.com/?page_id=87'>Wings3D documentation page</a> for more instruction.</p>\",\n       \"helpMenu\", \"bottom\"\n      );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"startTour\"]();\n   };\n\n   tours.introduction = () => {\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"cancel\"]();\n      // add step into tutor\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Welcome\", \"Interface Essential\", `Wings 3D interface keeps the focus on modeling. It consists of \n         <ul>\n          <li>Menubar</li>\n          <li>Toolbar</li>\n          <li>Geometry Info</li>\n          <li>Modelling Area</li>\n          <li>Information Line</li>\n         </ul>`,\n         \"\", \"top\"\n      );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Status\", \"Geometry Info\", \"Shown information about the current Model if any\",\n       \"statusbar\", \"bottom-start\"\n      );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Information\", \"Information Line\", \n       `<ul>\n         <li>Hovering over almost anything in Wings displays its function in the info line.</li>\n         <li><mark>L, M</mark>, and <mark>R</mark> are used in the info line to indicate commands initiated by the <em>Left, Middle</em>, and <em>Right</em> mouse buttons.</li>\n         <li>Uppercase letters in square brackets represent keyboard keys like <mark>[C]</mark>.</li>\n         <li>Numbers in square brackets represent number keys on the keyboard like <mark>[1], [2], [3]</mark>.</li>\n         <li><mark>[Shift], [Ctrl]</mark>, and <mark>[Alt]</mark> are keyboard modifier keys.</li>\n        </ul>`,\n       \"helpbar\", \"top-start\"\n      );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Undo\", \"undo/redo\", \"undo button revert the last operation\",\n       \"undoEdit\", \"bottom\"\n      );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Redo\", \"undo/redo\", \"redo button revert the last undo operation\",\n       \"redoEdit\", \"bottom\"\n     );\n   \n      // show \n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"startTour\"]();\n   };\n   tours.basicCommands = () => {\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"cancel\"]();   // clear tours.\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addZoomStep\"](\"Welcome\", \"Zoom\", \"Mouse wheel scroll in Canvas will zoom in/out\",\n       \"\", \"top\");\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addExpectStep\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].cameraModeEnter, \"Camera\", \"Camera Mode\", \"Let <em>M</em>, click middle mouse button anywhere in the Canvas to enter camera mode\",       \n       \"\", \"right\");\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addExpectStep\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].cameraModeExit, \"MoveCamera\", \"Move Camera\", \"Information Line shows you how to move camera, exit Camera Mode, and you can still zoom in/out\",\n       \"helpbar\", \"top-start\");\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addMultiStep\"](\"Cube Creation\", \"Create Cube Steps\", \"Steps to create a Cube\", \"\", \"top\",\n         [_wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"expectStep\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].contextMenu, \"CreateMenu\", \"ContextMenu\", \"Let <em>R</em> click right mouse button in the Canvas empty place to bring up CreateObject Menu\",\n           \"\", \"left\"),\n          _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"expectStep\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].createCubeDialog, \"CreateCubeForm\", \"Great Job\", \"Click Cube MenuItem to create Cube\",\n           \"createCube\", \"right\"),\n          _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"expectStep\"](\"createCube\", \"CreateCube\", \"Cube Form\", \"You can adjust the cube's parameter\",\n           \"createCubeForm\", \"top\")]\n         );\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addFaceSelectStep\"](1, \"selectFace\", \"Select any Face\", \"Try to click/select face\",\n         \"left\");\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addStep\"](\"Congratulation\", \"Congratulation\", \"<em>R</em>, Right click mouse button will bring up Face tools. Now you know the basic steps.\",\n           \"\", \"bottom\");\n\n/*\n      Tutor.addExpectStep(Wings3D.action.contextMenu, \"CreateMenu\", \"ContextMenu\", \"Let <em>R</em> click right mouse button in the Canvas empty place to bring up CreateObject Menu\",\n       \"\", \"left\");\n      Tutor.addExpectStep(Wings3D.action.createCubeDialog, \"CreateCubeForm\", \"Great Job\", \"Click Cube MenuItem to create Cube\",\n       \"createCube\", \"right\");\n      Tutor.addExpectStep(\"createCube\", \"CreateCube\", \"Cube Form\", \"You can adjust the cube's parameter\",\n       \"createCubeForm\", \"top\");\n      Tutor.addFaceSelectStep(1, \"selectFace\", \"Select any Face\", \"Try to click/select face\",\n       \"left\");\n      Tutor.addStep(\"Congratulation\", \"Congratulation\", \"<em>R</em>, Right click mouse button will bring up Face tools. Now you know the basic steps.\",\n       \"\", \"bottom\"); */\n\n       // start tour\n       _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"startTour\"]();\n   };\n   tours.tableTutor = () => {\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"cancel\"]();   // clear tours.\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"addExpectStep\"](\"Make a simple table\", \"Cube\", \"RMB (anywhere in geometry window) to display the primitives menu and select cube with LMB.\", \n      \"\", \"top\");\n\n      _wings3d_interact__WEBPACK_IMPORTED_MODULE_0__[\"startTour\"]();\n   };\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_1__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].about.name, (ev) => {\n      tours.about();\n   });\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_1__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].introduction.name, (ev) => {\n      tours.introduction();\n   });\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_1__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].basicCommands.name, (ev) => {\n      tours.basicCommands();\n   });\n\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_1__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"action\"].tableTutor.name, (ev) => {\n      tours.tableTutor();\n   });\n}\n\n_wings3d__WEBPACK_IMPORTED_MODULE_2__[\"onReady\"](createGuideTour);\n\n\n\n//# sourceURL=webpack:///./js/wings3d_guidetutor.js?");

/***/ }),

/***/ "./js/wings3d_hotkey.js":
/*!******************************!*\
  !*** ./js/wings3d_hotkey.js ***!
  \******************************/
/*! exports provided: runHotkeyAction, setHotkey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"runHotkeyAction\", function() { return runHotkeyAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setHotkey\", function() { return setHotkey; });\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n//\n// hotkey handling and remapping.\n//\n//\n//\n\n\n\nconst keyMap = new Map;\n\nfunction runHotkeyAction(mode, event) {\n   // extract alt, ctrl, shift key\n   const meta = Object(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"createMask\"])(event.altKey, event.ctrlKey, event.shiftKey);\n   // extract key\n   const hotkey = event.key.toLowerCase();\n   // run the binding function\n   let metaSet = keyMap.get(hotkey);\n   if (metaSet) {\n      // check mode specific first\n      for (let value of metaSet) {\n         if ( (meta === value.meta) && (value.mode === mode)) { // has all the meta\n            Object(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"runAction\"])(0, value.id, event);\n            return;\n         }\n      }\n      // check for non-mode, if no mode specific found\n      for (let value of metaSet) {\n         if ( (meta === value.meta) && (value.mode === null)) { // has all the meta\n            Object(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"runAction\"])(0, value.id, event);\n            return;\n         }\n      }\n   }\n};\n\n\nfunction setHotkey(mode, id, hotkey, meta='') {\n      hotkey = hotkey.toLowerCase();\n      meta = meta.toLowerCase();\n      const metaMask = Object(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"createMask\"])(meta.indexOf('alt') > -1, meta.indexOf('ctrl') > -1, meta.indexOf('shift') > -1);\n      if (!keyMap.has(hotkey)) {\n         keyMap.set(hotkey, []);\n      }\n      keyMap.get(hotkey).unshift({mode: mode, meta: metaMask, id: id});\n};\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_hotkey.js?");

/***/ }),

/***/ "./js/wings3d_i18n.js":
/*!****************************!*\
  !*** ./js/wings3d_i18n.js ***!
  \****************************/
/*! exports provided: i18n, setCurrentLocale, getCurrentLocale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i18n\", function() { return i18n; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setCurrentLocale\", function() { return setCurrentLocale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentLocale\", function() { return getCurrentLocale; });\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/*\n routines for translation. l10n.\n\n stub for i18n, other stuff, like number, date format.\n*/\n\n\n\n\nconst i18nAttrib = \"data-i18n\";\nconst newLine = \"\\n\";\nlet LMB = \"LMB: \";\nlet MMB = \"MMB: \";\nlet RMB = \"RMB: \";\nlet currentCountry = \"US\";\nlet currentLanguage = \"en\";\nlet defaultMessages;\nlet currentMessages;\n\nfunction getTemplate(key) {\n   let template = currentMessages.get(key);\n   if (!template && defaultMessages) {\n      return defaultMessages.get(key);\n   }\n   return template;\n}\n\nfunction helpTooltip(ev) {\n   const text = this.getAttribute(\"title\");\n   const helpText = text.replace(newLine, \"    \");\n   help(helpText);\n}\nfunction* entries(obj) {\n   for (let key in obj) {\n      yield [key, obj[key]];\n   }\n}\nfunction resetStaticElements(langObj) {  \n   // first copy to currentMessages.\n   currentMessages = new Map(entries(langObj));\n   if (!defaultMessages) {\n      defaultMessages = currentMessages;\n   }\n   \n   // set the resources staticElement\n   //console.log(langJson);\n   let allDom = document.querySelectorAll(`[${i18nAttrib}]`);\n   for (let elem of allDom) {\n      let warning = true;\n      let key = elem.getAttribute(i18nAttrib);\n      let content = getTemplate(key);\n      if (content) {\n         elem.textContent = content;\n         warning = false;\n      } \n      // now prepare tooltips\n      let tooltip = key + \"_tooltip\";\n      content = getTemplate(tooltip);\n      if (content) {\n         warning = false;\n         let text = \"\";\n         if (Array.isArray(content)) {\n            if (content[0]) {\n               text += LMB + content[0];\n            }\n            if (content[1]) {\n               text += newLine + MMB + content[1];\n            }\n            if (content[2]) {\n               text += newLine + RMB + content[2];\n            }\n         } else { // must be string\n            text = content;\n         }\n         elem.setAttribute(\"title\", text);   // use title tooltip directly\n         // should we register/unregister mouseover event?\n         elem.removeEventListener(\"mouseover\", helpTooltip);\n         elem.addEventListener(\"mouseover\", helpTooltip);\n      }\n      if (warning) {\n         console.log(`Warning: ${key} has no translation`);\n      }\n   }\n}\n\nfunction loadResource(language, successCallback){\n   Object(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"ezFetch\"])(`./resources/${language}.json`)\n      .then(data => {\n         resetStaticElements(data);\n         if (successCallback) {\n            successCallback();\n         }\n      })\n      .catch(err => {\n         console.log('Fetch Error :-S', err);\n      });\n} \n\nfunction getCurrentLocale() {\n   return {country: currentCountry, language: currentLanguage};\n}\n\n/**\n  * Sets the current language/locale and does any application initialization after loading language.\n  *\n  * @method load\n  * @param {language} The two-letter ISO language code.\n  * @param {country} The two-letter ISO conuntry code.\n  * @param {successCallback} The function to be called when the language/locale has been loaded. \n  */\nfunction setCurrentLocale(language, country, successCallback) {\n   currentCountry = country || 'unknown';\n   currentLanguage = language || 'unknown';\n\n   loadResource(currentLanguage, successCallback);\n};\n\n/*\n * wonderfully simple template engine.\n * https://stackoverflow.com/questions/30003353/can-es6-template-literals-be-substituted-at-runtime-or-reused\n*/\nconst fillTemplate = function(template, templateVars){\n   return new Function(`return \\`${template}\\`;`).call(templateVars);\n}\n   /**\n     * Replaces each format item in a specified localized string \n     * e.g. key = 'helloFirstNameLastName'\n            localised value of key = \"Hello ${this.firstname} ${this.lastname}!\"\n     *      _('helloFirstNameLastName', {firstname: 'John', lastname:'Smith'});\n     *      returns \"Hello John Smith!\"\n     *\n     * @method _\n     * @param {key} The unique identifier for the resource name (using object notation).\n     * @return {String} Returns the localized value based on the provided key and optional arguments.\n     */\nfunction i18n(key, templateVars) {\n   let template = getTemplate(key);\n   if (template) {\n      if (templateVars) {\n         return fillTemplate(template, templateVars);\n      }\n      return template;\n   }\n   return `Error: ${key} don't exist`;\n};\n\n\n \n\n\n// init\nObject(_wings3d__WEBPACK_IMPORTED_MODULE_0__[\"onReady\"])(()=> {\n   // init\n   setCurrentLocale(\"en\");\n   // hookup to language select\n   let selectLang = document.querySelector('#selectLanguage');\n   if (selectLang) {\n      selectLang.addEventListener('change', function(ev) {\n         setCurrentLocale(selectLang.value); // change locale\n       });\n   }\n});\n\n//# sourceURL=webpack:///./js/wings3d_i18n.js?");

/***/ }),

/***/ "./js/wings3d_importexport.js":
/*!************************************!*\
  !*** ./js/wings3d_importexport.js ***!
  \************************************/
/*! exports provided: ImportExporter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImportExporter\", function() { return ImportExporter; });\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_wingededge */ \"./js/wings3d_wingededge.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n//\n// file handling. \n// 1) handling local file upload. and simple file download.\n// todo\n// 2) dropbox, yandex.\n// 3) google drive, microsoft onedrive, baidupan to come later.\n//\n\n\n\n\n\n\n\nclass ImportExporter {\n   constructor(importMenuText, exportMenuText) {\n      const self = this;\n      // plug into import/export menu\n      if (importMenuText) {\n         // first get import Submenu.\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"addMenuItem\"]('fileImport', 'import' + importMenuText.split(\" \")[0], importMenuText, function(ev) {\n               _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"openFile\"](function(file) { // open file Dialog, and retrive data\n                     self.import(file);\n                  });      \n            });\n      }\n      if (exportMenuText) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"addMenuItem\"]('fileExport', 'export' + exportMenuText.split(\" \")[0], exportMenuText, function(ev) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"runDialog\"]('#exportFile', ev, function(form) {\n               const data = form.querySelector('input[name=\"Filename\"');\n               if (data) {\n                  self.export(data.value);\n               }\n             });\n         });\n      }\n      // init at beginning.\n      this._reset();\n   }\n\n\n   export(filename) {\n      const blob = this._export(_wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]());\n      saveAs(blob, filename + '.' + this.extension());\n   }\n\n   import(file) {\n      const self = this;\n      let reader = new FileReader();\n\n      reader.onload = function(ev) {\n         const text = reader.result;\n         const world = self._import(text);\n         const cages = [];\n         for (let cage of world) {\n            cages.push( new _wings3d_model__WEBPACK_IMPORTED_MODULE_0__[\"CreatePreviewCageCommand\"](cage) );\n         }\n         if (cages.length > 1) {\n            // combo\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"undoQueueCombo\"]( cages );\n         } else if (cages.length > 0) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"undoQueue\"](cages[0]);\n         }\n         // after we finalised _reset too.\n         self._reset();\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"updateWorld\"]();\n      }\n\n      reader.readAsText(file);\n   }\n\n   _reset() {\n      this.objs = [];\n      this.obj = null;\n      this.objView = null;\n      this.realVertices = []; // convert index\n      this.polygonCount = 0;\n      this.vertexCount = 0;\n      this.non_manifold = [];\n   }\n};\n\n\n\n//# sourceURL=webpack:///./js/wings3d_importexport.js?");

/***/ }),

/***/ "./js/wings3d_interact.js":
/*!********************************!*\
  !*** ./js/wings3d_interact.js ***!
  \********************************/
/*! exports provided: tours, targetCage, step, expectStep, faceSelectStep, addStep, addExpectStep, addFaceSelectStep, add, addMultiStep, addZoomStep, zoomStep, cancel, complete, startTour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tours\", function() { return tours; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"targetCage\", function() { return targetCage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"step\", function() { return step; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expectStep\", function() { return expectStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"faceSelectStep\", function() { return faceSelectStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStep\", function() { return addStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addExpectStep\", function() { return addExpectStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addFaceSelectStep\", function() { return addFaceSelectStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addMultiStep\", function() { return addMultiStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addZoomStep\", function() { return addZoomStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoomStep\", function() { return zoomStep; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cancel\", function() { return cancel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"complete\", function() { return complete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startTour\", function() { return startTour; });\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n//\n// interact. tutoring.\n//\n\n\n\n\n\nclass TutorStep {\n   constructor(title, text, targetID, placement) {\n     this.targetID = targetID;\n     this.placement = placement;\n     this.title = title;\n     this.content = text;\n     this.options = {};\n     this.options.showNext = true;\n   }\n\n   // do functions along recursively up the parent\n   static walkupDoms(target, ancestorTarget, fn) {\n      if (target) {\n         const parent = target.parentNode;\n         for (let element = parent.firstElementChild; element; element = element.nextElementSibling) {\n            if (element !==target) {\n               fn(element);\n            }           \n         }\n         if (parent !== ancestorTarget) {\n            this.walkupDoms(parent, ancestorTarget, fn);\n         }\n\n      } else { // select all parent's childern, except canvas\n         for (let element = ancestorTarget.firstElementChild; element; element = element.nextElementSibling) {\n            if (element.id !== \"canvas\") {\n               fn(element);\n            }\n         }\n      }\n   }\n\n   cancel() {\n      this.done();\n   }\n\n   done() {\n      // unblur all other id\n      let target;\n      if (this.targetID !== '') {\n         target = document.getElementById(this.targetID);\n      }\n      TutorStep.walkupDoms(target, document.body, function(element) {element.classList.remove('unfocus');});\n   }\n\n   expect(action, value) {}\n\n   option(name) {\n      return this.options[name];\n   }\n\n   show() {\n      // place on  the world.\n      popUp.title.textContent = this.title;\n      popUp.content.innerHTML = this.content;\n      popUp.bubble.classList.remove(\"left\", \"right\", \"top\", \"bottom\");\n      popUp.bubble.classList.add(_wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"getArrow\"](this.placement));\n      // now place it\n      const placement = _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"placement\"](this.targetID, this.placement, popUp.bubble);\n      popUp.bubble.style.top = placement.top.toString() + \"px\";\n      popUp.bubble.style.left = placement.left.toString() + \"px\"; \n      // blur all not ide.\n      let target;\n      if (this.targetID !== '') {\n         target = document.getElementById(this.targetID);\n      }\n      TutorStep.walkupDoms(target, document.body, function(node) {node.classList.add('unfocus')});\n   }\n}\n\n\nclass MultiStep extends TutorStep {\n   constructor(title, text, targetID, placement, steps) {\n      super(title, text, targetID, placement);\n      this.steps = steps;\n      this.endStep = steps[steps.length-1].step;\n   }\n\n   cancel() {\n      super.cancel();\n      // remember to clean up.\n      setMultiStep(null);\n   }\n\n   done() {\n      const realStep = getRealCurrentStep();\n      if (realStep  === this) {\n         super.done();\n      } else { // let substep handle it.\n         realStep.done();\n         if (realStep === this.endStep) {\n            // should we insert an repeat again? congratulation? or something?\n            setMultiStep(null);\n            popUp.progressBar.style.display = 'none';\n            popUp.progressDone.style.width = '0%';\n            popUp.progressIndicator.style.width = '0%';\n         }\n      }\n   }\n\n   // let substep handle it.\n   expect(action, value) {\n      const realStep = getRealCurrentStep();\n      if (realStep !== this) {\n         realStep.expect(action, value);\n      }\n   }\n\n   show() {\n      const realStep = getRealCurrentStep();\n      if (realStep === this) {\n         super.show();\n         setMultiStep(this);\n         this.begin = getCurrentStation() + 1;\n         this.end = this.begin + this.steps.length;\n         const percent = (1 / this.steps.length) * 100;\n         popUp.progressIndicator.style.width = percent + '%';\n         popUp.progressBar.style.display = 'flex';\n      } else { // run the real things\n         realStep.show();\n         // update the x/y progress bar.\n         const x = getCurrentStation() - this.begin;\n         const percent = (x / this.steps.length)*100;\n         popUp.progressDone.style.width = percent + '%';   // set the progress bar's percentage.\n      }\n   }\n}\n\n\nclass ExpectStep extends TutorStep {\n   constructor(expect, title, text, targetID, placement) {\n      super(title, text, targetID, placement);\n      this.expectAction = expect;\n      this.options.showNext = false;\n   }\n\n   action(value) {\n      goNext();\n   }\n\n   expect(action, value) {\n      if (this.expectAction === action) { // yes, great, now we can goto next step\n         this.action(value);\n      } else {\n         // show error, and try to rewind?\n         \n      }\n   }\n}\n\n\nclass ExpectZoomStep extends ExpectStep {\n   constructor(title, text, targetID, placement) {\n      super(_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"action\"].cameraZoom, title, text, targetID, placement);\n   }\n\n   action(value) {\n      // now zoom step is done, we can show next button.\n      nextButton(true);\n   }\n}\n\n\nclass SelectStep extends TutorStep {\n   constructor(tour, selections, title, text, placement) {\n      super(tour, title, text, \"\", placement);\n      if (Number.isInteger(selections)) {\n         this.count = selections;\n         this.countDown = selections;\n      } else {\n         this.selections = selections;\n         this.countDown = new Set(selections);\n      } \n   }\n\n   expect(action, value) {\n      if (action === this.modeSelect) {\n         // now check inside the array. if the array is empty. check number.\n         if (this.count !== undefined) {\n            if(--this.countDown === 0) {\n               goNext();\n            } else {\n               this.showSelectionCount();\n            }\n         } else {\n            if (this.countDown.has(value)) {\n               this.countDown.delete(value);\n               this.showSelectionCount();\n            }\n         }\n      }\n   }\n\n   done() {\n      popUp.select.textContent = \"\";    \n   }\n\n   show() {\n      super.show();\n      this.showSelectionCount();\n   }\n\n   showSelectionCount() {\n      if (this.count !== undefined) {\n         popUp.select.textContent = \"selection \" + (this.count - this.countDown).toString() + \" of \" + (this.count).toString();\n      } else {\n            // popUp.select.textContent = (this.selections.size - this.countDown.size).toString() + \" of \" + (this.selections.size).toString();\n      }\n   }\n}\n\nclass FaceSelectStep extends SelectStep {\n   constructor(tour, selections, title, text, placement) {\n      super(tour, selections, title, text, placement);\n      this.modeSelect = \"faceSelectOn\";\n   }\n}\n\nclass EdgeSelectStep extends SelectStep {\n}\n\n\n\n//\n// export variable\n//\nconst tours = {};\nlet targetCage = null;\n\n//\n// internal accounting.\n//\nconst rail = {stops: new Map, routes: [], currentStation: -1};\nlet multiStep = null;   // current multistep if any\nlet popUp = {};\n// init() popup.bubble.\nfunction init(idName) {\n   // default \n   popUp.bubble = document.getElementById('tutorGuide');\n   if (popUp.bubble) {\n      popUp.close = extractElement(\"close\");\n      if (popUp.close) { // get close\n         popUp.close.addEventListener('click', function(e) {\n            cancel();\n         });\n      }\n      popUp.next = extractElement(\"next\");\n      if (popUp.next) {\n         popUp.next.addEventListener('click', function(ev){\n            if (popUp.next.textContent === \"Done\") {\n               complete();\n            } else {\n               goNext();\n            }\n         });\n      }\n      //\n      popUp.title = extractElement(\"tutor-title\");\n      popUp.content = extractElement(\"tutor-content\");\n      popUp.select = extractElement(\"tutor-selection\");\n      popUp.progressBar = extractElement(\"tutor-progress\");\n      popUp.progressDone = extractElement(\"tutor-progress-done\");\n      popUp.progressIndicator = extractElement('tutor-progress-indicator');\n   }\n}\n\nfunction nextButton(shown) {\n   if (popUp.next) {\n      if (shown) {\n         popUp.next.style.display = 'inline-block';\n      } else {\n         popUp.next.style.display = 'none';\n      }\n   }\n}\n\nfunction setMultiStep(obj) {\n   multiStep = obj;\n};\n\nfunction getCurrentStep() {\n   if (multiStep) {  // let multiStep handle it\n      return multiStep;\n   } else {\n      return rail.routes[rail.currentStation];\n   }\n};\n\nfunction getRealCurrentStep() {\n   return rail.routes[rail.currentStation];\n};\n\nfunction getCurrentStation() {\n   return rail.currentStation;\n}\n\nfunction extractElement(className) {\n   const nodeList = popUp.bubble.getElementsByClassName(className);\n   if (nodeList.length > 0) {\n      return nodeList[0];\n   }\n   return undefined;\n};\n      \nfunction noDuplicate(nameId) {      \n   if (rail.stops.has(nameId)) {\n      console.log(\"bad step: already has \", nameId);\n      return false;\n   }\n   return true;\n};\n\nfunction add(nameStep) {  // rename from _addStep, also return success or failure.\n   if (noDuplicate(nameStep.nameId)) {\n      rail.stops.set(nameStep.nameId, rail.routes.length);\n      rail.routes.push(nameStep.step);\n      return true;\n   } else {\n      return false;\n   }\n};\n    \n//\nfunction step(nameId, title, text, targetID, placement, stepOptions) {\n   return {nameId: nameId, step: new TutorStep(title, text, targetID, placement)};\n};\nfunction addStep(nameId, title, text, targetID, placement, stepOtions) {\n   add(step(nameId, title, text, targetID, placement, stepOtions));\n};\n\nfunction expectStep(expect, nameId, title, text, targetID, placement, stepOptions) {\n   return {nameId: nameId, step: new ExpectStep(expect, title, text, targetID, placement)};\n};\nfunction addExpectStep(expect, nameId, title, text, targetID, placement, stepOptions) {\n   add(expectStep(expect, nameId, title, text, targetID, placement, stepOptions));\n};\n\nfunction faceSelectStep(selection, nameId, title, text, placement, stepOptions) {\n   return {nameId: nameId, step: new FaceSelectStep(selection, title, text, placement)};\n};\nfunction addFaceSelectStep(selection, nameId, title, text, placement, stepOptions) {\n   add(faceSelectStep(selection, nameId, title, text, placement, stepOptions));\n};\n\nfunction zoomStep(nameId, title, text, targetID, placement, stepOptions) {\n   return {nameId: nameId, step: new ExpectZoomStep(title, text, targetID, placement, stepOptions)};\n}\n\nfunction addZoomStep(nameId, title, text, targetID, placement, stepOptions) {\n   add(zoomStep(nameId, title, text, targetID, placement, stepOptions));\n}\n\n// add MultiStep.\nfunction addMultiStep(nameId, title, text, target, placement, steps) {\n   //\n   const multiStep = new MultiStep(title, text, target, placement, steps);\n   add({nameId: nameId, step: multiStep}); // begin;\n   for (let step of steps) {\n      add(step);\n   }\n}\n\n\nlet _play = function(stepNumber) {\n   if ((stepNumber < 0) || (stepNumber >= rail.routes.length)) {\n      console.log(\"bad step number in tutor guide\");\n   } else {\n      if (stepNumber === (rail.routes.length-1)) {\n         // change the NextButton to DoneButton\n         popUp.next.textContent = \"Done\";\n      }\n      if ((rail.currentStation >= 0) && (rail.currentStation < rail.routes.length)) {\n         const prevStep = getCurrentStep();//rail.routes[rail.currentStation];\n         prevStep.done();\n      }\n      rail.currentStation = stepNumber;\n      const step = getCurrentStep();//rail.routes[stepNumber];\n      // apply data\n      nextButton(step.option('showNext'));\n      step.show();\n   }\n};\n    \nfunction startTour(stepArray) {\n   _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"interposeLog\"](expect, true);\n   //myObj.hasOwnProperty('key')\n   if (stepArray) {\n\n   }\n   // onto the world\n   popUp.bubble.classList.remove(\"hide\");\n   // display firstStep\n   _play(0);\n};\n    \nfunction complete() {\n   // remove all unfocus class\n   if (rail.currentStation > -1) {\n      rail.routes[rail.currentStation].done();\n   }\n   // restore to original condition\n   popUp.bubble.classList.add(\"hide\");\n   popUp.next.textContent = \"Next\";\n   rail.stops.clear();\n   rail.routes.length = 0;\n   rail.currentStation = -1;\n   _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"interposeLog\"](expect, false);   // remove interceptLog\n};\n    \nfunction cancel() {\n   complete();\n};\nfunction goNext() { _play(rail.currentStation+1); };\n    \nfunction goBack() { _play(rail.currentStation-1); };\n    \nfunction goTo(id) {};\n\nfunction expect(action, log) {\n   if (rail.currentStation >= 0) {\n      const step = getCurrentStep();\n      step.expect(action, log);\n      if (action === \"createCube\") {   // \n         targetCage = value;\n      }\n   }\n};\n\n// register for \n_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"onReady\"](init);\n\n\n\n//# sourceURL=webpack:///./js/wings3d_interact.js?");

/***/ }),

/***/ "./js/wings3d_mads.js":
/*!****************************!*\
  !*** ./js/wings3d_mads.js ***!
  \****************************/
/*! exports provided: Madsor, MultiMadsor, DragSelect, GenericEditCommand, MovePositionHandler, MouseMoveAlongAxis, MoveDirectionHandler, MoveBidirectionHandler, MoveAlongNormal, MoveFreePositionHandler, MouseRotateAlongAxis, ToggleCheckbox, ToggleModeCommand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Madsor\", function() { return Madsor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiMadsor\", function() { return MultiMadsor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragSelect\", function() { return DragSelect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenericEditCommand\", function() { return GenericEditCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MovePositionHandler\", function() { return MovePositionHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseMoveAlongAxis\", function() { return MouseMoveAlongAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveDirectionHandler\", function() { return MoveDirectionHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveBidirectionHandler\", function() { return MoveBidirectionHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveAlongNormal\", function() { return MoveAlongNormal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveFreePositionHandler\", function() { return MoveFreePositionHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseRotateAlongAxis\", function() { return MouseRotateAlongAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToggleCheckbox\", function() { return ToggleCheckbox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToggleModeCommand\", function() { return ToggleModeCommand; });\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_boundingvolume */ \"./js/wings3d_boundingvolume.js\");\n/*\n *\n * MADS (Modify, Add, Delete, Select) operation. \n *\n**/\n\n\n\n\n\n\n\n\n\nclass Madsor { // Modify, Add, Delete, Select, (Mads)tor. Model Object.\n   constructor(mode) {\n      this.modeString = mode;\n      if (mode === 'Multi') {\n         return;\n      }\n      mode = mode.toLowerCase();\n      const self = this;\n      // contextMenu\n      this.contextMenu = {menu: document.querySelector(\"#\"+mode+\"-context-menu\")};\n      if (this.contextMenu.menu) {\n         this.contextMenu.menuItems = this.contextMenu.menu.querySelectorAll(\".context-menu__item\");\n      }\n      const axisVec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n      const axisName = ['X', 'Y', 'Z'];\n      // type handler \n      // movement for (x, y, z)\n      for (let axis=0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](mode + 'Move' + axisName[axis], function(ev) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new MouseMoveAlongAxis(self, axis));\n            });\n      }\n      // free Movement.\n      const moveFree = {body: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyMoveFree, face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceMoveFree, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeMoveFree, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexMoveFree};\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](moveFree[mode].name, function(ev) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new MoveFreePositionHandler(self));\n         });\n      // normal Movement.\n      const moveNormal = {face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceMoveNormal, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeMoveNormal, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexMoveNormal};\n      if (moveNormal[mode]) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](moveNormal[mode].name, function(ev) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new MoveAlongNormal(self));\n          });\n      }\n      // scale uniform\n      const scaleUniform = {face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleUniform, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleUniform, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleUniform, body: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleUniform};\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](scaleUniform[mode].name, (_ev) => {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ScaleHandler(this, [1, 1, 1]));\n       });\n      // rotate x, y, z\n      for (let axis = 0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](mode + 'Rotate' + axisName[axis], (ev) => {\n            const vec = [0, 0, 0]; vec[axis] = 1.0;\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new MouseRotateAlongAxis(this, vec));\n          });\n      }\n      // Bevel\n      const bevel = {face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceBevel, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeBevel, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexBevel};\n      if (bevel[mode]) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](bevel[mode].name, (ev)=> {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new BevelHandler(this));\n          });\n      }\n      // extrude\n      const extrude = {face: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceExtrudeX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceExtrudeY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceExtrudeZ],\n                       edge: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeExtrudeX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeExtrudeY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeExtrudeZ],\n                       vertex:  [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexExtrudeX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexExtrudeY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexExtrudeZ],};\n      let extrudeMode = extrude[mode];\n      if (extrudeMode) {\n         // movement for (x, y, z)\n         for (let axis=0; axis < 3; ++axis) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](extrudeMode[axis].name, (ev) => {\n                  _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ExtrudeAlongAxisHandler(this, axis));\n             });\n         }\n      }\n      const extrudeFree = {face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceExtrudeFree, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeExtrudeFree, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexExtrudeFree };\n      if (extrudeFree[mode]) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](extrudeFree[mode].name, (ev) => {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ExtrudeFreeHandler(this));\n          });\n      }\n      const extrudeNormal = {face: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceExtrudeNormal, edge: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeExtrudeNormal, vertex: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexExtrudeNormal};\n      if (extrudeNormal[mode]) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](extrudeNormal[mode].name, (ev) => {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ExtrudeNormalHandler(this));\n          });\n      }\n      // flatten x,y,z\n      const flatten = {face: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceFlattenX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceFlattenY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceFlattenZ],\n                       edge: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeFlattenX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeFlattenY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeFlattenZ],\n                       vertex: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexFlattenX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexFlattenY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexFlattenZ] };\n      let flattenMode = flatten[mode];\n      if (flattenMode) {\n         for (let axis = 0; axis < 3; ++axis) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](flattenMode[axis].name, (_ev) => {\n               const cmd = new GenericEditCommand(this, this.flatten, [axisVec[axis]]);\n               if (cmd.doIt()) {\n                  _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"undoQueue\"](cmd);\n               }\n             });\n         }\n      }\n      // scale axis and radial\n      const radialVec = [[0, 1, 1], [1, 0, 1], [1, 1, 0]];\n      const scaleAxis = {face: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleAxisX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleAxisY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleAxisZ],\n                         edge: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleAxisX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleAxisY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleAxisZ],\n                       vertex: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleAxisX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleAxisY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleAxisZ],\n                         body: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleAxisX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleAxisY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleAxisZ]};\n      const scaleAxisMode = scaleAxis[mode];\n      const scaleRadial = {face: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleRadialX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleRadialY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].faceScaleRadialZ],\n                           edge: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleRadialX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleRadialY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].edgeScaleRadialZ],\n                         vertex: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleRadialX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleRadialY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].vertexScaleRadialZ],\n                           body: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleRadialX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleRadialY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyScaleRadialZ]};\n      const scaleRadialMode = scaleRadial[mode];\n      for (let axis = 0; axis < 3; ++axis) {\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](scaleAxisMode[axis].name, (_ev) => {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ScaleHandler(this, axisVec[axis]));\n          });\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](scaleRadialMode[axis].name, (_ev) => {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseMove\"](new ScaleHandler(this, radialVec[axis]));\n          });\n      }\n      // plane Cut\n      const planeCut = { face: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].facePlaneCutX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].facePlaneCutY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].facePlaneCutZ], \n                         body: [_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyPlaneCutX, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyPlaneCutY, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].bodyPlaneCutZ], };\n      const planeCutMode = planeCut[mode];\n      if (planeCutMode) {\n         for (let axis = 0; axis < 3; ++axis) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_4__[\"bindMenuItem\"](planeCutMode[axis].name, (_ev) =>{\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"attachHandlerMouseSelect\"](new PlaneCutHandler(this, axisVec[axis]));\n             });\n         }\n      }\n   }\n\n   modeName() {\n      return this.modeString;\n   }\n\n   getContextMenu() {\n      if (this.hasSelection()) {\n         return this.contextMenu;\n      } else {\n         return null;\n      }\n   }\n\n   snapshotAll(func, ...args) {\n      const snapshots = [];\n      //for (let preview of View.getWorld()) {\n      for (let preview of this.selectableCage()) {\n         if (preview.hasSelection()) {\n            const snapshot = func.call(preview, ...args);\n            if (snapshot || (snapshot === false)) {\n               snapshots.push( {preview: preview, snapshot: snapshot} );\n            }\n         }\n      }\n      return snapshots;\n   }\n\n   /**\n    * should we make it static?\n    * @param {*} targets \n    * @param {*} func \n    * @param  {...any} args \n    */\n   snapshotTarget(targets, func, ...args) {\n      const snapshots = [];\n      for (let preview of targets) {\n         const snapshot = func.call(preview, ...args);\n         if (snapshot || (snapshot === false)) {\n            snapshots.push( {preview: preview, snapshot: snapshot} );\n         }\n      }\n      return snapshots;\n   }\n\n   doAll(snapshots, func, ...args) {\n      if (snapshots) {\n         for (let obj of snapshots) {\n            func.call(obj.preview, obj.snapshot, ...args);\n         }\n      } else {\n         for (let preview of this.eachCage()) {\n            func.call(preview, undefined, ...args);\n         }\n      }\n   }\n\n   resultAll(func, ...args) {\n      for (let preview of this.selectedCage()) {\n         if (func.call(preview, ...args)) {\n            return true;\n         }\n      }\n      return false;\n   }\n\n   * eachCage() {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         yield cage;\n      }\n   }\n\n   * selectableCage() {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         if (!cage.isLock() && cage.isVisible()) {\n            yield cage;\n         }\n      }\n   }\n\n   * selectedCage() {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         if (!cage.isLock() && cage.isVisible() && cage.hasSelection()) {\n            yield cage;\n         }\n      }\n   }\n\n   * notSelectedCage() {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         if (!cage.isLock() && cage.isVisible() && !cage.hasSelection()) {\n            yield cage;\n         }\n      }\n   }\n\n   // visible but may be lock/unlock\n   * visibleCage() {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         if (cage.isVisible()) {\n            yield cage;\n         }\n      }\n   }\n\n   * visibleWireCage(wireMode) {\n      const world = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"getWorld\"]();\n      for (let cage of world) {\n         if (cage.isVisible() && (cage.isWireMode() === wireMode)) {\n            yield cage;\n         }\n      }\n   }\n\n   hasSelection() {\n      for (let cage of this.selectableCage()) {\n         if (!cage.isLock() && cage.hasSelection()) {\n            return true;\n         }\n      }\n      return false;\n   }\n\n   restoreMoveSelection(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.restoreMoveSelection);\n   }\n\n   // move vertices\n   moveSelection(snapshots, movement) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.moveSelection, movement);\n   }\n\n   restoreSelectionPosition(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.restoreMoveSelection);\n   }\n\n   // scale vertices along axis\n   scaleSelection(snapshots, scale, axis) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.scaleSelection, scale, axis);\n   }\n\n   // rotate vertices\n   rotateSelection(snapshots, quatRotate, center) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.rotateSelection, quatRotate, center);\n   }\n\n   snapshotSelection() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype['snapshotSelection' + this.modeName()]);\n   }\n\n   _doSelection(doName, forceAll=false) {\n      doName = '_select' + this.modeName() + doName;\n      const snapshots = [];\n      for (let cage of this.eachCage()) {    // this is snapshot all\n         if (forceAll || cage.hasSelection()) {\n            snapshots.push( {preview: cage, snapshot: cage[doName]()} );\n         }\n      }\n      if (snapshots.length > 0) {\n         return {undo: this.undoDoSelection, snapshots: snapshots};\n      }\n      return false;  // null? \n   }\n\n   similarSelection() {\n      return this._doSelection('Similar');\n   }\n\n   adjacentSelection() {\n      return this._doSelection('Adjacent');\n   }\n\n   invertSelection() {\n      return this._doSelection('Invert', true);\n   }\n\n   allSelection() {\n      return this._doSelection('All', true);\n   }\n\n   lessSelection() {\n      return this._doSelection('Less');\n   }\n\n   moreSelection() {\n      return this._doSelection('More');\n   }\n\n   resetSelection() {\n      for (let cage of this.selectedCage()) {\n         this._resetSelection(cage);\n      }\n   }\n\n   restoreSelection(selection) {\n      this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.restoreSelection, this); \n   }\n\n   undoDoSelection(snapshots) {\n      this.resetSelection();\n      this.restoreSelection(snapshots);\n   }\n\n   selectObject(objects, input) {\n      if (input.checked) {\n         return this.snapshotTarget(objects, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype['_select' + this.modeName() + 'All']);\n      } else {\n         return this.snapshotTarget(objects, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype['_resetSelect' + this.modeName()]);\n      }\n   }\n\n   undoSelectObject(selection, input) {\n      if (input.checked) {\n         this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype['_resetSelect' + this.modeName()]); // unselected All then\n      }\n      this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.restoreSelection, this); // restore\n   }\n\n   toggleObjectLock(objects, input) {\n      return this.snapshotTarget(objects, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.toggleLock, input.checked);\n   }\n\n   undoToggleObjectLock(selection) {\n      this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.toggleLock);   // restore\n   }\n\n   toggleObjectVisibility(objects, input) {\n      return this.snapshotTarget(objects, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.setVisible, !input.checked); // checked is invisible\n   }\n\n   undoObjectVisibility(selection) {\n      return this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.setVisible);\n   }\n\n   toggleObjectWireMode(objects, checked) {\n      return this.snapshotTarget(objects, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.toggleWireMode, checked);\n   }\n\n   undoToggleObjectWireMode(selection) {\n      return this.doAll(selection, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.toggleWireMode);\n   }\n\n   isVertexSelectable() { return false; }\n   isEdgeSelectable() { return false; }\n   isFaceSelectable() { return false; }\n\n   toggleMulti(_hilite) {}\n\n   // default draw FaceHlite, needs to override by vertex/edge/multi mode.\n   drawExtra(gl, draftBench) {\n      gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_2__[\"solidColor\"]);\n      gl.bindTransform();\n      // draw hilite\n      draftBench.drawHilite(gl);\n      //gl.disableShader();\n   }\n\n   // override by edge only\n   previewShader(gl) {\n      gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_2__[\"solidWireframe\"]);\n   }\n}\n\n\n\n\n\nclass DragSelect {\n   constructor(madsor, cage, current, onOff) {\n      this.madsor = madsor;\n      this.select = new Map; \n      this.select.set(cage, [current]);\n      this.onOff = onOff;        // true = on, false = off.\n   }\n\n //  finish() {\n //     return new EdgeSelectCommand(this.select);\n //  }\n\n   dragSelect(cage, hilite) {\n      var array = this.select.get(cage);\n      if (array === undefined) {\n         array = [];\n         this.select.set(cage, array);\n      }\n      this.madsor.dragSelect(cage, hilite, array, this.onOff);\n   }\n}\n\n\nclass ToggleCheckbox extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"EditCommand\"] {\n   constructor(input) {\n      super();\n      this.input = input;\n   }\n\n   doIt() {\n      this.input.checked = !this.input.checked;\n   }\n\n   undo() {\n      this.input.checked = !this.input.checked;\n   }\n}\n\n\nclass ToggleModeCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"EditCommand\"] {\n   constructor(doFn, undoFn, snapshots) {\n      super();\n      this.snapshots = snapshots;\n      this.redoToggle = doFn;\n      this.undoToggle = undoFn;\n   }\n\n   doIt() {\n      this.redoToggle();\n   }\n\n   undo() {\n      // toggle back\n      this.undoToggle(this.snapshots);\n   }\n}\n\n\n\nclass MovePositionHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"MouseMoveHandler\"] {\n   constructor(madsor, snapshots, movement) {\n      super();\n      this.madsor = madsor;\n      this.snapshots = snapshots;\n      this.movement = movement;\n   }\n\n   isDoable() {\n      return (this.snapshots.length > 0);\n   }\n\n   doIt() {\n      if (this.snapshots.length > 0) {\n         //if (this.movement !== 0) {\n            this._transformSelection(this.movement);\n         //}\n         return true;\n      }\n      return false;\n   }\n\n   undo() {\n      this.madsor.restoreSelectionPosition(this.snapshots);\n   }\n\n   handleMouseMove(ev, cameraView) {\n      this._transformSelection(this._updateMovement(ev, cameraView));\n   }\n\n   _transformSelection(transform) {\n      this.madsor.moveSelection(this.snapshots, transform);\n   }\n}\n\n\nclass MoveVertexHandler extends MovePositionHandler { // temp refactoring class\n   constructor(madsor, movement, cmd) {\n      super(madsor, null, movement);\n      this.cmd = cmd;\n   }\n\n   doIt() {\n      if (this.cmd) {\n         this.cmd.doIt();\n         this.snapshots = this.cmd.snapshotPosition();\n      } else {\n         this.snapshots = this.snapshotPosition();\n      }\n      super.doIt();\n      return true;\n   }\n\n   undo() {\n      if (this.cmd) {\n         this.cmd.undo();   // no need to restore to be deleted position\n      } else {\n         super.undo();\n      }\n\n   }\n}\n\n\n// movement handler.\nclass MouseMoveAlongAxis extends MovePositionHandler {\n   constructor(madsor, axis) {   // 0 = x axis, 1 = y axis, 2 = z axis.\n      super(madsor, madsor.snapshotPosition(), [0.0, 0.0, 0.0]);\n      this.axis = axis;\n   }\n\n   _updateMovement(ev) {\n      let move = this._calibrateMovement(ev.movementX);\n      let movement = [0.0, 0.0, 0.0];\n      movement[this.axis] = move;\n      this.movement[this.axis] += move;\n      return movement;\n   }\n}\n\nclass MoveDirectionHandler extends MoveVertexHandler {\n   constructor(madsor, cmd, noNegative=false) {\n      super(madsor, 0, cmd);\n      this.noNegative = noNegative;\n   }\n   \n   _updateMovement(ev) {\n      let move = this._calibrateMovement(ev.movementX);\n      this.movement += move;\n      if (this.noNegative && (this.movement < 0)) {\n         move -= this.movement;\n         this.movement = 0.0;\n      }\n      return move;\n   }\n}\n\n\nclass MoveBidirectionHandler extends MoveVertexHandler {\n   constructor(madsor, cmd) {\n      super(madsor, 0, cmd);\n   }\n\n   // override original handler. this\n   handleMouseMove(ev, _cameraView) {\n      let move = this._calibrateMovement(ev.movementX);\n      if (move > 0) {\n         if ((this.movement < 0) && ((this.movement+move) >=0)) { // negativeDir done\n            this.madsor.moveSelection(this.snapshots, -this.movement);\n            move += this.movement;\n            this.movement = 0;\n            this.madsor.doAll(this.snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.positiveDirection);\n         }\n      } else {\n         if ((this.movement >= 0) && ((this.movement+move) < 0)) {\n            this.madsor.moveSelection(this.snapshots, -this.movement);\n            move += this.movement;\n            this.movement = 0;\n            this.madsor.doAll(this.snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_1__[\"PreviewCage\"].prototype.negativeDirection);\n         }\n      }\n      this.movement += move;\n      this.madsor.moveSelection(this.snapshots, move);\n   }\n}\n\nclass MoveAlongNormal extends MovePositionHandler {\n   constructor(madsor, noNegative = false, snapshots) {\n      if (!snapshots) {\n         snapshots = madsor.snapshotPositionAndNormal();\n      }\n      super(madsor, snapshots, 0.0);\n      this.noNegative = noNegative;\n   }\n\n   _updateMovement(ev) {\n      let move = this._calibrateMovement(ev.movementX);\n      this.movement += move;\n      if (this.noNegative && (this.movement < 0)) {\n         move -= this.movement;\n         this.movement = 0.0;\n      }\n      return move;\n   }\n}\n\n\nclass MoveFreePositionHandler extends MovePositionHandler {\n   constructor(madsor) {\n      super(madsor, madsor.snapshotPosition(), [0.0, 0.0, 0.0]);\n   }\n\n   _updateMovement(ev, cameraView) {\n      let x = this._calibrateMovement(ev.movementX);\n      let y = this._calibrateMovement(-ev.movementY);\n      var cam = cameraView.inverseCameraVectors();\n      // move parallel to camera.\n      var movement = [cam.x[0]*x + cam.y[0]*y, cam.x[1]*x + cam.y[1]*y, cam.x[2]*x + cam.y[2]*y];\n      vec3.add(this.movement, this.movement, movement);\n      return movement;\n   }\n}\n\n\nclass ScaleHandler extends MovePositionHandler {\n   constructor(madsor, axis) {\n      const snapshots = madsor.snapshotTransformGroup();\n      super(madsor, snapshots, 1.0);\n      this.axis = axis;\n   }\n\n   _transformSelection(scale) {\n      this.madsor.scaleSelection(this.snapshots, scale, this.axis);\n   }\n\n   _updateMovement(ev, _camera) {\n      let scale = this._xPercentMovement(ev);   // return (100% to -100%)\n      if (scale < 0) {\n         scale = 1.0 + Math.abs(scale);\n      } else {\n         scale = 1.0 / (1.0 + scale);\n      }\n      this.movement *= scale;\n      return scale;\n   }\n}\n\n\n// movement handler.\nclass MouseRotateAlongAxis extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"EditCommand\"] {\n   constructor(madsor, axis, center) {   // axis directly\n      super();\n      this.madsor = madsor;\n      this.snapshots = madsor.snapshotTransformGroup();\n      this.movement = 0.0;             // cumulative movement.\n      this.axisVec3 = vec3.clone(axis);\n      this.center = center;\n   }\n\n   handleMouseMove(ev) {\n      const move = this._xPercentMovement(ev)*5;\n      const quatRotate = quat.create();\n      quat.setAxisAngle(quatRotate, this.axisVec3, move);\n      this.madsor.rotateSelection(this.snapshots, quatRotate, this.center);\n      this.movement += move;\n   }\n\n   doIt() {\n      const quatRotate = quat.create();\n      quat.setAxisAngle(quatRotate, this.axisVec3, this.movement);\n      this.madsor.rotateSelection(this.snapshots, quatRotate, this.center);\n   }\n\n   undo() {\n      this.madsor.restoreSelectionPosition(this.snapshots);\n   }\n}\n\n\nclass BevelHandler extends MovePositionHandler {\n   constructor(madsor) {\n      const selection = madsor.snapshotSelection();   // have to get selection first\n      super(madsor, madsor.bevel(), 0.0);\n      this.selection = selection;\n      // get limit\n      this.vertexLimit = Number.MAX_SAFE_INTEGER;\n      for (let snapshot of this.snapshots) {\n         this.vertexLimit = Math.min(this.vertexLimit, snapshot.vertexLimit);\n      }\n   }\n\n   _updateMovement(ev) {\n      let move = this._calibrateMovement(ev.movementX);\n      if ((this.movement+move) > this.vertexLimit) {\n         move = this.vertexLimit - this.movement;\n      } else if ((this.movement+move) < 0) {\n         move = 0 - this.movement;\n      }\n      this.movement += move;\n      return move;\n   }\n\n   doIt() {\n      this.snapshots = this.madsor.bevel();   // should test for current snapshots and prev snapshots? should not change\n      // no needs to recompute limit, wont change, \n      // move \n      super.doIt();  // = this.madsor.moveSelection(this.snapshots, this.movement);\n   }\n\n   undo() {\n      this.madsor.undoBevel(this.snapshots, this.selection);\n      //this.snapshots = undefined;\n   }\n}\n\n// extrude\nclass ExtrudeHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"MoveableCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n      this.contourEdges = madsor.extrude();\n   }\n\n   doIt() {\n      this.contourEdges = this.madsor.extrude(this.contourEdges);\n      super.doIt();     // = this.madsor.moveSelection(this.snapshots, this.movement);\n   }\n\n   undo() {\n      super.undo(); //this.madsor.restoreSelectionPosition(this.snapshots);\n      this.madsor.undoExtrude(this.contourEdges);\n   }\n}\n\nclass ExtrudeAlongAxisHandler extends ExtrudeHandler {\n   constructor(madsor, axis) { \n      super(madsor);\n      this.moveHandler = new MouseMoveAlongAxis(madsor, axis); // this should comes earlier\n   }\n}\n\n\nclass ExtrudeFreeHandler extends ExtrudeHandler {\n   constructor(madsor) {\n      super(madsor);\n      this.moveHandler = new MoveFreePositionHandler(madsor);\n   }\n}\n\nclass ExtrudeNormalHandler extends ExtrudeHandler {\n   constructor(madsor) {\n      super(madsor);\n      this.moveHandler = new MoveAlongNormal(madsor);\n   }\n}\n// end of extrude\n\nclass PlaneCutHandler extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"EditSelectHandler\"] {\n   constructor(madsor, planeNorm) {\n      super(true, true, true, planeNorm);\n      this.madsor = madsor;\n      this.center = vec3.create();\n   }\n\n   hilite(hilite, _currentCage) {\n      if (hilite.plane) {\n         this.plane = new _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_6__[\"Plane\"](this.planeNormal, hilite.plane.center);\n         if (this.madsor.planeCuttable(this.plane)) {\n            hilite.plane.hilite = true;\n            return true;\n         }\n         hilite.plane.hilite = false;\n         delete this.plane;\n      }\n      return true;   // always true, we want user to see selection.\n   }\n   \n   select(_hilite) {\n      if (this.plane) { // doIt   \n         return this.doIt();\n      }\n      return false;\n   }\n\n   doIt() {\n      if (this.plane) {\n         this.cut = this.madsor.planeCut(this.plane);\n         if (this.cut.length > 0) {\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"restoreVertexMode\"](this.cut);\n            this.vertexConnect = _wings3d_view__WEBPACK_IMPORTED_MODULE_3__[\"currentMode\"]().connectVertex();   // assurely it vertexMode\n            return this.vertexConnect.doIt();\n         }\n      }\n      return false;\n   }\n\n   undo() {\n      if (this.vertexConnect) {\n         this.vertexConnect.undo();\n         delete this.vertexConnect; // we are in vertex mode\n         this.madsor.undoPlaneCut(this.cut);\n      }\n   }\n}\n\n\nclass GenericEditCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_0__[\"EditCommand\"] {\n   constructor(madsor, doCmd, doParams, undoCmd, undoParams) {\n      super();\n      this.madsor = madsor;\n      this.doCmd = doCmd;\n      this.doParams = doParams;\n      this.undoCmd = undoCmd; \n      this.undoParams = undoParams;\n   }\n\n   doIt(_currentMadsor) {\n      this.snapshots = this.doCmd.call(this.madsor, ...(this.doParams? this.doParams : []));\n      return (this.snapshots.length > 0);\n   }\n\n   undo(_currentMadsor) {\n      if (this.undoCmd) {\n         this.undoCmd.call(this.madsor, this.snapshots, ...(this.undoParams? this.undoParams : []) );\n      } else {\n         this.madsor.restoreSelectionPosition(this.snapshots);\n      }\n   }\n\n   snapshotPosition() {\n      return this.snapshots;\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_mads.js?");

/***/ }),

/***/ "./js/wings3d_model.js":
/*!*****************************!*\
  !*** ./js/wings3d_model.js ***!
  \*****************************/
/*! exports provided: PreviewCage, CreatePreviewCageCommand, PreviewGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreviewCage\", function() { return PreviewCage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreatePreviewCageCommand\", function() { return CreatePreviewCageCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreviewGroup\", function() { return PreviewGroup; });\n/* harmony import */ var _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_boundingvolume */ \"./js/wings3d_boundingvolume.js\");\n/* harmony import */ var _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_wingededge */ \"./js/wings3d_wingededge.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/* harmony import */ var _wings3d_i18n__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_i18n */ \"./js/wings3d_i18n.js\");\n/*\n*  hold onto a WingedEdgeTopology. adds index, texture, etc....\n*  bounding box, picking.\n* \n*  previewCage. Internal representation rewrote many times.\n*  Finally decided to trade space for ease of implementation and \n*  no worst case non linear runtimes.\n* \n*  Add PreviewGroup. simple grouping without transform.\n*/\n\n\n\n\n\n\n\n\n\n\n/**\n * PreviewGroup constructor.\n * \n */\nconst PreviewGroup = function() {\n   this.group = [];\n   this.parent = null;\n   this.uuid = PreviewCage.get_uuidv4();\n   this.guiStatus = {};\n   this.status = {locked: false, visible: true, wireMode: false};\n\n   // default to no name\n   let _name = \"\";\n   Object.defineProperty(this,\"name\",{\n      get: function() { return _name; },\n      set: function(value) {  \n         if (value === '') {  // cannot assign empty string?\n            return;\n         }\n         _name = value; \n         if (this.guiStatus.textNode) {   // treeView's representation.\n            if (this.guiStatus.textNode.textContent !== value) {\n               this.guiStatus.textNode.textContent = value;\n            }\n         } \n       }\n    });\n   // how about bvh?\n\n};\n\n\n// prototype method.\nPreviewGroup.prototype.insert = function(obj) {\n   if (obj.parent) {\n      obj.parent.remove(obj);\n   }\n   this.group.push( obj );\n   obj.parent = this;\n   //this.guiStatus.count.textContent = this.numberOfCage();\n};\n\n\nPreviewGroup.prototype.remove = function(obj) {\n   if (obj.parent === this) {\n      const index = this.group.indexOf(obj);\n      if (index >= 0) {\n         this.group.splice(index, 1);\n         obj.parent = null;\n         //this.guiStatus.count.textContent = this.numberOfCage();\n         return obj;\n      }\n   }\n   // console log\n   console.log('remove() integrity error');\n   return null;\n};\n\nfunction countCage(acc, preview) {\n   return acc+preview.numberOfCage();\n};\nPreviewGroup.prototype.numberOfCage = function() {\n   let count = this.group.reduce(countCage, 0);\n   if (this.guiStatus.count) {\n      this.guiStatus.count.textContent = count;\n   }\n   return count;\n};\n\nPreviewGroup.prototype.getCage = function* () {\n   for (let cage of this.group) {\n      for (let subCage of cage.getCage()) {\n         yield subCage;\n      }\n   }\n};\n\n\nclass MeshAllocatorProxy { // we could use Proxy, but ....\n   constructor(preview) {\n      this.preview = preview;\n   }\n\n   allocVertex(...args) { return this.preview.bench.allocVertex(...args); }\n\n   allocEdge(...args) { return this.preview.bench.allocEdge(...args); }\n\n   allocPolygon(...args) {\n      const face = this.preview.bench.allocPolygon(...args);\n      if (this.preview.bench.boundingSpheres.length < this.preview.bench.faces.length) {   // now create sphere and insert to preview's bvh\n         this.preview.bench.boundingSpheres.push( _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__[\"BoundingSphere\"].allocate(face) );\n      }\n      this.preview.insertFace(face);\n      return face;\n   }\n\n   freeAll(polygons, wEdges, vertices) { this.preview.bench.freeAll(polygons, wEdges, vertices); }\n\n   freeVertex(vertex) { \n      this.preview.bench.alterVertex(); \n      this.preview.bench.freeVertex(vertex); \n   }\n\n   freeHEdge(hEdge) { this.preview.bench.freeHEdge(hEdge); }\n\n   freePolygon(polygon) {\n      this.preview.removeFace(polygon);\n      this.preview.bench.freePolygon(polygon);\n   }\n\n   getVertices(index) { return this.preview.bench.getVertices(index); }\n\n   clearAffected() { this.preview.bench.clearAffected(); }\n\n   addAffectedEdgeAndFace(...args) { this.preview.bench.addAffectedEdgeAndFace(...args); }\n   addAffectedWEdge(wEdge) {this.preview.bench.addAffectedWEdge(wEdge);}\n   addAffectedFace(polygon) {this.preview.bench.addAffectedFace(polygon);}\n   addAffectedVertex(vertex) {this.preview.bench.addAffectedVertex(vertex);}\n}\n\n\n/**\n * Model constructor.\n * \n * @param {DraftBench} bench - drawing workbench. \n */\nconst PreviewCage = function(bench) {\n   this.parent = null;\n   this.uuid = PreviewCage.get_uuidv4();\n   this.geometry = new _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"](new MeshAllocatorProxy(this));\n   this.bench = bench;\n   this.guiStatus = {};\n   this.status = {locked: false, visible: true, wireMode: false};\n\n   // selecte(Vertex,Edge,Face)here\n   this.selectedSet = new Set;\n   // default no name\n   let _name = \"\";\n   Object.defineProperty(this,\"name\",{\n      get: function() { return _name; },\n      set: function(value) {  \n         if (value === '') {  // cannot assign empty string?\n            return;\n         }\n         _name = value; \n         if (this.guiStatus.textNode) {   // treeView's representation.\n            if (this.guiStatus.textNode.textContent !== value) {\n               this.guiStatus.textNode.textContent = value;\n            }\n         }\n       }\n    });\n   // bvh\n   this.bvh = {root: null, queue: new Set};       // queue is for lazy evaluation.1\n};\n\n\n/**\n * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n * generate unique id using crypto functions to avoid collision.\n */\nPreviewCage.get_uuidv4 = function() {\n   return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n     (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n   )\n };\n\n PreviewCage.prototype.numberOfCage = function() {\n    return 1;\n }\n\n PreviewCage.prototype.getCage = function* () {\n    yield this;\n }\n\n PreviewCage.prototype.removeFromParent = function() {\n   if (this.parent) {\n      return this.parent.remove(this);\n   }\n   return false;\n };\n\n// act as destructor\nPreviewCage.prototype.freeBuffer = function() {\n   if (this.bvh.root) {\n      this.bvh.root.free();\n      this.bvh.root = null;\n   }\n   this.geometry.free();\n};\n\n/**\n * update gui status.\n */\nPreviewCage.prototype.updateStatus = function() {\n   if (!this.isVisible() || (this.selectedSet.size === 0)) {\n      if (this.guiStatus.select.checked) {\n         this.guiStatus.select.checked = false;\n      }\n   } else {\n      if (!this.guiStatus.select.checked) {\n         this.guiStatus.select.checked = true;\n      }\n   }\n};\n\n//-- bvh -----\n\nPreviewCage.prototype.initBVH = function() {\n   const faceSet = this.geometry.faces;\n\n   let max, min;\n   const center = vec3.create();\n   // first compute midPoint.\n   const spheres = [];\n   for (let face of faceSet) {\n      const sphere = this.bench.boundingSpheres[face.index];\n      spheres.push(sphere);\n      vec3.add(center, center, sphere.center);\n      if (!max) {\n         max = vec3.fromValues(sphere.center[0]+sphere.radius, sphere.center[1]+sphere.radius, sphere.center[2]+sphere.radius);\n         min = vec3.fromValues(sphere.center[0]-sphere.radius, sphere.center[1]-sphere.radius, sphere.center[2]-sphere.radius);\n      } else {\n         for (let axis = 0; axis < 3; ++axis) {\n            if (max[axis] < (sphere.center[axis]+sphere.radius)) {\n               max[axis] = sphere.center[axis]+sphere.radius;\n            } else if (min[axis] > (sphere.center[axis]-sphere.radius)) {\n               min[axis] = sphere.center[axis] - sphere.radius;\n            }\n         }\n      }\n   }\n   vec3.scale(center, center, 1/spheres.length);\n   // mid point of a bunch of spheres will likely split more evently.\n   const bound = {center: center, \n                  halfSize: vec3.fromValues(Math.max(max[0]-center[0], center[0]-min[0]), \n                                            Math.max(max[1]-center[1], center[1]-min[1]), \n                                            Math.max(max[2]-center[2], center[2]-min[2]) )};\n   if (this.bvh.root) {\n      this.bvh.root.free();\n   }\n   this.bvh.queue.clear();\n   this.bvh.root = new _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__[\"LooseOctree\"](this, bound, 0);\n   // now insert every spheres onto the root\n   for (let sphere of spheres) {\n      this.bvh.root.getBound(bound);\n      this.bvh.root.insert(sphere, bound);\n   }\n   //this.bvh.root.check(new Set);\n}\n\nPreviewCage.prototype.insertFace = function(face) {\n   const sphere = this.bench.boundingSpheres[face.index];\n   if (!sphere.octree) {\n      this.bvh.queue.add(sphere);\n   } else {\n      console.log(\"octree insert duplicated\");\n   }\n   //this.bvh.root.insert(sphere);\n}\n\nPreviewCage.prototype.moveSphere = function(sphere) { // lazy evaluation.\n   this.bvh.queue.add(sphere);\n}\n\nPreviewCage.prototype.removeFace = function(face) { \n   const sphere = this.bench.boundingSpheres[face.index];\n   if (sphere.octree) { // octree should exist, or \n      sphere.octree._remove(sphere);                     \n   } else {\n      this.bvh.queue.delete(sphere);\n   }\n}\n\n// check if we needs to resize, if yes then might as well rebuild.\nPreviewCage.prototype.updateBVH = function() {\n   // check if any sphere is outside of original bound.\n   for (let sphere of this.bvh.queue) {\n      if (!this.bvh.root.isInside(sphere)) {\n         this.bvh.queue.clear();\n         this.initBVH();\n         return;\n      }\n   }\n   \n   // now insert the queue moved polygons\n   const bound = {center: vec3.create(), halfSize: vec3.create()};\n   for (let sphere of this.bvh.queue) {\n      this.bvh.root.getBound(bound);\n      this.bvh.root.insert(sphere, bound);\n   }\n   this.bvh.root.check(new Set);\n   this.bvh.queue.clear();\n}\n\n//-- end of bvh\n\nPreviewCage.prototype.rayPick = function(ray) {\n   if (this.bvh.root === null) {\n      this.initBVH();\n   } else {\n      this.updateBVH();\n   }\n   // return the closest face (triangle) that intersect ray.\n   // check for triangle intersection, select the hit Face, hit Edge(closest), and hit Vertex (closest).\n   var hitEdge = null;\n   var center;\n   var hitT = Number.POSITIVE_INFINITY;   // z_far is the furthest possible intersection\n\n   for (let sphere of this.bvh.root.intersectExtent(ray)) {\n      sphere.polygon.eachEdge( function(edge) {\n         // now check the triangle is ok?\n         var t = _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"intersectTriangle\"](ray, [sphere.center, edge.origin.vertex, edge.destination().vertex]);\n         if ((t != 0.0) && (t < hitT)) {\n            // intersection, check for smallest t, closest intersection\n            hitT = t;\n            hitEdge = edge;\n            center = sphere.center;\n         }\n      });\n   }\n   // yes, we have an hit\n   if (hitEdge) {\n      return {t: hitT, model: this, center: center, edge: hitEdge};\n      // p = o + td; intersection point.\n   } else {\n      return null;\n   }\n};\n\n\nPreviewCage.prototype.getSelectedSorted = function() {\n   let selectedSort = Array.from(this.selectedSet);\n   selectedSort.sort((a, b) => {return a.index - b.index;});  // iterated selectedFaces in index order.\n   return selectedSort;\n}\n\n\nPreviewCage.duplicate = function(originalCage) {\n   // copy geometry.\n   const indexMap = new Map;\n   const previewCage = new PreviewCage(originalCage.bench);\n   const geometry = previewCage.geometry;\n   for (let vertex of originalCage.geometry.vertices) {\n      const copy = geometry.addVertex(vertex.vertex);\n      indexMap.set(vertex.index, copy.index);\n   }\n   for (let polygon of originalCage.geometry.faces) {\n      let index = [];\n      polygon.eachVertex( function(vertex) {\n         index.push( indexMap.get(vertex.index) );\n      });\n      geometry.addPolygon(index);\n   }\n   //geometry.clearAffected();\n   previewCage._updatePreviewAll();\n   // new PreviewCage, and new name\n   previewCage.name = originalCage.name + \"_copy1\";\n\n   return previewCage;\n};\n\n\nPreviewCage.prototype.merge = function(mergeSelection) {\n   // copy geometry.\n   this.geometry.merge(function* (){for (let cage of mergeSelection) {yield cage.geometry;}});\n   // copy selection\n   this.selectedSet = new Set(function* (){for (let cage of mergeSelection) {yield* cage.selectedSet;}}());\n   // clear out all ?\n/*   for (let cage of mergeSelection) {\n      cage.geometry.faces = new Set;\n      cage.geometry.vertices = new Set;\n      cage.geometry.edges = new Set;\n      cage.selectedSet = new Set;\n   } */\n};\n\nPreviewCage.prototype.separate = function() {\n   const separatePreview = [];\n   const separateGeometry = this.geometry.separateOut();\n   let sep = 0;\n   for (let geometry of separateGeometry) {\n      const cage = new PreviewCage(this.bench);\n      cage.geometry = geometry;     // copy back\n      if (sep > 0) {\n         cage.name = this.name + \"_sep\" + sep.toString();\n      } else {\n         cage.name = this.name;\n      }\n      sep++;\n      separatePreview.push(cage);\n   }\n   return separatePreview;    // snapshot.\n};\n\n\nPreviewCage.prototype.detachFace = function(detachFaces, number) {\n   const detach = this.geometry.detachFace(detachFaces);\n   const separate = new PreviewCage(this.bench);   // should only happened once for each partition.\n   separate.geometry.faces = detachFaces;\n   separate.geometry.edges = detach.edges;\n   separate.geometry.vertices = detach.vertices;\n   separate.name = this.name + \"_cut\" + number.toString();\n\n   return separate;\n};\n\n\nPreviewCage.prototype.setVisible = function(on) {\n   if (on) {\n      if (!this.status.visible) {\n         this.status.visible = true;\n         this.bench.alterPreview();\n         return (!on);\n      }\n   } else {\n      if (this.status.visible) {\n         this.status.visible = false;\n         this.bench.alterPreview();\n         return (!on);\n      }\n   }\n   return null;\n};\n\n\n/**\n * lock/unlock Preview to further operation.\n * @param {bool} toggle - lock/ unlock\n */\nPreviewCage.prototype.toggleLock = function(toggle) {\n   if (toggle) {\n      if (!this.status.locked) {\n         this.status.locked = true;\n         return !toggle;\n      }\n   } else {\n      if (this.status.locked) {\n         this.status.locked = false;\n         return !toggle;\n      }\n   }\n   return null;\n};\n\n\n/**\n * \n */\nPreviewCage.prototype.toggleWireMode = function(on) {\n   if (on) {\n      if (!this.status.wireMode) {\n         this.status.wireMode = true;\n         this.bench.alterPreview();\n         return (!on);\n      }\n   } else {\n      if (this.status.wireMode) {\n         this.status.wireMode = false;\n         this.bench.alterPreview();\n         return (!on);\n      }\n   }\n   return null;\n};\n\n\nPreviewCage.prototype.isLock = function() {\n   return this.status.locked;\n}\n\nPreviewCage.prototype.isVisible = function() {\n   return this.status.visible;\n}\n\nPreviewCage.prototype.isWireMode = function() {\n   return this.status.wireMode;\n}\n\n\nPreviewCage.prototype._getGeometrySize = function() {\n   return { face: this.geometry.faces.size,\n            edge: this.geometry.edges.size,\n            vertex: this.geometry.vertices.size\n          };\n};\n\n\nPreviewCage.prototype._updatePreviewAll = function() {\n   this.bench.updatePreview();\n};\n\n\n// body selection.\nPreviewCage.prototype.changeFromBodyToFaceSelect = function() {\n   // do nothing, already selected or deselected.\n   return this.snapshotSelectionBody();\n};\n\nPreviewCage.prototype.changeFromBodyToEdgeSelect = function() {\n   const snapshot = this.snapshotSelectionBody();\n\n   if (this.hasSelection()) {\n      this._resetSelectBody();\n      // select all edge\n      for (let wingedEdge of this.geometry.edges) {\n         this.selectedSet.add(wingedEdge);\n         this.bench.setEdgeColor(wingedEdge, true);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromBodyToVertexSelect = function() {\n   const snapshot = this.snapshotSelectionBody();\n\n   if (this.hasSelection()) {\n      this._resetSelectBody();\n      // select all vertex\n      for (let vertex of this.geometry.vertices) {\n         this.selectedSet.add(vertex);\n         this.setVertexColor(vertex, 0.25);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromBodyToMultiSelect = function() {\n   const snapshot = this.snapshotSelectionBody();\n   if (this.hasSelection()) {\n      this._resetSelectBody();\n   }\n\n   return snapshot;\n}\n\n\n\n// hack for calling restoerXXXSelection. double dispatch?\nPreviewCage.prototype.restoreSelection = function(snapshot, madsor) {\n   madsor._restoreSelection(this, snapshot);\n}\n\nPreviewCage.prototype.restoreFaceSelection = function(snapshot) {\n   for (let polygon of snapshot.selectedFaces) {\n      this.selectFace(polygon);\n   }\n};\n\nPreviewCage.prototype.restoreEdgeSelection = function(snapshot) {\n   for (let wingedEdge of snapshot.wingedEdges) {\n      this.selectEdge(wingedEdge.left);\n   }\n};\n\nPreviewCage.prototype.restoreVertexSelection = function(snapshot) {\n   for (let vertex of snapshot.vertices) {\n      this.selectVertex(vertex);\n   }\n};\n\nPreviewCage.prototype.restoreBodySelection = function(snapshot) {\n   if (snapshot.body.size > 0) {\n      this.selectBody();\n   }\n};\n\nPreviewCage.prototype.restoreFromBodyToFaceSelect = function(snapshot) {\n   if (snapshot) {\n      this._resetSelectBody();\n      this.restoreFaceSelection(snapshot);\n   } else {\n      this.changeFromBodyToFaceSelect();\n   }\n};\n\nPreviewCage.prototype.restoreFromBodyToEdgeSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectBody();\n      this.restoreEdgeSelection(snapshot);\n   } else {\n      this.changeFromBodyToEdgeSelect();  // choose compute over storage, use the same code as going forward.\n   }\n};\n\nPreviewCage.prototype.restoreFromBodyToVertexSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectBody();\n      // and selected using the snapshots.\n      this.restoreVertexSelection(snapshot);\n   } else {\n      this.changeFromBodyToVertexSelect();  // compute vs storage. currently lean toward compute.\n   }\n};\n\nPreviewCage.prototype.restoreFromBodyToMultiSelect = function(_snapshot) {\n   this.changeFromBodyToMutliSelect();\n};\n\nPreviewCage.prototype._resetSelectBody = function() {\n   const oldSet = this.snapshotSelectionBody();\n   this.selectedSet = new Set();\n   this.bench.resetBody(oldSet.body);\n   return oldSet;\n};\n\nPreviewCage.prototype._selectBodyLess = function() {\n   const snapshot = this.snapshotSelectionBody();\n   if (this.hasSelection()) {\n      this.selectBody();\n   }\n   return snapshot;\n}\n\nPreviewCage.prototype._selectBodyAll = function() {\n   const snapshot = this.snapshotSelectionBody();\n   if (!this.hasSelection()) {\n      this.selectBody();\n   }\n   return snapshot;\n}\n\nPreviewCage.prototype._selectBodyInvert = function() {\n   const snapshot = this.snapshotSelectionBody();\n   this.selectBody();\n   return snapshot;\n}\n\nPreviewCage.prototype.selectBody = function() {\n   //let faceColor;\n   // we change interior color to show the selection\n   if (this.hasSelection()) {\n      this.bench.selectGroup(this.selectedSet, false);\n      this.selectedSet = new Set;\n         //faceColor = [0.0, 1.0, 0.0];   // hilite and unselected         \n         //faceColor = [0.5, 0.5, 0.5];   // unselected\n   } else {\n      this.selectedSet = new Set(this.geometry.faces);\n      this.bench.selectGroup(this.selectedSet, true);\n         //faceColor = [1.0, 1.0, 0.0];   // selected and hilite\n         //faceColor = [1.0, 0.0, 0.0];   // selected.\n      geometryStatus(Object(_wings3d_i18n__WEBPACK_IMPORTED_MODULE_6__[\"i18n\"])(\"body_status\", {name: this.name, polygonSize: this.geometry.faces.size, edgeSize: this.geometry.edges.size, vertexSize: this.geometry.vertices.size}));\n   }\n   return this.hasSelection();\n};\n\nPreviewCage.prototype.hiliteBody = function(hilite) {\n   this.bench.hiliteBody(this.geometry.faces, hilite); \n}\n\nPreviewCage.prototype.hasSelection = function() {\n   return (this.selectedSet.size > 0);\n};\n\nPreviewCage.prototype.selectionSize = function() {\n   return this.selectedSet.size;\n}\n\nPreviewCage.prototype.snapshotSelection = function() {\n   return new Set(this.selectedSet);\n};\n\nPreviewCage.prototype.snapshotSelectionFace = function() {\n   return {selectedFaces: new Set(this.selectedSet)};\n}\n\nPreviewCage.prototype.snapshotSelectionEdge = function() {\n   return {wingedEdges: new Set(this.selectedSet)};\n}\n\nPreviewCage.prototype.snapshotSelectionVertex = function() {\n   return {vertices: new Set(this.selectedSet)};\n}\n\nPreviewCage.prototype.snapshotSelectionBody = function() {\n   return {body: new Set(this.selectedSet)};\n}\n\nPreviewCage.prototype.setVertexColor = function(vertex, color) {\n   // selected color\n   this.bench.setVertexColor(vertex, color);\n};\n\nPreviewCage.prototype.dragSelectVertex = function(vertex, onOff) {\n   if (this.selectedSet.has(vertex)) {\n      if (onOff === false) {\n         this.selectedSet.delete(vertex);\n         this.setVertexColor(vertex, -0.25);\n         return true;\n      }\n   } else {\n      if (onOff === true) {\n         this.selectedSet.add(vertex);\n         this.setVertexColor(vertex, 0.25);\n         geometryStatus(\"select vertex: \" + vertex.index);\n         return true;\n      }\n   }\n   return false;\n};\n\nPreviewCage.prototype.selectVertex = function(vertex) {\n   var onOff;\n   var color;\n   if (this.selectedSet.has(vertex)) {\n      this.selectedSet.delete(vertex);\n      color = -0.25;\n      onOff = false;\n   } else {\n      this.selectedSet.add(vertex);\n      color = 0.25;\n      onOff = true;\n      geometryStatus(\"select vertex: \" + vertex.index);\n   }\n   // selected color\n   this.setVertexColor(vertex, color);\n   return onOff;\n};\n\n\nPreviewCage.prototype._resetSelectVertex = function() {\n   var snapshot = this.snapshotSelectionVertex();\n   this.selectedSet = new Set;\n   // zeroout the edge seleciton.\n   this.bench.resetSelectVertex();\n   return snapshot;\n};\n\nPreviewCage.prototype._selectVertexMore = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   const self = this;\n   for (let vertex of snapshot.vertices) {\n      vertex.eachInEdge( function(inEdge) {\n         if (!self.selectedSet.has(inEdge.origin)) {\n            self.selectVertex(inEdge.origin);\n         }\n      });\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectVertexLess = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   for (let vertex of snapshot.vertices) {\n      for (let ringV of vertex.oneRing()) {\n         if (!snapshot.vertices.has(ringV)) {\n            this.selectVertex(vertex);\n            break;\n         }\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectVertexAll = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   for (let vertex of this.geometry.vertices) {\n      if (vertex.isLive() && !snapshot.vertices.has(vertex)) {\n         this.selectVertex(vertex);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectVertexInvert = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   for (let vertex of this.geometry.vertices) {\n      if (vertex.isLive()) {\n         this.selectVertex(vertex);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectVertexAdjacent = function() {\n   return this._selectVertexMore();\n};\n\nPreviewCage.prototype._selectVertexSimilar = function() {\n   const snapshot = this.snapshotSelectionVertex();\n   const similarVertex = new SimilarVertex(snapshot.vertices);\n\n   for (let vertex of this.geometry.vertices) {\n      if (vertex.isLive() && !snapshot.vertices.has(vertex) && similarVertex.find(vertex)) {\n         this.selectVertex(vertex);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromVertexToFaceSelect = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   var self = this;\n   var oldSelected = this._resetSelectVertex();\n   //\n   for (let vertex of oldSelected.vertices) { \n      // select all face that is connected to the vertex.\n      vertex.eachOutEdge(function(edge) {\n         if (!self.selectedSet.has(edge.face)) {\n            self.selectFace(edge.face);\n         }\n      });\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromVertexToEdgeSelect = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   var self = this;\n   var oldSelected = this._resetSelectVertex();\n   //\n   for (let vertex of oldSelected.vertices) { \n      // select all edge that is connected to the vertex.\n      vertex.eachOutEdge(function(edge) {\n         if (!self.selectedSet.has(edge.wingedEdge)) {\n            self.selectEdge(edge);\n         }\n      });\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromVertexToBodySelect = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   if (this.hasSelection()) {\n      // select whole body,\n      this._resetSelectVertex();\n      this.selectBody();\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromVertexToMultiSelect = function() {\n   const snapshot = this.snapshotSelectionVertex();\n\n   // clear all selection.\n   this._resetSelectVertex();\n\n   return snapshot;\n};\n\nPreviewCage.prototype.restoreFromVertexToFaceSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectVertex();\n      this.restoreFaceSelection(snapshot);\n   } else {\n      this.changeFromVertexToFaceSelect();  // choose compute over storage, use the same code as going forward.\n   }\n};\n\nPreviewCage.prototype.restoreFromVertexToEdgeSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectVertex();\n      this.restoreEdgeSelection(snapshot);\n   } else {\n      this.changeFromVertexToEdgeSelect();  // choose compute over storage, use the same code as going forward.\n   }\n};\n\nPreviewCage.prototype.restoreFromVertexToBodySelect = function(snapshot) {\n   if (snapshot) {\n      this._resetSelectVertex();\n      this.restoreBodySelection(snapshot);\n   } else {\n      this.changeFromVertexToBodySelect();\n   }\n};\n\nPreviewCage.prototype.restoreFromVertexToMultiSelect = function(_snapshot) {\n   this.changeFromVertexToMultiSelect();\n};\n\n\nPreviewCage.prototype.changeFromMultiToEdgeSelect = function() {\n   return {}; // nothing todo\n};\nPreviewCage.prototype.changeFromMultiToFaceSelect = function() {\n   return {}; // nothing todo\n};\nPreviewCage.prototype.changeFromMultiToVertexSelect = function() {\n   return {}; // nothing todo\n};\nPreviewCage.prototype.changeFromMultiToBodySelect = function() {\n   return {}; // nothing todo\n};\nPreviewCage.prototype.restoreFromMultiToEdgeSelect = function(_snapshot) {\n   // nothing because guarantee nothing selected.\n};\nPreviewCage.prototype.restoreFromMultiToFaceSelect = function(_snapshot) {\n   // nothing because guarantee nothing selected.\n};\nPreviewCage.prototype.restoreFromMultiToVertexSelect = function(_snapshot) {\n   // nothing because guarantee nothing selected.\n};\nPreviewCage.prototype.restoreFromMultiToBodySelect = function(_snapshot) {\n   // nothing because guarantee nothing selected.\n};\n\n\nPreviewCage.prototype.dragSelectEdge = function(selectEdge, dragOn) {\n   var wingedEdge = selectEdge.wingedEdge;\n\n   if (this.selectedSet.has(wingedEdge)) { \n      if (dragOn === false) { // turn from on to off\n         this.selectedSet.delete(wingedEdge);\n         this.bench.selectEdge(wingedEdge, false);\n         return true;   // new off selection\n      }\n   } else {\n      if (dragOn === true) {   // turn from off to on.\n         this.selectedSet.add(wingedEdge);\n         this.bench.selectEdge(wingedEdge, true);\n         return true;\n      }\n   }\n   // edge already on the correct state.\n   return false;\n}\n\nPreviewCage.prototype.selectEdge = function(selectEdge) {\n   // select polygon set color,\n   var wingedEdge = selectEdge.wingedEdge;\n\n   var onOff;\n   var color;\n   if (this.selectedSet.has(wingedEdge)) {\n      this.selectedSet.delete(wingedEdge);\n      color = -0.25;\n      onOff = false;\n   } else {\n      this.selectedSet.add(wingedEdge);\n      color = 0.25;\n      onOff = true;\n      geometryStatus(\"select edge: \" + wingedEdge.index);\n   }\n   // selected color\n   this.bench.selectEdge(wingedEdge, onOff);\n   return onOff;\n};\n\nPreviewCage.prototype.computeSnapshot = function(snapshot) {\n   // update all affected polygon(use sphere). copy and recompute vertex.\n   for (let polygon of snapshot.faces) {\n      const sphere = this.bench.boundingSpheres[polygon.index];\n      // recompute sphere center. and normal\n      polygon.computeNormal();\n      sphere.setSphere( _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__[\"BoundingSphere\"].computeSphere(polygon, sphere.center) );\n   }\n   this.bench.updateCentroid();\n};\n\n\nPreviewCage.prototype.restoreMoveSelection = function(snapshot) {\n   // restore to the snapshot position.\n   let i = 0;\n   for (let vertex of snapshot.vertices) {\n      vec3.copy(vertex.vertex, snapshot.position.subarray(i, i+3));\n      i += 3;\n   }\n   this.bench.updatePosition();\n   this.computeSnapshot(snapshot);\n};\n\n\n// 3-15 - add limit to movement.\nPreviewCage.prototype.moveSelection = function(snapshot, movement) {\n   // first move geometry's position\n   if (snapshot.direction) {\n      let i = 0; \n      for (let vertex of snapshot.vertices) {\n         vec3.scaleAndAdd(vertex.vertex, vertex.vertex, snapshot.direction.subarray(i, i+3), movement);  // movement is magnitude\n         i+=3;\n      }\n   } else {\n      for (let vertex of snapshot.vertices) {\n         vec3.add(vertex.vertex, vertex.vertex, movement);\n      }\n   }\n   this.bench.updatePosition();\n   this.computeSnapshot(snapshot);\n};\n\n//\n// rotate selection, with a center\n//\nPreviewCage.prototype.rotateSelection = function(snapshot, quatRotate, center) {\n   const translate = vec3.create();\n   const scale = vec3.fromValues(1, 1, 1);\n   this.transformSelection(snapshot, (transform, origin) => {\n      mat4.fromRotationTranslationScaleOrigin(transform, quatRotate, translate, scale, (center ? center : origin));   \n    });\n};\n\n//\n// scale selection, by moving vertices\n//\nPreviewCage.prototype.scaleSelection = function(snapshot, scale, axis) {\n   const scaleV = vec3.fromValues(axis[0] ? scale * axis[0] : 1, \n                                  axis[1] ? scale * axis[1] : 1, \n                                  axis[2] ? scale * axis[2] : 1);\n   this.transformSelection(snapshot, (transform, _origin) => {\n      mat4.fromScaling(transform, scaleV);   \n    });\n};\n\n//\n// transform selection,\n//\nPreviewCage.prototype.transformSelection = function(snapshot, transformFn) {\n   // construct the matrix\n   const transform = mat4.create();\n\n   const vArry = snapshot.vertices[Symbol.iterator]();\n   for (let group of snapshot.matrixGroup) {\n      //mat4.fromRotationTranslationScaleOrigin(transform, quatRotation, translate, scale, group.center); // origin should not be modified by scale, glmatrix seems to get the order wrong.\n      transformFn(transform, group.center);\n      for (let index = 0; index < group.count; index++) {\n         const vertex = vArry.next().value;\n         vec3.transformMat4(vertex.vertex, vertex.vertex, transform);\n      }\n   }\n\n   this.bench.updatePosition();\n   this.computeSnapshot(snapshot);\n};\n\n\nPreviewCage.prototype.snapshotPositionAll = function() {\n   return this.snapshotPosition(this.geometry.vertices);\n};\n\nPreviewCage.prototype.snapshotPosition = function(vertices, normalArray) {\n   var ret = {\n      faces: new Set,\n      vertices: null,\n      wingedEdges: new Set,\n      position: null,\n      direction: normalArray,\n   };\n   ret.vertices = vertices;\n   // allocated save position data.\n   const length = vertices.length ? vertices.length : vertices.size; // could be array or set\n   ret.position = new Float32Array(length*3);\n   // use the vertex to collect the affected polygon and the affected edge.\n   let i = 0;\n   for (let vertex of ret.vertices) {\n      vertex.eachOutEdge(function(edge) {\n         if (edge.isNotBoundary() && !ret.faces.has(edge.face)) {\n            ret.faces.add(edge.face);\n         }\n         if (!ret.wingedEdges.has(edge.wingedEdge)) {\n            ret.wingedEdges.add(edge.wingedEdge);\n         }\n      });\n      // save position data\n      ret.position.set(vertex.vertex, i);\n      i += 3;\n   }\n   return ret;\n};\n\nPreviewCage.prototype.snapshotEdgePosition = function() {\n   var vertices = new Set;\n   // first collect all the vertex\n   for (let wingedEdge of this.selectedSet) {\n      for (let edge of wingedEdge) {\n         var vertex = edge.origin;\n         if (!vertices.has(vertex)) {\n            vertices.add(vertex);\n         }\n      }\n   }\n   return this.snapshotPosition(vertices);\n};\n\n\nPreviewCage.prototype.snapshotFacePosition = function() {\n   var vertices = new Set;\n   // first collect all the vertex\n   for (let polygon of this.selectedSet) {\n      polygon.eachVertex( function(vertex) {\n         if (!vertices.has(vertex)) {\n            vertices.add(vertex);\n         }\n      });\n   }\n   return this.snapshotPosition(vertices);\n};\n\nPreviewCage.prototype.snapshotVertexPosition = function() {\n   const vertices = new Set(this.selectedSet);\n   return this.snapshotPosition(vertices);\n};\n\nPreviewCage.prototype.snapshotBodyPosition = function() {\n   let vertices = new Set;\n   if (this.hasSelection()) {\n      vertices = new Set(this.geometry.vertices);\n   }\n   return this.snapshotPosition(vertices);\n};\n\n\nPreviewCage.prototype.snapshotFacePositionAndNormal = function() {\n   const vertices = new Set;\n   let normalMap = new Map;\n   // first collect all the vertex\n   for (let polygon of this.selectedSet) {\n      polygon.eachVertex( function(vertex) {\n         if (!vertices.has(vertex)) {\n            vertices.add(vertex);\n            const normal = [polygon.normal[0], polygon.normal[1], polygon.normal[2]];\n            normalMap.set(vertex, normal);\n         } else {\n            const normal = normalMap.get(vertex);\n            if (vec3.dot(normal, polygon.normal) < 0.999) {  // check for nearly same normal, or only added if hard edge?\n               vec3.add(normal, normal, polygon.normal);\n            } \n         }\n      });\n   }\n   // copy normal;\n   const normalArray = new Float32Array(vertices.size*3);\n   let i = 0;\n   for (let [_vert, normal] of normalMap) {\n      let inputNormal = normalArray.subarray(i, i+3);\n      vec3.copy(inputNormal, normal);\n      i+=3;\n   }\n   return this.snapshotPosition(vertices, normalArray);\n};\n\nPreviewCage.prototype.snapshotVertexPositionAndNormal = function() {\n   const vertices = new Set(this.selectedSet);\n   const array = new Float32Array(vertices.size*3);\n   array.fill(0.0);\n   // copy normal\n   let i = 0;\n   for (let vertex of vertices) {\n      let normal = array.subarray(i, i+3);\n      vertex.eachOutEdge( function(outEdge) {\n         if (outEdge.isNotBoundary()) {\n            vec3.add(normal, normal, outEdge.face.normal);\n         }\n      });\n      vec3.normalize(normal, normal);        // finally, we can safely normalized?\n      i +=3;\n   }\n\n   return this.snapshotPosition(vertices, array);\n};\n\nPreviewCage.prototype.snapshotEdgePositionAndNormal = function() {\n   const vertices = new Set;\n   const normalMap = new Map; \n   // first collect all the vertex\n   const tempNorm = vec3.create();\n   for (let wingedEdge of this.selectedSet) {\n      const p0 = wingedEdge.left.face;\n      const p1 = wingedEdge.right.face;\n      //vec3.normalize(tempNorm, tempNorm);\n      for (let edge of wingedEdge) {\n         let vertex = edge.origin;\n         let normal;\n         if (!vertices.has(vertex)) {\n            vertices.add(vertex);\n            normal = new Set;\n            normalMap.set(vertex, normal);\n         } else {\n            normal = normalMap.get(vertex);\n         }\n         if (p0 !== null) {\n            normal.add( p0 );\n         }\n         if (p1 !== null) {\n            normal.add( p1 );\n         }\n      }\n   }\n   // copy normal\n   const normalArray = new Float32Array(vertices.size*3);\n   normalArray.fill(0.0);\n   let i = 0;\n   for (let [_vert, normal] of normalMap) {\n      let inputNormal = normalArray.subarray(i, i+3);\n      for (let poly of normal) {\n         vec3.add(inputNormal, inputNormal, poly.normal);\n      }\n      i+=3;\n   }\n   return this.snapshotPosition(vertices, normalArray);\n};\n\nPreviewCage.prototype.snapshotTransformEdgeGroup = function() {\n   const vertices = new Set;\n   const matrixGroup = [];\n   // array of edgeLoop. \n   let edgeGroup = this.geometry.findEdgeGroup(this.selectedSet);\n   // compute center of loop, gather all the vertices, create the scaling matrix\n   for (let group of edgeGroup) {\n      let count = 0;\n      const center = vec3.create();\n      for (let wEdge of group) {\n         for (let vertex of wEdge.eachVertex()) {\n            if (!vertices.has(vertex)){\n               vertices.add(vertex);\n               count++;\n               vec3.add(center, center, vertex.vertex);\n            }\n          };\n      }\n      vec3.scale(center, center, 1.0/count); // get the center\n      // now construct the group\n      matrixGroup.push( {center: center, count: count});\n   }\n\n   // now construct all the effected data and save position.\n   const ret = this.snapshotPosition(vertices);\n   ret.matrixGroup = matrixGroup;\n   return ret;\n};\n\nPreviewCage.prototype.snapshotTransformFaceGroup = function() {\n   const vertices = new Set;\n   const matrixGroup = [];\n   // array of edgeLoop. \n   let faceGroup = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findFaceGroup(this.getSelectedSorted());\n   // compute center of loop, gather all the vertices, create the scaling matrix\n   const center = vec3.create();\n   for (let group of faceGroup) {\n      let count = 0;\n      vec3.set(center, 0, 0, 0);\n      for (let face of group) {\n         face.eachVertex(function(vertex) {\n            if (!vertices.has(vertex)){\n               vertices.add(vertex);\n               count++;\n               vec3.add(center, center, vertex.vertex);\n            }\n          });\n      }\n      vec3.scale(center, center, 1.0/count); // get the center\n      // now construct the group\n      matrixGroup.push( {center: center, count: count});\n   }\n\n   // now construct all the effected data and save position.\n   const ret = this.snapshotPosition(vertices);\n   ret.matrixGroup = matrixGroup;\n   return ret;\n};\n\nPreviewCage.prototype.snapshotTransformBodyGroup = function() {\n   let vertices = new Set;\n   const center = vec3.create();\n   if (this.hasSelection()) {\n      for (let vertex of this.geometry.vertices) {\n         if (vertex.isLive()) {\n            vertices.add(vertex);\n            vec3.add(center, center, vertex.vertex);\n         }\n      }\n      vec3.scale(center, center, 1.0/vertices.size);\n   }\n\n   const ret = this.snapshotPosition(vertices);\n   ret.matrixGroup = [{center: center, count: vertices.size}];\n   return ret;\n};\n\n//\n// no separate group. needs to have 2 vertex to see rotation.\n//\nPreviewCage.prototype.snapshotTransformVertexGroup = function() {\n   let vertices = new Set;\n   const center = vec3.create();\n   if (this.hasSelection()) {\n      for (let vertex of this.selectedSet) {\n         vertices.add(vertex);\n         vec3.add(center, center, vertex.vertex);\n      }\n      vec3.scale(center, center, 1.0/vertices.size);\n   }\n\n   const ret = this.snapshotPosition(vertices);\n   ret.matrixGroup = [{center: center, count: vertices.size}];\n   return ret;\n};\n\n\nPreviewCage.prototype._resetSelectEdge = function() {\n   const snapshot = this.snapshotSelectionEdge();\n   this.selectedSet = new Set;\n   this.bench.resetSelectEdge();\n   return snapshot;\n};\n\nPreviewCage.prototype._selectEdgeMore = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   for (let wingedEdge of snapshot.wingedEdges) {\n      for (let halfEdge of wingedEdge) {\n         halfEdge.eachEdge( (edge) => {\n            if (!this.selectedSet.has(edge.wingedEdge)) {\n               this.selectEdge(edge);\n            }\n         });\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectEdgeLess = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   const self = this;\n   for (let selectedWinged of snapshot.wingedEdges) {\n      for (let wingedEdge of selectedWinged.oneRing()) {\n         if (!snapshot.wingedEdges.has(wingedEdge)) {\n            this.selectEdge(selectedWinged.left);\n            break;\n         }\n      }\n   }\n\n   return snapshot;\n}\n\nPreviewCage.prototype._selectEdgeAll = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   for (let wingedEdge of this.geometry.edges) {\n      if (wingedEdge.isLive() && !snapshot.wingedEdges.has(wingedEdge)) {\n         this.selectEdge(wingedEdge.left);\n      }\n   }\n\n   return snapshot;\n}\n\nPreviewCage.prototype._selectEdgeInvert = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   for (let wingedEdge of this.geometry.edges) {\n      if (wingedEdge.isLive()) {\n         this.selectEdge(wingedEdge.left);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectEdgeAdjacent = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   for (let wingedEdge of snapshot.wingedEdges) {\n      for (let adjacent of wingedEdge.adjacent()) {\n         if (!this.selectedSet.has(adjacent)) {\n            this.selectEdge(adjacent.left);\n         }\n      }\n   }\n\n   return snapshot;\n};\n\n\nPreviewCage.prototype._selectEdgeSimilar = function() {\n   const snapshot = this.snapshotSelectionEdge();\n   const similarEdge = new SimilarWingedEdge(snapshot.wingedEdges);\n\n   for (let wingedEdge of this.geometry.edges) {\n      if (wingedEdge.isLive && !snapshot.wingedEdges.has(wingedEdge) && similarEdge.find(wingedEdge)) {\n         this.selectEdge(wingedEdge.left);\n      }\n   }\n\n   return snapshot;\n};\n\n\nPreviewCage.prototype.changeFromEdgeToFaceSelect = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   const oldSelected = this._resetSelectEdge();\n   for (let wingedEdge of oldSelected.wingedEdges) {\n      // for each WingedEdge, select both it face.\n      for (let halfEdge of wingedEdge) {\n         if (!this.selectedSet.has(halfEdge.face)) {\n            this.selectFace(halfEdge.face);\n         }\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromEdgeToVertexSelect = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   const oldSelected = this._resetSelectEdge();\n   for (let wingedEdge of oldSelected.wingedEdges) {\n      // for each WingedEdge, select both it face.\n      for (let halfEdge of wingedEdge) {\n         if (!this.selectedSet.has(halfEdge.origin)) {\n            this.selectVertex(halfEdge.origin);\n         }\n      }\n   }\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromEdgeToBodySelect = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   if (this.hasSelection()) {\n      this._resetSelectEdge();\n      this.selectBody();\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromEdgeToMultiSelect = function() {\n   const snapshot = this.snapshotSelectionEdge();\n\n   if (this.hasSelection()) {\n      this._resetSelectEdge();\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.restoreFromEdgeToFaceSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectEdge();\n      this.restoreFaceSelection(snapshot);\n   } else {\n      this.changeFromEdgeToFaceSelect();  // we cheat, use the same code as going forward.\n   }\n};\n\nPreviewCage.prototype.restoreFromEdgeToVertexSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectEdge();\n      this.restoreVertexSelection(snapshot);\n   } else {\n      this.changeFromEdgeToVertexSelect();  // we cheat, use the same code as going forward.\n   }\n};\n\nPreviewCage.prototype.restoreFromEdgeToBodySelect = function(snapshot) {\n   if (snapshot) {\n      this._resetSelectEdge();\n      this.restoreBodySelection(snapshot);\n   } else {\n      this.changeFromEdgeToBodySelect();\n   }\n};\n\nPreviewCage.prototype.restoreFromEdgeToMultiSelect = function(_snapshot) {\n   this.changeFromEdgeToMultiSelect();\n};\n\nPreviewCage.prototype.setFaceSelectionOff = function(polygon) {\n   this.bench.selectFace(polygon, false);\n   this.selectedSet.delete(polygon);\n};\nPreviewCage.prototype.setFaceSelectionOn = function(polygon) {\n   this.bench.selectFace(polygon, true);\n   this.selectedSet.add(polygon);\n};\n\nPreviewCage.prototype.dragSelectFace = function(polygon, onOff) {\n   // select polygon set color,\n   if (this.selectedSet.has(polygon)) {\n      if (onOff === false) {\n         this.setFaceSelectionOff(polygon);\n         return true;\n      }\n   } else {\n      if (onOff === true) {\n         this.setFaceSelectionOn(polygon);\n         return true;\n      }\n   }\n   geometryStatus(\"polygon face # \" + polygon.index);\n   return false;\n};\n\n/**\n * \n */\nPreviewCage.prototype.selectFace = function(polygon) {\n   var onOff;\n   if (this.selectedSet.has(polygon)) {\n      this.setFaceSelectionOff(polygon);\n      _wings3d__WEBPACK_IMPORTED_MODULE_3__[\"log\"](\"faceSelectOff\", polygon.index);\n      onOff = false;\n   } else {\n      this.setFaceSelectionOn(polygon);\n      _wings3d__WEBPACK_IMPORTED_MODULE_3__[\"log\"](\"faceSelectOn\", polygon.index);\n      onOff = true;\n   }\n   geometryStatus(\"polygon face # \" + polygon.index);\n   return onOff;\n};\n\n\nPreviewCage.prototype._resetSelectFace = function() {\n   const snapshot = this.snapshotSelectionFace();\n   this.selectedSet = new Set;\n   this.bench.selectGroup(snapshot.selectedFaces, false);   // turn off selected Face\n   return snapshot;\n}\n\nPreviewCage.prototype._selectFaceMore = function() {\n   const snapshot = this.snapshotSelectionFace();\n   // seleceted selectedFace's vertex's all faces.\n   for (let polygon of snapshot.selectedFaces) {\n      for (let face of polygon.oneRing()) {\n         // check if face is not selected.\n         if ( (face !== null) && !this.selectedSet.has(face) ) {\n            this.selectFace(face);\n         }\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectFaceLess = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   for (let selected of snapshot.selectedFaces) {\n      for (let polygon of selected.adjacent()) {\n         if (!snapshot.selectedFaces.has(polygon)) {      // selected is a boundary polygon\n            this.selectFace(selected); // now removed.\n            break;\n         }\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectFaceAll = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   for (let polygon of this.geometry.faces) {\n      if (polygon.isLive && !snapshot.selectedFaces.has(polygon)) {\n         this.selectFace(polygon);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectFaceInvert = function() {\n   const snapshot = this.snapshotSelectionFace();;\n\n   for (let polygon of this.geometry.faces) {\n      if (polygon.isLive()) {\n         this.selectFace(polygon);\n      }\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype._selectFaceAdjacent = function() {\n   const snapshot = this.snapshotSelectionFace();;\n\n   // seleceted selectedFace's vertex's all faces.\n   for (let polygon of snapshot.selectedFaces) {\n      for (let face of polygon.adjacent()) {\n         // check if face is not selected.\n         if ( (face !== null) && !this.selectedSet.has(face) ) {\n            this.selectFace(face);\n         }\n      }\n   }\n   \n   return snapshot;\n};\n\nPreviewCage.prototype._selectFaceSimilar = function() {\n   const snapshot = this.snapshotSelectionFace();;\n   const similarFace = new SimilarFace(snapshot.selectedFaces);\n\n   for (let polygon of this.geometry.faces) {\n      if (polygon.isLive() && !snapshot.selectedFaces.has(polygon) && similarFace.find(polygon)) {\n         this.selectFace(polygon);\n      }\n   }\n\n   return snapshot;\n};\n\n\nPreviewCage.prototype.changeFromFaceToEdgeSelect = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   var self = this;\n   var oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      // for eachFace, selected all it edge.\n      polygon.eachEdge(function(edge) {\n         if (!self.selectedSet.has(edge.wingedEdge)) {\n            self.selectEdge(edge);\n         }\n      });\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromFaceToVertexSelect = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   var self = this\n   var oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      // for eachFace, selected all it vertex.\n      polygon.eachVertex(function(vertex) {\n         if (!self.selectedSet.has(vertex)) {\n            self.selectVertex(vertex);\n         }\n      });\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromFaceToBodySelect = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   if (this.hasSelection()) {\n      this._resetSelectFace();\n      this.selectBody();\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.changeFromFaceToMultiSelect = function() {\n   const snapshot = this.snapshotSelectionFace();\n\n   if (this.hasSelection()) {\n      this._resetSelectFace();\n   }\n\n   return snapshot;\n};\n\nPreviewCage.prototype.restoreFromFaceToEdgeSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectFace();\n      // and selected using the snapshots.\n      this.restoreEdgeSelection(snapshot);\n   } else {\n      this.changeFromFaceToEdgeSelect();  // compute vs storage. currently lean toward compute.\n   }\n}\n\nPreviewCage.prototype.restoreFromFaceToVertexSelect = function(snapshot) {\n   if (snapshot) {\n      // discard old selected,\n      this._resetSelectFace();\n      // and selected using the snapshots.\n      this.restoreVertexSelection(snapshot);\n   } else {\n      this.changeFromFaceToVertexSelect();  // compute vs storage. currently lean toward compute.\n   }\n};\n\nPreviewCage.prototype.restoreFromFaceToBodySelect = function(snapshot) {\n   if (snapshot) {\n      this._resetSelectFace();\n      this.restoreBodySelection(snapshot);\n   } else {\n      this.changeFromFaceToBodySelect();\n   }\n};\n\nPreviewCage.prototype.restoreFromFaceToMultiSelect = function(_snapshot) {\n   this.changeFromFaceToMultiSelect();\n};\n\n\nPreviewCage.prototype.extractFace = function() {\n   var vertexSize = this.geometry.vertices.size;\n   var edgeSize = this.geometry.edges.size;\n   var faceSize = this.geometry.faces.size;\n   // array of edgeLoop. \n   var edgeLoops = this.geometry.extractPolygon(this.selectedSet);\n   // adjust preview to the new vertices, edges and faces.\n   this._resizeBoundingSphere(faceSize);\n   this._resizePreview(vertexSize, faceSize);\n   //this._resizeEdges();\n\n   return edgeLoops;\n};\n\n\nPreviewCage.prototype.creaseEdge = function() {\n   return this.extrudeEdge(true);\n}\n//\n// extrudeEdge - add 1/5 vertex to non-selected next/prev hEdges.\n// or to extrude corner if next/prev hEdges are selected. \n// creaseFlag = crease endCap is different.\nPreviewCage.prototype.extrudeEdge = function(creaseFlag = false) {\n   const oldSize = this._getGeometrySize();\n\n   // return value\n   let collapsibleWings = new Set;\n   let liftEdges = [];\n   function undoExtrudeAccounting(result) {  // for undo Purpose.\n      for (let hEdge of result.extrude) {\n         collapsibleWings.add(hEdge.wingedEdge);\n      }\n      for (let hEdge of result.lift) {\n         liftEdges.push(hEdge);\n      }\n   };\n   // temp for accounting purpose.\n   const pt = vec3.create();\n   let extrudeOut  = new Set;    // fFence\n   let extrudeIn = new Set;       // sFence\n   let fences = [];\n   let adjustEnd = [];\n   let adjustStart = [];\n   let traversedEdges = new Set;\n   for (let wEdge of this.selectedSet) {\n      for (let hEdge of wEdge) {\n         if (traversedEdges.has(hEdge)) {  \n            continue;   // already processed.\n         }\n         let current = hEdge.next;\n         while (current !== hEdge) {\n            if (!this.selectedSet.has(current.wingedEdge)) {\n               while (!this.selectedSet.has(current.next.wingedEdge)) { current = current.next; }\n               break;   // found the last of the first contiguous non-selected hEdge.\n            } \n            // this is selected, so keep going.\n            current = current.next;\n         }\n         if (current === hEdge) {   // all inner edges of polygon selected. \n            for (let current of hEdge.face.hEdges()) {\n               traversedEdges.add(current);\n            }  \n            // liftCorner, and extrudeTheLooop.\n            let danglingOut = this.geometry.liftCornerEdge(current);\n            liftEdges.push(danglingOut.pair);\n            let result = this.geometry.extrudeEdge(danglingOut.pair, danglingOut);    \n            undoExtrudeAccounting(result);\n         } else { // now we have a starting non-selected hEdge. restart from here. this is the heart of the algorithm.\n            //let fences = [];\n            hEdge = current;     // reset the starting edge.\n            do {\n               let start = current; // now find contiguous selected.\n               current = current.next;\n               while (this.selectedSet.has(current.wingedEdge)) {\n                  traversedEdges.add(current);\n                  current = current.next; // go until not selected.\n               }\n               let endAdjust = false;\n               let startAdjust = false;\n               let end = current;\n               // we have start, we have end. now split new Edge if not already split by neighbor edges.\n               if (!extrudeIn.has(current.pair)) {\n                  if (end === end.pair.next.pair.next) { // special case of -- edge. lift Edge.\n                     endAdjust = true;\n                  } else { // split it out.\n                     vec3.lerp(pt, current.origin.vertex, current.destination().vertex, 0.2);\n                     current = this.geometry.splitEdge(current, pt); // current newly create edge\n                     end = current;\n                     extrudeOut.add(current);\n                     liftEdges.push(current.pair);\n                  }\n               } else {\n                  extrudeIn.delete(current.pair);   // yes, already create, now connect together, can savely remove\n               }\n               if (!extrudeOut.has(start.pair)) {  // we have end, check if already split by neighbor edges.\n                  if (start === start.next.pair.next.pair) { // special case of -- edge. lift Edge\n                     startAdjust = true;\n                  } else { // split it out, start stay in the front.\n                     vec3.lerp(pt, start.origin.vertex, start.destination().vertex, 0.8);\n                     let newOut = this.geometry.splitEdge(start.pair, pt).pair;\n                     extrudeIn.add(newOut);\n                     liftEdges.push(newOut);\n                     if (start === hEdge) {\n                        hEdge = newOut;               // adjust endEdge.\n                     }\n                     start = newOut;\n                  }\n               } else {\n                  extrudeOut.delete(start.pair);   // yes, already create, now connect together, can savely remove\n               }\n               let fence = {start: start, end: end};\n               fences.push(fence);\n               if (endAdjust) { adjustEnd.push(fence);}\n               if (startAdjust) { adjustStart.push(fence);}\n               // non-selected edge\n               while (!this.selectedSet.has(current.next.wingedEdge)) { \n                  current = current.next;\n               }\n            } while (current !== hEdge);  // check if we have reach starting point.\n         }\n      }\n   }\n   // before loop the extrudeEdge, check if we needs to adjust {start, end}\n   for (let fence of adjustEnd) {\n      let end = fence.end;\n      end.face.getCentroid(pt);\n      vec3.lerp(pt, end.origin.vertex, pt, 0.2);\n      const destVert = this.geometry.addVertex(pt);\n      end = this.geometry._liftDanglingEdge(end.prev(), destVert);\n      liftEdges.push(end.pair);\n      fence.end = end;\n   }\n   for (let fence of adjustStart) {\n      let start = fence.start;\n      start.face.getCentroid(pt);\n      vec3.lerp(pt, start.destination().vertex, pt, 0.2);\n      const destVert = this.geometry.addVertex(pt);\n      start = this.geometry._liftDanglingEdge(start, destVert);\n      liftEdges.push(start.pair);\n      fence.start = start.pair;\n   }\n   // now loop the extrudeEdge. we could not (splitEdge and extrudeEdge) because it will become very hard to find the beginning again.\n   for (let fence of fences) {\n      // now extrude the contiguous selected edge.\n      let result = this.geometry.extrudeEdge(fence.start, fence.end);\n      undoExtrudeAccounting(result);\n   }\n\n   // connected the extrudeEdge corner together if any.\n   for (let hOut of extrudeOut) {\n      let hIn = hOut.pair;\n      // if (extrudeIn.has(hIn)) { continue; } // this is special case of -- edges. already connected. \n      if (creaseFlag) {  // special case of creasing\n         let currentOut = hIn.next;\n         const endIn = currentOut.pair.next.pair;\n         if (extrudeIn.has(endIn))  { // yes the special pair\n            if ((currentOut.face.numberOfVertex > 3) && (currentOut.pair.face.numberOfVertex > 3)) {  // could not do diagonal with triangle.\n               // check if we have to splitEdge because we share the edge with other selected edge.\n               if (extrudeIn.has(currentOut.next.pair) && extrudeOut.has(currentOut.pair.prev().pair)) {\n                  vec3.lerp(pt, currentOut.origin.vertex, currentOut.destination().vertex, 0.5);\n                  let newOut = this.geometry.splitEdge(currentOut, pt);\n                  liftEdges.push(newOut.pair);\n                  currentOut = newOut;\n               }\n               // insert diagonal edge.\n               let diagonalOut = this.geometry.insertEdge(currentOut, hIn);\n               collapsibleWings.add(diagonalOut.wingedEdge);\n               // slide currentOut Edge to diagonal.\n               this.geometry.slideToNext(currentOut.pair);  // will collapse back, due to edge's contraction.\n               continue;   // done th end cap\n            }\n         }\n      }\n      do {\n         hIn = hIn.next.pair;   // move to next In\n         if (extrudeIn.has(hIn)) {  // just connect, then exit\n            let connect = this.geometry.insertEdge(hIn.pair, hOut.pair);\n            collapsibleWings.add(connect.wingedEdge);\n            break;\n         } else { // split edge and connect\n            vec3.lerp(pt, hIn.destination().vertex, hIn.origin.vertex, 0.2);\n            let newOut = this.geometry.splitEdge(hIn.pair, pt);\n            hIn = newOut.pair;\n            liftEdges.push( hIn );\n            let connect = this.geometry.insertEdge(newOut, hOut.pair);\n            collapsibleWings.add(connect.wingedEdge);\n         }\n         hOut = hIn.pair;  // move to current\n      } while (true);   // walk until we hit the other pair\n   }\n   \n   this._updatePreviewAll(oldSize, this.geometry.affected);\n\n   return {collapsibleWings: collapsibleWings, liftEdges: liftEdges};\n};\nPreviewCage.prototype.undoExtrudeEdge = function(extrude) {\n   const oldSize = this._getGeometrySize();\n\n   if (extrude.dissolveEdges) {\n      for (let hEdge of extrude.dissolveEdges) {\n         if (hEdge.wingedEdge.isLive()) {\n            this.geometry.dissolveEdge(hEdge, extrude.collapsibleWings);\n         }\n      }\n   }\n\n   for (let hEdge of extrude.liftEdges) {\n      this.geometry.collapseEdge(hEdge, extrude.collapsibleWings);\n   }\n \n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\n//\n// extrudeVertex - add 1/4 vertex to every edge then connect all together.\nPreviewCage.prototype.extrudeVertex = function() {\n   const oldSize = this._getGeometrySize();\n\n   const splitEdges = [];\n   const extrudeLoops = [];\n   const pt = vec3.create();\n   for (let vertex of this.selectedSet) {\n      let firstHalf;\n      let prevHalf = null;\n      let hEdge = vertex.outEdge;\n      do {\n         vec3.lerp(pt, hEdge.origin.vertex, hEdge.destination().vertex, 0.25);\n         let newOut = this.geometry.splitEdge(hEdge, pt);   // pt is the split point.\n         splitEdges.push( newOut );\n         hEdge = newOut.pair.next;                          // move to next\n         // connect vertex\n         if (prevHalf) {\n            let outConnect = this.geometry.insertEdge(prevHalf, newOut.next);\n            extrudeLoops.push( outConnect );\n            prevHalf = outConnect.next.pair;\n         } else {\n            firstHalf = newOut;   // remember to save the first one\n            prevHalf = newOut.next.pair;\n         }\n      } while (hEdge !== firstHalf);   // firstHalf is the new vertex.outEdge;\n      // connect last to first loop.\n      let outConnect = this.geometry.insertEdge(prevHalf, firstHalf.next);\n      extrudeLoops.push( outConnect );\n   }\n\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n\n   return {insertEdges: extrudeLoops, splitEdges: splitEdges};\n};\nPreviewCage.prototype.undoExtrudeVertex = function(extrude) {\n   const oldSize = this._getGeometrySize();\n\n   for (let hEdge of extrude.insertEdges) {\n      this.geometry.removeEdge(hEdge.pair);\n   }\n   for (let hEdge of extrude.splitEdges) {\n      this.geometry.collapseEdge(hEdge.pair);\n   }\n \n   this._updatePreviewAll(oldSize, this.geometry.affected);\n}\n\n\n//\n// extrudeFace - will create a list of \nPreviewCage.prototype.extrudeFace = function(contours) {\n   const oldSize = this._getGeometrySize();\n   // array of edgeLoop. \n   if (!contours) {\n      contours = {};\n      contours.edgeLoops = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findContours(this.selectedSet); \n   }\n   contours.edgeLoops = this.geometry.liftContours(contours.edgeLoops);\n   contours.extrudeEdges = this.geometry.extrudeContours(contours.edgeLoops);\n   //const edgeLoops = this.geometry.extrudePolygon(this.selectedSet);\n   // add the new Faces. and new vertices to the preview\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // reselect face\n   const oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      this.selectFace(polygon);\n   }\n\n   return contours; //edgeLoops;\n};\n\n\n// collapse list of edges\nPreviewCage.prototype.collapseExtrudeEdge = function(undo) {\n   const edges = undo.extrudeEdges;\n   const affectedPolygon = new Set;\n   const oldSize = this._getGeometrySize();\n   for (let edge of edges) {\n      edge.origin.eachOutEdge( function(edge) {\n         affectedPolygon.add(edge.face);\n      });\n      this.geometry.collapseEdge(edge);\n   }\n   // recompute the smaller size\n   this._updatePreviewAll(oldSize,  this.geometry.affected);\n   // reselect face\n   const oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      this.selectFace(polygon);\n   }\n\n   // update all affected polygon(use sphere). recompute centroid.\n   for (let polygon of affectedPolygon) {\n      if (polygon.isLive()) {\n         const sphere = this.bench.boundingSpheres[polygon.index];\n         // recompute sphere center.\n         sphere.setSphere( _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__[\"BoundingSphere\"].computeSphere(polygon, sphere.center) );\n      }\n   }\n   // done, update shader data, should we update each vertex individually?\n   this.bench.updateCentroid();\n};\n\n//\n// selectable polygon - find exterior edges loop of selected polygon\n//\nPreviewCage.prototype.findExtFaceContours = function() {\n   const contourEdges = new Set;\n   const cornerFaces = new Set;\n   const edgeLoops = [];\n   // find all contourEdges to extrude\n   for (let polygon of this.selectedSet) {\n      for (let outEdge of polygon.hEdges()) {\n         let extEdge = outEdge.pair;\n         if (!contourEdges.has(extEdge) && !this.selectedSet.has(extEdge.face)) {   // yes, this exterior edge has not been processed yet\n            const edgeLoop = [];\n            let current = extEdge;\n            do {\n               edgeLoop.push( current );\n               contourEdges.add(current);       // checkIn the contour edge.\n               let corner = true;\n               while (!this.selectedSet.has(current.next.pair.face)) {  // walk to the next exterior edge\n                  current = current.next.pair;\n                  corner = false;\n               }\n               if (corner) {\n                  cornerFaces.add(current.face);\n               }\n               current = current.next;          // the next exterior Edge\n            } while (current !== extEdge);      // check if we come full circle\n            edgeLoops.push( edgeLoop );\n         }\n      }\n   }\n\n   return {contourLoops: edgeLoops, cornerFaces: cornerFaces};\n};\n\n\nPreviewCage.prototype.bumpFace = function() {\n   const oldSize = this._getGeometrySize();\n\n   // find contourEdge\n   const result = this.findExtFaceContours();\n   const contours = result.contourLoops;\n\n   const pt = vec3.create();\n   const cornerFaces = new Map;\n   let collapsibleWings = new Set;\n   let dissolveEdges = new Set;\n   let liftEdges = new Set;\n   let self = this;\n   function bumpEdge(next, prev) {\n      let connectOut = self.geometry.insertEdge(next, prev);\n      collapsibleWings.add(connectOut.wingedEdge);\n      dissolveEdges.add(connectOut.pair); // make sure it gone.\n   };\n   // split and connect the exterior edges.\n   for (let loop of contours) {\n      let firstLift = null;\n      let prevLift = null;\n      let prevH = loop[loop.length-1]; // get the last exterior edge\n      for (let hEdge of loop) {\n         let current = prevH.next;\n         if (current !== hEdge) {   // skip corner\n            do {  // at lease one splitEdge\n               let splitOut = current;\n               if (collapsibleWings.has(current.next.wingedEdge) || liftEdges.has(current.next)) {  // yep, already split,\n                  // check if neighbor face already bump it\n                  if (prevLift) {\n                     if (current.next.next !== prevLift) {  // no, not bump yet.\n                        bumpEdge(splitOut, prevLift);\n                     }\n                  } else if (firstLift === null) { // first time through\n                     firstLift = current;\n                  } else { // exit cornerFace\n                     const fans = cornerFaces.get(current.face);\n                     fans.add(current);\n                  }\n               } else { // split edge, and connect to prevLift\n                  vec3.lerp(pt, current.origin.vertex, current.destination().vertex, 0.5);\n                  splitOut = this.geometry.splitEdge(current, pt);   // pt is the split point.\n                  liftEdges.add(splitOut.pair);\n                  if (prevLift) {   // connect to prevLift\n                     bumpEdge(splitOut, prevLift);\n                  } else if (firstLift === null) { // first time through\n                     firstLift = splitOut;\n                  } else { // exit cornerFace\n                     const fans = cornerFaces.get(splitOut.face);\n                     fans.add(splitOut);\n                  }\n               }\n\n               prevLift = splitOut.pair;\n               current = splitOut.pair.next;\n            } while (current !== hEdge);\n         } else { // inner corner, reset prevLift\n            if (!cornerFaces.has(current.face)) {\n               cornerFaces.set(current.face, new Set);\n            }\n            const fans = cornerFaces.get(current.face);\n            if (prevLift) {\n               fans.add( prevLift.prev() );\n               prevLift = null;\n            }\n            fans.add( prevH );   // all inEdge.\n            if (firstLift === null) {  // firstLift is a corner, so no worry. undefined it\n               firstLift = undefined;\n            }\n         }\n         prevH = hEdge;\n      }\n      if (prevLift) {\n         if (cornerFaces.has(prevLift.face)) {\n            const fans = cornerFaces.get(prevLift.face);\n            fans.add( prevLift.prev() );\n         }\n\n         if (firstLift && (firstLift.next.next !== prevLift)) {   // no bumped by other loop\n            // connect last to first.\n            bumpEdge(firstLift, prevLift);\n         }\n      }\n   }\n   // now do polygon fans on the cornerFace.\n   for (let [polygon, fans] of cornerFaces) {   // fan is error\n      const fan = this.geometry.insertFan(polygon, fans);\n      // add fan to dissolveEdges, and collapsibleWings\n      //liftEdges.add(liftEdge);\n      //collapsibleWings.add(liftEdge.wingedEdge);\n      for (let hEdge of fan) {\n         collapsibleWings.add(hEdge.wingedEdge);\n         dissolveEdges.add(hEdge);\n      }\n   }\n\n \n   this._updatePreviewAll(oldSize, this.geometry.affected);\n\n   return {liftEdges: liftEdges, collapsibleWings: collapsibleWings, dissolveEdges: dissolveEdges};\n};\n\n\nPreviewCage.prototype.cutEdge = function(numberOfSegments) {\n   const edges = this.selectedSet;\n\n   const oldSize = this._getGeometrySize();\n   const vertices = [];\n   const splitEdges = [];              // added edges list\n   // cut edge by numberOfCuts\n   let diff = vec3.create();\n   let vertex = vec3.create();\n   for (let wingedEdge of edges) {\n      let edge = wingedEdge.left;\n      vec3.sub(diff, edge.origin.vertex, edge.destination().vertex); // todo: we could use vec3.lerp?\n      for (let i = 1; i < numberOfSegments; ++i) {\n         const scaler = (numberOfSegments-i)/numberOfSegments;\n         vec3.scale(vertex, diff, scaler);                  \n         vec3.add(vertex, edge.destination().vertex, vertex);\n         const newEdge = this.geometry.splitEdge(edge, vertex);       // input edge will take the new vertex as origin.\n         vertices.push( edge.origin );\n         splitEdges.push( newEdge.pair );\n      }\n      // update previewEdge position.\n      //this._updatePreviewEdge(edge, true);\n   }\n      // after deletion of faces and edges. update\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // returns created vertices.\n   return {vertices: vertices, halfEdges: splitEdges};\n};\n\n// collapse list of edges, pair with CutEdge, bevelEdge.\nPreviewCage.prototype.collapseSplitOrBevelEdge = function(collapse) {\n   const oldSize = this._getGeometrySize();\n   for (let halfEdge of collapse.halfEdges) {\n      if (halfEdge.wingedEdge.isLive()) { // checked for already collapse edge\n         this.geometry.collapseEdge(halfEdge, collapse.collapsibleWings);\n      }\n   }\n   // recompute the smaller size\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\n// connect selected Vertex,\nPreviewCage.prototype.connectVertex = function() {\n   const oldSize = this._getGeometrySize();\n   \n   //this.geometry.clearAffected();\n   const edgeList = this.geometry.connectVertex(this.selectedSet);\n   const wingedEdgeList = [];\n   for (let edge of edgeList) {\n      wingedEdgeList.push( edge.wingedEdge );\n   }\n\n   // updatePreviewbox\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n\n   return {halfEdges: edgeList, wingedEdges: wingedEdgeList};\n};\n// pair with connectVertex.\nPreviewCage.prototype.dissolveConnect = function(connect) {\n   const insertEdges = connect.halfEdges;\n   const oldSize = this._getGeometrySize();\n\n   // dissolve in reverse direction\n   for (let i = insertEdges.length-1; i >= 0; --i) {\n      const halfEdge = insertEdges[i];\n      this.geometry.removeEdge(halfEdge.pair);\n   }\n\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\n//\nPreviewCage.prototype.dissolveSelectedEdge = function() {\n   const dissolveEdges = [];\n   const oldSize = this._getGeometrySize();\n   for (let edge of this.selectedSet) {\n      let undo = this.geometry.dissolveEdge(edge.left);\n      let dissolve = { halfEdge: edge.left, undo: undo};\n      dissolveEdges.push(dissolve);\n   }\n   this.selectedSet.clear();\n   // after deletion of faces and edges. update\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // return affected.\n   return dissolveEdges;\n};\nPreviewCage.prototype.reinsertDissolveEdge = function(dissolveEdges) {\n   const oldSize = this._getGeometrySize();\n   // walk form last to first.\n   for (let i = (dissolveEdges.length-1); i >= 0; --i) {\n      let dissolve = dissolveEdges[i];\n      this.geometry.restoreDissolveEdge(dissolve.undo);\n      this.selectEdge(dissolve.halfEdge);\n   }\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\nPreviewCage.prototype.collapseSelectedEdge = function() {\n   const restoreVertex = [];\n   const collapseEdges = [];\n   const oldSize = this._getGeometrySize();\n   const selected = new Map();\n   for (let edge of this.selectedSet) {\n      let undo = null;\n      if (edge.isLive()){\n      let vertex = edge.left.origin;\n      let pt;\n      if (selected.has(vertex)) {\n         pt = selected.get(vertex);    \n         selected.delete(vertex);   // going to be freed, so we can safely remove it.\n         vec3.add(pt.pt, pt.pt, vertex.vertex);\n         pt.count++;\n      } else {\n         pt = {pt: new Float32Array(3), count: 1};\n         vec3.copy(pt.pt, vertex.vertex);\n      }\n      let keep = edge.right.origin;\n      if (selected.has(keep)) {\n         const keepPt = selected.get(keep);\n         vec3.add(keepPt.pt, pt.pt, keepPt.pt);\n         keepPt.count += pt.count;\n      } else {\n         selected.set(keep, pt);\n      }\n         undo = this.geometry.collapseEdge(edge.left);\n      }\n      let collapse = {halfEdge: edge.left, undo: undo};\n      collapseEdges.push(collapse);\n   }\n   this.selectedSet.clear();\n\n   // the selected is the remaining Vertex\n   const selectedVertex = [];\n   for (let [vertex, pt] of selected) {\n      selectedVertex.push( vertex );\n      // save and move the position\n      const savePt = new Float32Array(3);\n      vec3.copy(savePt, vertex.vertex);\n      restoreVertex.push({vertex: vertex, savePt: savePt});\n      vec3.add(pt.pt, pt.pt, savePt);\n      vec3.scale(pt.pt, pt.pt, 1.0/(pt.count+1)); \n      vec3.copy(vertex.vertex, pt.pt);\n      this.geometry.addAffectedEdgeAndFace(vertex);\n   }\n   // after deletion of\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   return { collapse: {edges: collapseEdges, vertices: restoreVertex}, vertices: selectedVertex };\n};\n\nPreviewCage.prototype.restoreCollapseEdge = function(data) {\n   const collapse = data.collapse;\n   const oldSize = this._getGeometrySize();\n   // walk form last to first.\n   this.selectedSet.clear();\n\n   const collapseEdges = collapse.edges;\n   for (let i = (collapseEdges.length-1); i >= 0; --i) {\n      let collapseEdge = collapseEdges[i];\n      if (collapseEdge.undo) {\n         this.geometry.restoreCollapseEdge(collapseEdge.undo);\n      }\n   }\n   for (let collapseEdge of collapseEdges) { // selectedge should be in order\n      this.selectEdge(collapseEdge.halfEdge);\n   }\n   const restoreVertex = collapse.vertices;\n   for (let restore of restoreVertex) {   // restore position\n      vec3.copy(restore.vertex.vertex, restore.savePt);\n      this.geometry.addAffectedEdgeAndFace(restore.vertex);\n   }\n   // \n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\nPreviewCage.prototype.dissolveSelectedFace = function() {\n   const oldSize = this._getGeometrySize();\n   const selectedEdges = new Set;\n   // the all the selectedFace's edge.\n   for (let polygon of this.selectedSet) {\n      polygon.eachEdge( function(outEdge) {\n         selectedEdges.add(outEdge.wingedEdge);\n      });\n   }\n   // get the outline edge\n   const contourLoops = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findContours(this.selectedSet);\n   // subtract outline edges from all selected edge.\n   for (let loop of contourLoops) {\n      for (let edge of loop) {\n         let outEdge = edge.outer;\n         if (selectedEdges.has(outEdge.wingedEdge)) {\n            selectedEdges.delete(outEdge.wingedEdge);\n         }\n      }\n   }\n   // the reemaining edges is the remove Edge.\n   const substract = [];\n   for (let edge of selectedEdges) {\n      substract.unshift( this.geometry.dissolveEdge(edge.left) );   // add in reverse order\n   }\n   // update the remaining selectedSet.\n   const selectedFace = this.selectedSet;\n   const selectedSet = new Set;\n   for (let polygon of this.selectedSet) {\n      if (polygon.isLive()) {\n         selectedSet.add(polygon);\n      }\n   }\n   this.selectedSet = selectedSet;\n   // update previewBox.\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // return undo function\n   return {edges: substract, selection: selectedFace};\n};\nPreviewCage.prototype.undoDissolveFace = function(dissolve) {\n   const oldSize = this._getGeometrySize();\n   for (let dissolveUndo of dissolve.edges) {\n      dissolveUndo();\n   }\n   this.selectedSet.clear();\n   // reselected the polygon in order.\n   for (let polygon of dissolve.selection) {\n      this.selectFace(polygon);\n   }\n   // update previewBox.\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n}\n\n\n// the original wings3D collapse quite strangely. collapse by edge index order? such a weird algorithm.\n// we change it to collapse to middle.\nPreviewCage.prototype.collapseSelectedFace = function() {\n   const saveSet = this.selectedSet;\n   // reuse edgeSelect().\n   this.changeFromFaceToEdgeSelect();\n   // reuse collapseEdge\n   const collapse = this.collapseSelectedEdge();\n   collapse.selectedFaces = saveSet;\n   return collapse;\n};\nPreviewCage.prototype.undoCollapseFace = function(collapse) {\n   this.restoreCollapseEdge(collapse);\n};\n\n\nPreviewCage.prototype.dissolveSelectedVertex = function() {\n   const oldSize = this._getGeometrySize();\n   const undoArray = {array: [], selectedFaces: []};\n   for (let vertex of this.selectedSet) {\n      let result = this.geometry.dissolveVertex(vertex);\n      undoArray.array.unshift( result );\n      undoArray.selectedFaces.push( result.polygon );\n   }\n   this._resetSelectVertex();\n   // update previewBox.\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   return undoArray;\n};\nPreviewCage.prototype.undoDissolveVertex = function(undoArray) {\n   const oldSize = this._getGeometrySize();\n   for (let undo of undoArray.array) {\n      this.geometry.restoreDissolveVertex(undo);\n      this.selectVertex(undo.vertex);\n   }\n   // update previewBox.\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n};\n\n\n// Bevelling of edge.\nPreviewCage.prototype.bevelEdge = function() {\n   const oldSize = this._getGeometrySize();\n   const wingedEdges = this.selectedSet;\n\n   // bevelEdge\n   const result = this.geometry.bevelEdge(wingedEdges);       // input edge will take the new vertex as origin.\n   // get all effected wingedEdge\n   result.wingedEdges = new Set;\n   result.faces = new Set;\n   for (let vertex of result.vertices) {\n      for (let hEdge of vertex.edgeRing()) {\n         result.wingedEdges.add( hEdge.wingedEdge );\n         result.faces.add( hEdge.face );\n      }\n   };\n\n   // add the new Faces, new edges and new vertices to the preview\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // update vertices created vertices.\n   return result;\n   //let ret = {\n   //   faces: [],\n   //   vertices: [],\n   //   wingedEdge: new set,\n   //   halfEdges: [],\n   //   position: float32array,\n   //   direction: float32array,\n   //   vertexLimit: magnitude,\n   //};\n};\n// \n// bevel face, same as edge but with differnt hilite faces\n//\nPreviewCage.prototype.bevelFace = function() {\n   const oldSize = this._getGeometrySize();\n   const faces = this.selectedSet;\n\n   let wingedEdges = new Set;\n   for (let polygon of faces) {  // select all polygon's edges\n      for (let hEdge of polygon.hEdges()) {\n         wingedEdges.add( hEdge.wingedEdge );\n      }\n   }\n   // bevelEdge\n   const result = this.geometry.bevelEdge(wingedEdges);       // input edge will take the new vertex as origin.\n   // get all effected wingedEdge\n   result.wingedEdges = new Set;\n   result.faces = new Set;\n   for (let vertex of result.vertices) {\n      for (let hEdge of vertex.edgeRing()) {\n         result.wingedEdges.add( hEdge.wingedEdge );\n         result.faces.add( hEdge.face );\n      }\n   };\n\n   // add the new Faces, new edges and new vertices to the preview\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // reselect faces again. because polygon's edges were changed.\n   const oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      this.selectFace(polygon);\n   }\n\n   return result;\n};\n//\n// bevel vertex\n//\nPreviewCage.prototype.bevelVertex = function() {\n   const oldSize = this._getGeometrySize();\n   const vertices = this.selectedSet;\n\n   // bevelVertex\n   const result = this.geometry.bevelVertex(vertices);       // input vertices, out new vertex, edges, and faces.\n   // get all effected wingedEdge\n   result.wingedEdges = new Set;\n   result.faces = new Set;\n   for (let vertex of result.vertices) {\n      for (let hEdge of vertex.edgeRing()) {\n         result.wingedEdges.add( hEdge.wingedEdge );\n         result.faces.add( hEdge.face );\n      }\n   };\n\n   // add the new Faces, new edges and new vertices to the preview\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // update vertices created vertices.\n   return result;\n   //let ret = {\n   //   faces: [],\n   //   vertices: [],\n   //   wingedEdge: new set,\n   //   halfEdges: [],\n   //   position: float32array,\n   //   direction: float32array,\n   //   vertexLimit: magnitude,\n   //};\n};\n\n//\n// iterated through selectedEdge, and expand it along the edges, edge loop only possible on 4 edges vertex\n//\nPreviewCage.prototype.edgeLoop = function(nth) {\n   let count = 0;\n   const selection = new Set(this.selectedSet);\n   const ret = [];\n   for (let wingedEdge of selection) {\n      // walk forward, then backward.\n      for (let hEdge of wingedEdge) {\n         const end = hEdge;\n         // walking along the loop\n         while (hEdge = hEdge.next.pair.next) { // next edge\n            if (this.selectedSet.has(hEdge.wingedEdge) || (hEdge.destination().numberOfEdge() !== 4) ) {\n               break;   // already at end, or non-4 edge vertex.\n            }\n            ++count;\n            if ((count % nth) === 0) {\n               this.selectEdge(hEdge);\n               ret.push(hEdge);\n            }\n         }\n      }\n   }\n   return ret;\n};\n\n//\n// iterated through selectedEdge, and expand it along 2 side of loop, edge Ring only possible on 4 edges face\n//\nPreviewCage.prototype.edgeRing = function(nth) {\n   let count = 0;\n   const selection = new Set(this.selectedSet);\n   const ret = [];\n   for (let wingedEdge of selection) {\n      // walk forward, then backward.\n      for (let hEdge of wingedEdge) {\n         const end = hEdge;\n         // walking along the loop\n         while (hEdge = hEdge.pair.next.next) { // next edge\n            if (this.selectedSet.has(hEdge.wingedEdge) || (hEdge.next.next.next.next !== hEdge) ) {\n               break;   // already at end, or non-4 edge face.\n            }\n            ++count;\n            if ((count % nth) === 0) {\n               this.selectEdge(hEdge);\n               ret.push(hEdge);\n            }\n         }\n      }\n   }\n   return ret;\n};\n\n// bridge, and unbridge\nPreviewCage.prototype.bridge = function(targetFace, sourceFace) {\n   if (this.selectedSet.size === 2) {  // make sure. it really target, source\n      const oldSize = this._getGeometrySize();\n\n      const targetSphere = this.bench.boundingSpheres[targetFace.index];\n      const sourceSphere = this.bench.boundingSpheres[sourceFace.index];\n      const deltaCenter = vec3.create();\n      //vec3.sub(deltaCenter, targetSphere.center, sourceSphere.center);   // what if we don't move the center, would it work better? so far, no\n      const result = this.geometry.bridgeFace(targetFace, sourceFace, deltaCenter);\n      // clear selection\n      result.selectedFaces = this.selectedSet;\n      this._resetSelectFace();\n\n\n      // update previewBox.\n      this._updatePreviewAll(oldSize, this.geometry.affected);  \n      return result;\n   }\n   // should not happened, throw?\n   return null;\n};\nPreviewCage.prototype.undoBridge = function(bridge) {\n   if (bridge) {\n      const oldSize = this._getGeometrySize();\n\n      this.geometry.undoBridgeFace(bridge);\n\n      // update previewBox.\n      this._updatePreviewAll(oldSize, this.geometry.affected);  \n   }\n};\n\n// \n// Inset face, reuse extrude face code.\n//\nPreviewCage.prototype.insetFace = function() {\n   const oldSize = this._getGeometrySize();\n\n   // array of edgeLoop.\n   const contours = {};\n   contours.edgeLoops = this.geometry.findInsetContours(this.selectedSet); \n   \n   contours.edgeLoops = this.geometry.liftContours(contours.edgeLoops);\n   contours.extrudeEdges = this.geometry.extrudeContours(contours.edgeLoops);\n   // now get all the effected vertices, and moving direction.\n   let vertexCount = 0;\n   for (let polygon of this.selectedSet) {\n      vertexCount += polygon.numberOfVertex;\n   }\n   // compute direction, and moveLimit.\n   contours.vertices = [];\n   contours.faces = new Set;\n   contours.wingedEdges = new Set;\n   contours.position = new Float32Array(vertexCount*3);     // saved the original position\n   contours.direction = new Float32Array(vertexCount*3);    // also add direction.\n   contours.vertexLimit = Number.MAX_SAFE_INTEGER;  // really should call moveLimit.\n   let count = 0;\n   for (let polygon of this.selectedSet) {\n      let prev = null;\n      contours.faces.add(polygon);\n      for (let hEdge of polygon.hEdges()) {\n         contours.vertices.push(hEdge.origin);\n         contours.faces.add(hEdge.pair.face);\n         contours.wingedEdges.add( hEdge.wingedEdge );\n         contours.wingedEdges.add( hEdge.pair.next.wingedEdge );  // the extrude edge \n         let position = contours.position.subarray(count, count+3);\n         let direction = contours.direction.subarray(count, count+3);\n         count += 3;\n         vec3.copy(position, hEdge.origin.vertex);\n         if (!prev) {\n            prev = hEdge.prev();\n         }\n         vec3.scale(direction, hEdge.destination().vertex, 1.0/2);            // compute the sliding middle point\n         vec3.scaleAndAdd(direction, direction, prev.origin.vertex, 1.0/2);\n         vec3.sub(direction, direction, hEdge.origin.vertex);\n         // get length and normalized.\n         const len = vec3.length(direction);\n         if (len < contours.vertexLimit) {\n            contours.vertexLimit = len;\n         }\n         vec3.normalize(direction, direction);\n         // \n         prev = hEdge;\n      }\n   }\n\n   // add the new Faces. and new vertices to the preview\n   this._updatePreviewAll(oldSize, this.geometry.affected);\n   // reselect face, or it won't show up. a limitation.\n   const oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      this.selectFace(polygon);\n   }\n\n\n   return contours;\n};\n\nPreviewCage.prototype.invertBody = function() {\n   this.geometry.invert();\n};\n\nPreviewCage.prototype.flipBodyAxis = function(pivot, axis) {\n   // first flip, then invert.\n   this.geometry.flip(pivot, axis);\n   this.geometry.invert();\n};\n\n// todo: current implementation is wrong. we should not average vertex, instead we should average using area of polygon\nPreviewCage.prototype.bodyCentroid = function() {\n   // \n   const pt = vec3.create();\n   let count = 0;\n   for (let vertex of this.geometry.vertices) {\n      vec3.add(pt, pt, vertex.vertex);\n      ++count;\n   }\n   if (count > 0) {\n      vec3.scale(pt, pt, 1/count);\n   }\n   return pt;\n};\n\nPreviewCage.prototype.weldableVertex = function(vertex) {\n   if (this.selectedSet.size == 1) {\n      let it = this.selectedSet.values();\n      let selectedVertex = it.next().value;     // get the selectedVertex\n      const end = selectedVertex.outEdge;\n      let current = end;\n      do {\n         if (current.destination() === vertex) {\n            return current;\n         }\n         current = current.pair.next;\n      } while (current !== end);\n   }\n   return false;\n};\n\nPreviewCage.prototype.weldVertex = function(halfEdge) {\n   this.selectVertex(halfEdge.origin);\n   this.selectVertex(halfEdge.destination());   // select the weld Vertex as new Selection.\n   let ret = this.geometry.collapseEdge(halfEdge);\n   this._updatePreviewAll();\n   return ret;\n};\n\nPreviewCage.prototype.undoWeldVertex = function(undo) {\n   this.geometry.restoreCollapseEdge(undo);\n   this.selectVertex(undo.hEdge.destination())  // unselect\n   this.selectVertex(undo.hEdge.origin);\n   this._updatePreviewAll();\n};\n\n\nPreviewCage.prototype.intrudeFace = function() {\n   const ret = {};\n   if (this.selectedSet.size == 0) {\n      return ret;   // no hole to intrude through.\n   }\n\n   // first merge adjacent faces\n   ret.dissolve = this.dissolveSelectedFace();\n\n   // duplicate connectivity info(invert), and vertex\n   const uniqueVertex = new Map;\n   const addVertex = (vertex) => {\n      let pt = uniqueVertex.get(vertex);\n      if (!pt) {\n         pt = this.geometry.addVertex(vertex.vertex);\n         uniqueVertex.set(vertex, pt);\n      }\n      return pt.index;\n   };\n   const newPolygons = [];\n   const connectLoops = [];\n   const originalFaces = Array.from(this.geometry.faces);\n   for (let polygon of originalFaces) {\n      const ptsLoop = [];\n      for (let hEdge of polygon.hEdges()) {\n         ptsLoop.push( addVertex(hEdge.origin) );\n      }\n      if (this.selectedSet.has(polygon)) {   // save hole's connect loop.\n         let i = 0;\n         let lastFront, lastBack;\n         for (let hEdge of polygon.hEdges()) {\n            const currentF = hEdge.origin.index;\n            const currentB = ptsLoop[i];\n            if (i > 0) {\n               connectLoops.push( [lastFront, currentF, currentB, lastBack] );\n            }\n            ++i;\n            lastFront = currentF;\n            lastBack = currentB;\n         }\n         // add the last loop\n         connectLoops.push( [lastFront, polygon.halfEdge.origin.index, ptsLoop[0], lastBack]);\n      } else { // add the invert polygon.\n         ptsLoop.reverse();\n         newPolygons.push( this.geometry.addPolygon(ptsLoop) );\n      }\n   }\n\n   // now holed the remaining selected Face\n   this._updatePreviewAll();  // temp Fix: needs to update Preview before holeSelectedFace\n   ret.holed = this.holeSelectedFace();\n   // select all newly created polygon\n   for (let polygon of newPolygons) {\n      this.selectFace(polygon);\n   }\n   ret.invert = newPolygons;\n\n   // connect to the front polygons.\n   ret.connect = [];\n   for (let loop of connectLoops) {\n      ret.connect.push( this.geometry.addPolygon(loop) );\n   }\n\n   this._updatePreviewAll();\n   // return restoration params.\n   return ret;\n};\n\nPreviewCage.prototype.undoIntrudeFace = function(intrude) {\n   for (let polygon of intrude.connect) { // first remove the connect face\n      this.geometry.makeHole(polygon);\n   }\n\n   // now deselect inverts, and remove all polygon' and it edges and vertex\n   for (let polygon of intrude.invert) {\n      this.selectFace(polygon);\n   }\n   const wEdges = new Set();\n   for (let polygon of intrude.invert) {\n      for (let hEdge of polygon.hEdges()) {\n         this.geometry._freeVertex(hEdge.origin);\n         wEdges.add( hEdge.wingedEdge );\n      }\n      this.geometry._freePolygon(polygon);\n   }\n   for (let wEdge of wEdges) {\n      this.geometry._freeEdge(wEdge.left);\n   }\n\n   // now restore hole facce\n   this.undoHoleSelectedFace(intrude.holed);\n\n   // undo merge face\n   this.undoDissolveFace(intrude.dissolve);\n};\n\n\nPreviewCage.prototype.holeSelectedFace = function() {\n   // remove the selected Face, and free it.\n   const holes = new Set(this.selectedSet);\n   const ret = [];\n   for (let polygon of holes) {\n      this.selectFace(polygon);\n      ret.push( this.geometry.makeHole(polygon) );\n   }\n\n   return ret;\n};\nPreviewCage.prototype.undoHoleSelectedFace = function(holes) {\n   for (let hole of holes) {\n      const polygon = this.geometry.undoHole(hole);\n      this.selectFace(polygon);\n   }\n};\n\n\n// edgeMode - cut out selected contours.\nPreviewCage.prototype.loopCut = function() {\n   const allFaces = new Set(this.geometry.faces);\n   let partition;\n\n   const partitionFace = (polygon) => {\n      partition.add(polygon);\n      allFaces.delete(polygon);\n      for (let hEdge of polygon.hEdges()) {\n         if (!this.selectedSet.has(hEdge.wingedEdge) && allFaces.has(hEdge.pair.face)) {\n            partitionFace(hEdge.pair.face);\n         }\n      }      \n   };\n\n   let partitionGroup = [];\n   for (let wEdge of this.selectedSet) {\n      for (let hEdge of wEdge) {\n         if (allFaces.has(hEdge.face)) {\n            partition = new Set;\n            partitionFace(hEdge.face);\n            // go the partition, now save it\n            partitionGroup.push( partition );\n         }\n      }\n   }\n\n   if (partitionGroup.length < 2) {   // make sure, there is at least 2 partition.\n      geometryStatus(\"less than 2 partitions\");\n      return false;\n   }\n\n   // we have to separate from smallest to largest, so that separation can gel into single face correctly.\n   partitionGroup = partitionGroup.sort((a,b) => { return a.size - b.size;});\n   // reset selected set\n   const selected = new Set(this.selectedSet);\n   for (let wEdge of selected) {\n      this.selectEdge(wEdge.left);\n   }\n\n   const ret = {separateCages: [], fillFaces: [], contourLoops: [], selectedSet: selected};\n   const fillFaces = new Set;\n   // detach smaller groups from the largest, by finding the contour.\n   for (let i = 0; i < partitionGroup.length; ++i) {\n      const partition = partitionGroup[i];\n      let newFills = [];\n      let separate = this;\n      if (i !== (partitionGroup.length-1)) { \n         let contours = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findContours(partition); // detach faceGroups from main\n         for (let edgeLoop of contours) {\n            if ((edgeLoop.length > 0) && !fillFaces.has(edgeLoop[0].outer.face)) { // not already separated.\n               this.geometry.liftContour(edgeLoop);\n               const fillFace = this.geometry._createPolygon(edgeLoop[0].outer, edgeLoop.size); // fill hole.\n               newFills.push(fillFace);\n               separate = this.detachFace(partition, i);\n               ret.contourLoops.push( edgeLoop );\n            }\n         }\n      }\n      // merge/delete add fillFaces\n      for (let polygon of fillFaces) {\n         if (separate.geometry.faces.has(polygon)) {\n            separate.selectedSet.add(polygon);\n            fillFaces.delete(polygon);\n         }\n      }\n      separate.dissolveSelectedFace(); // merge if possible.\n      ret.fillFaces = ret.fillFaces.concat( Array.from(separate.selectedSet) );\n      separate.selectedSet = new Set;\n      for (let polygon of newFills) {  // newFills should be always 0th, or 1th length. \n         fillFaces.add(polygon);\n      }\n\n      // separation will be selected.\n      if (separate !== this) {\n         ret.separateCages.push( separate );\n      }\n   }\n\n   return ret;\n};\n\nPreviewCage.prototype.undoLoopCut = function(undo) {\n   // merge back to this\n   this.merge(undo.separateCages);\n\n   // remove fillFaces\n   for (let polygon of undo.fillFaces) {\n      this.geometry.removePolygon(polygon);\n   }\n\n   // weldContour back\n   for (let edgeLoop of undo.contourLoops) {\n      this.geometry.weldContour(edgeLoop);\n   }\n\n   // reSelect edges.\n   for (let wEdge of undo.selectedSet) {\n      this.selectEdge(wEdge.left);\n   }\n};\n\n\n// the real workhorse.\nPreviewCage.prototype._putOn = function(target) {\n   let fromFace = this.selectedSet.values().next().value; // must be true\n\n   const center = this.bench.boundingSpheres[fromFace.index].center;\n   const normal = vec3.create();\n   vec3.copy(normal, fromFace.normal);\n   vec3.negate(normal, normal);\n\n   const rotAxis = mat4.create();\n   _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"rotationFromToVec3\"](rotAxis, normal, target.normal);\n   \n   const transform = mat4.create();\n   mat4.fromTranslation(transform, target.center);\n   mat4.mul(transform, transform, rotAxis);\n   vec3.negate(center, center);\n   const centerTransform = mat4.create();\n   mat4.fromTranslation(centerTransform, center);\n   mat4.mul(transform, transform, centerTransform);\n\n   // now transform all vertex\n   for (let vertex of this.geometry.vertices) {\n      vec3.transformMat4(vertex.vertex, vertex.vertex, transform);\n      this.geometry.addAffectedVertex(vertex);\n      this.geometry.addAffectedEdgeAndFace(vertex);\n   }\n   // now transform all normal\n   for (let face of this.geometry.faces) {\n      vec3.transformMat4(face.normal, face.normal, rotAxis);\n   }\n\n   this._updatePreviewAll();\n};\n\n\nPreviewCage.prototype.putOnVertex = function(vertex) {\n   const normal = vec3.create();\n   vertex.getNormal(normal);\n\n   this._putOn({normal: normal, center: vertex.vertex});\n};\n\nPreviewCage.prototype.putOnEdge = function(hEdge) {\n   const normal = vec3.create();\n   hEdge.wingedEdge.getNormal(normal);\n   const center = vec3.create();\n   vec3.add(center, hEdge.origin.vertex, hEdge.destination().vertex);\n   vec3.scale(center, center, 0.5);\n\n   this._putOn({normal: normal, center: center});\n};\n\nPreviewCage.prototype.putOnFace = function(polygon) {\n   const normal = polygon.normal;\n   const center = this.bench.boundingSpheres[polygon.index].center;\n   \n   this._putOn({normal:normal, center: center});\n};\n\n\nPreviewCage.prototype.getSelectedFaceContours = function() {\n   let contours = {};\n   contours.edgeLoops = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findContours(this.selectedSet);\n\n   contours.edges = new Set;\n   // copy to a set, so searching is easier.\n   for (let edgeLoop of contours.edgeLoops) {\n      for (let edge of edgeLoop) {\n         contours.edges.add(edge.outer.wingedEdge);\n      }\n   }\n\n   return contours;\n};\n\nPreviewCage.prototype.liftFace = function(contours, hingeHEdge) {\n   // extrude edges\n   contours.edgeLoops = this.geometry.liftContours(contours.edgeLoops);\n   contours.extrudeEdges = this.geometry.extrudeContours(contours.edgeLoops);\n   \n   this._updatePreviewAll();\n   // collapse hEdgeHinge\n   const length = contours.extrudeEdges.length\n   for (let i = 0; i < length; ++i) {\n      const hEdge = contours.extrudeEdges[i];\n      if (hEdge.next.wingedEdge === hingeHEdge.wingedEdge) {\n         this.geometry.collapseEdge(hEdge);\n         if (i === length-1) {\n            this.geometry.collapseEdge(contours.extrudeEdges[0]);\n            contours.extrudeEdges = contours.extrudeEdges.slice(1, length-1); // remove collapseEdges\n         } else {\n            this.geometry.collapseEdge(contours.extrudeEdges[i+1]);\n            contours.extrudeEdges.splice(i, 2);     // remove collapseEdges\n         }\n         break;\n      }\n   }\n\n   // reselect face, due to rendering requirement\n   this._updatePreviewAll();\n   // reselect face\n   const oldSelected = this._resetSelectFace();\n   for (let polygon of oldSelected.selectedFaces) {\n      this.selectFace(polygon);\n   }\n\n   return contours;\n};\n\n\n//\n// mirror object, select polygon will become hole and connect the mirror object to original object\n//\nPreviewCage.prototype.mirrorFace = function() {\n   const selectedPolygons = this.getSelectedSorted();\n\n   const mirrorMat = mat4.create();\n   const protectVertex = new Set;\n   const protectWEdge = new Set;\n   const uniqueVertex = new Map;\n   function resetAddVertex(targetFace) {\n      uniqueVertex.clear();\n      for (let hEdge of targetFace.hEdges()) {\n         uniqueVertex.set(hEdge.origin, hEdge.origin);   // targetFace's pts are shared to the newly mirror faces.\n         protectVertex.add(hEdge.origin);\n         protectWEdge.add(hEdge.wingedEdge);\n      }\n      _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"reflectionMat4\"](mirrorMat, targetFace.normal, targetFace.halfEdge.origin.vertex);\n   };\n   const addVertex = (vertex) => {\n      let pt = uniqueVertex.get(vertex);\n      if (!pt) {\n         pt = this.geometry.addVertex(vertex.vertex);\n         vec3.transformMat4(pt.vertex, pt.vertex, mirrorMat);\n         uniqueVertex.set(vertex, pt);\n      }\n      return pt.index;\n   };\n\n   const originalFaces = Array.from(this.geometry.faces);\n   const newGroups = [];\n   for (let target of selectedPolygons) {\n      resetAddVertex(target);\n      const newPolygons = [];\n      for (let polygon of originalFaces) {\n         if (polygon !== target) {  // add polygon\n            const ptsLoop = [];\n            for (let hEdge of polygon.hEdges()) {\n               ptsLoop.push( addVertex(hEdge.origin) );\n            }\n            ptsLoop.reverse();   // new face is invert\n            newPolygons.push( ptsLoop );\n         }\n      }\n      newGroups.push( newPolygons );\n   }\n\n         \n   this._updatePreviewAll();  // temp Fix: needs to update Preview before holeSelectedFace\n   // now we can safely create new polygons to connect everything together\n   const mirrorGroups = [];\n   for (let i = 0; i < selectedPolygons.length; ++i) {\n      const polygon = selectedPolygons[i];\n      this.selectFace(polygon);\n      const holed = this.geometry.makeHole(polygon);   // remove selected polygon so mirror face connect through\n      const newPolygons = newGroups[i];\n      const newMirrors = [];\n      for (let ptsLoop of newPolygons) {\n         newMirrors.push( this.geometry.addPolygon(ptsLoop) );\n      }\n      mirrorGroups.push( {holed: holed, newMirrors: newMirrors} );\n   }\n\n   this._updatePreviewAll();\n\n   return {mirrorGroups: mirrorGroups, protectVertex: protectVertex, protectWEdge: protectWEdge};\n}\n\nPreviewCage.prototype.undoMirrorFace = function(undoMirror) {\n   for (let undo of undoMirror.mirrorGroups) {\n      const wEdges = new Set();\n      for (let polygon of undo.newMirrors) {\n         for (let hEdge of polygon.hEdges()) {\n            if (!undoMirror.protectVertex.has(hEdge.origin)) {\n               this.geometry._freeVertex(hEdge.origin);\n            }\n            if (undoMirror.protectWEdge.has(hEdge.wingedEdge)) {\n               hEdge.next = hEdge.next.pair.next;     // hacky: restore to original connection.\n            } else {\n               wEdges.add( hEdge.wingedEdge );\n            }\n         }\n         this.geometry._freePolygon(polygon);\n      }\n      for (let wEdge of wEdges) {\n         this.geometry._freeEdge(wEdge.left);\n      }\n      // restore hole\n      this.undoHoleSelectedFace([undo.holed]);\n   }\n   this._updatePreviewAll();\n};\n\n\nPreviewCage.prototype.cornerEdge = function() {\n   const selectedEdge = this.getSelectedSorted();\n\n   const faces = [];\n   const vertices = [];\n   const splitEdges = [];\n   const dissolveEdges = [];\n   const vertex = vec3.create();\n   for (let wEdge of selectedEdge) {\n      let three;\n      let five = wEdge.left;\n      if (five.face) {\n         if (five.face.numberOfVertex == 5) {\n            three = wEdge.right;\n            if (three.face && (three.face.numberOfVertex !== 3)) {\n               three = null;\n            }\n         } else if (five.face.numberOfVertex === 3) {\n            three = five;\n            five = wEdge.right;\n            if (five.face && (five.face.numberOfVertex !== 5)) {\n               five = null;\n            }\n         }\n      }\n      if (three && five) {\n         faces.push( three.face );\n         faces.push( five.face );\n         // insert mid point at wEdge.\n         vec3.add(vertex, three.origin.vertex, five.origin.vertex);\n         vec3.scale(vertex, vertex, 0.5);\n         let outEdge = this.geometry.splitEdge(five, vertex);\n         vertices.push(five.origin);\n         splitEdges.push(outEdge.pair);\n         // insert edge from mid-pt to five's diagonal point.\n         let connectOut = this.geometry.insertEdge(outEdge, five.next.next.next);\n         dissolveEdges.push(connectOut.pair);\n         faces.push(connectOut.face);\n      }\n   }\n   // compute direction, and copy position.\n   let count = 0;\n   let direction = new Float32Array(dissolveEdges.length*3);\n   for (let connect of dissolveEdges) {\n      const dir = direction.subarray(count, count+3);\n      vec3.sub(dir, connect.origin.vertex, connect.destination().vertex);\n      vec3.normalize(dir, dir);\n      count += 3;\n   }\n   const ret = this.snapshotPosition(vertices, direction);\n   this._updatePreviewAll();\n   // reselect splitEdges\n   for (let hEdge of splitEdges) {\n      this.selectEdge(hEdge);\n   }\n\n   // undo stuff\n   ret.splitEdges = splitEdges;\n   ret.dissolveEdges = dissolveEdges;\n   return ret; \n};\nPreviewCage.prototype.undoCornerEdge = function(undo) {\n   // dissolveEdges first\n   for (let hEdge of undo.dissolveEdges) {\n      this.geometry.removeEdge(hEdge);\n   }\n\n   // unselect the splitEdges then restore to original situation\n   for (let hEdge of undo.splitEdges) {\n      this.selectEdge(hEdge);\n      this.geometry.collapseEdge(hEdge);\n   }\n   this._updatePreviewAll();\n}\n\nPreviewCage.prototype.slideEdge = function() {\n   const selection = this.snapshotSelectionEdge();\n\n   const sixAxis = [[0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, -1], [0, -1, 0], [-1, 0, 0]];\n   const vertices = new Map;\n   const pt = vec3.create();\n   for (let wEdge of selection.wingedEdges) {\n      for (let hEdge of wEdge) {\n         // compute the direction\n         let dir = vertices.get(hEdge.origin);\n         if (!dir) {\n            dir = {positive: vec3.create(), negative: vec3.create()};\n            vertices.set(hEdge.origin, dir);\n         }\n         const prev = hEdge.prev();\n         const next = hEdge.pair.next;\n         // compute which quadrant, pt(normal) is normalized.\n         _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"computeEdgeNormal\"](pt, next, prev.pair);\n         let max;\n         let index;\n         for (let i = 0; i < 6; ++i) {\n            let axis = sixAxis[i];\n            let angle =  vec3.dot(axis, pt);\n            if (i === 0) {\n               max = angle;\n               index = 0;\n            } else if (max < angle) {\n               max = angle;\n               index = i;\n            }\n         }\n         // now compute the dir\n         if (index > 2) {   // check if needs to reverse negative and positive.\n            vec3.sub(pt, hEdge.origin.vertex, prev.origin.vertex);\n            vec3.add(dir.negative, dir.negative, pt);\n            vec3.sub(pt, next.destination().vertex, next.origin.vertex);\n            vec3.add(dir.positive, dir.positive, pt);\n         } else {\n            vec3.sub(pt, prev.origin.vertex, hEdge.origin.vertex);\n            vec3.add(dir.positive, dir.positive, pt);\n            vec3.sub(pt, next.origin.vertex, next.destination().vertex);\n            vec3.add(dir.negative, dir.negative, pt);\n         }\n      }\n   }\n\n   // copy to array and normalize.\n   let count = 0;\n   const retVertices = [];\n   const positiveDir = new Float32Array(vertices.size*3);\n   const negativeDir = new Float32Array(vertices.size*3);\n   for (const [vertex, dir] of vertices) {\n      retVertices.push( vertex );\n      const positive = positiveDir.subarray(count, count+3);\n      vec3.copy(positive, dir.positive);\n      vec3.normalize(positive, positive);\n      const negative = negativeDir.subarray(count, count+3);\n      vec3.copy(negative, dir.negative);\n      vec3.normalize(negative, negative);\n      count += 3;\n   }\n\n   const ret = this.snapshotPosition(retVertices, positiveDir);\n   ret.directionPositive = positiveDir;\n   ret.directionNegative = negativeDir;\n\n   return ret;\n};\nPreviewCage.prototype.positiveDirection = function(snapshot) {\n   snapshot.direction = snapshot.directionPositive;\n};\nPreviewCage.prototype.negativeDirection = function(snapshot) {\n   snapshot.direction = snapshot.directionNegative;\n};\n\n\n// flatten\nPreviewCage.prototype.flattenEdge = function(axis) {\n   // first snapshot original position\n   const ret = this.snapshotEdgePosition();\n\n   // project onto axis.\n   const center = vec3.create();\n   const vertices = new Set;\n   const edgeGroups = this.geometry.findEdgeGroup(this.getSelectedSorted());\n   for (let group of edgeGroups) {\n      // compute center of a plane\n      vertices.clear();\n      vec3.set(center, 0, 0, 0);\n      for (let wEdge of group) { // compute center.\n         for (let hEdge of wEdge) {\n            if (!vertices.has(hEdge.origin)) {\n               vec3.add(center, center, hEdge.origin.vertex);\n               vertices.add(hEdge.origin);\n               this.geometry.addAffectedEdgeAndFace(hEdge.origin);\n            }\n         }\n      }\n      vec3.scale(center, center, 1/vertices.size);\n      // now project all vertex to (axis, center) plane.\n      _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"projectVec3\"](vertices, axis, center);\n   }\n\n\n   this._updatePreviewAll();\n   return ret;\n};\n\n\n// add group normal if planeNormal not present.\nPreviewCage.prototype.flattenFace = function(planeNormal) {\n   // first snapshot original position.\n   const ret = this.snapshotFacePosition();\n\n   const faceGroups = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findFaceGroup(this.getSelectedSorted());\n   const center = vec3.create();\n   const vertices = new Set;\n   let normal = planeNormal;\n   if (!planeNormal) {\n      normal = vec3.create();\n   }\n   for (let group of faceGroups) {\n      vertices.clear();\n      vec3.set(center, 0, 0, 0);\n      for (let face of group) {\n         for (let hEdge of face.hEdges()) {\n            if (!vertices.has(hEdge.origin)) {\n               vertices.add(hEdge.origin);\n               vec3.add(center, center, hEdge.origin.vertex);\n               this.geometry.addAffectedEdgeAndFace(hEdge.origin);\n            }\n         }\n         if (!planeNormal) {\n            vec3.add(normal, normal, face.normal);\n         }\n      }\n      vec3.scale(center, center, 1/vertices.size);\n      if (!planeNormal) {\n         vec3.normalize(normal, normal);\n      }\n      _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"projectVec3\"](vertices, normal, center);\n   }\n\n   this._updatePreviewAll();\n   return ret;\n};\n\n\nPreviewCage.prototype.flattenVertex = function(planeNormal) {\n   if (this.selectedSet.size > 1) { // needs at least 2 vertex to get a center.\n      const selectedVertices = this.getSelectedSorted();\n      const ret = this.snapshotVertexPosition();\n\n      const center = vec3.create();\n      for (let vertex of selectedVertices) {\n         vec3.add(center, center, vertex.vertex);\n         this.geometry.addAffectedEdgeAndFace(vertex);\n      }\n      vec3.scale(center, center, 1/selectedVertices.length);\n      _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"projectVec3\"](selectedVertices, planeNormal, center);\n\n      this._updatePreviewAll();\n\n      return ret;\n   }\n   return null;\n};\n\n\n// check if given plane can cut selected face. coplanar does not count.\nPreviewCage.prototype.planeCuttableFace = function(plane) {\n   for (let sphere of this.bvh.root.intersectBound(plane)) {\n      if (this.selectedSet.has(sphere.polygon)) {\n         // now, check hEdge against plane.\n         for (let hEdge of sphere.polygon.hEdges()) {\n            const t = _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"intersectPlaneHEdge\"](null, plane, hEdge);\n            if ((t>0) && (t<1)) {   // intersection at begin or end don't count\n               return true;\n            }\n         }\n      }\n   }\n   return false;\n};\n\n// cut the selected by the given plane, and reconnect\nPreviewCage.prototype._planeCutFace = function(cutPlanes) {\n   const selectedVertex = new Set;\n   const splitEdges = [];\n   const pt = vec3.create();\n   for (let plane of cutPlanes) {\n      const cutList = [];\n      for (let sphere of this.bvh.root.intersectBound(plane)) {\n         if (this.selectedSet.has(sphere.polygon)) {\n            cutList.push(sphere.polygon);\n         }\n      }\n\n      // sort cutList, guarantee ordering.\n      cutList.sort( (a,b)=> { return a.index - b.index;} );\n\n      // now cut, and select vertex for later connect phase.\n      const cuthEdgeList = [];\n      const wEdgeList = new Set;\n      for (let polygon of cutList) {\n         for (let hEdge of polygon.hEdges()) {\n            if (!wEdgeList.has(hEdge.wingedEdge)) {\n               cuthEdgeList.push(hEdge);\n               wEdgeList.add(hEdge.wingedEdge);\n            }\n         }\n      }\n      for (let hEdge of cuthEdgeList) {   // only iterate once for every potentail edges\n         const t = _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"intersectPlaneHEdge\"](pt, plane, hEdge);\n         if (t == 0) {  // select origin\n            selectedVertex.add( hEdge.origin );\n         } else if ( (t>0) && (t<1)) { // spliEdge, and select\n            let newOut = this.geometry.splitEdge(hEdge, pt);   // pt is the split point.\n            splitEdges.push( newOut.pair );\n            selectedVertex.add( hEdge.origin );\n         }\n      }\n   }\n   this._updatePreviewAll();  // update drawing buffer.\n   return {selectedFaces: this.selectedSet, vertices: selectedVertex, halfEdges: splitEdges};\n};\n\nPreviewCage.prototype.planeCutFace = function(plane) {\n   return this._planeCutFace([plane]);\n};\n\nPreviewCage.prototype.planeCutBody = function(plane) {\n   const result = this._planeCutFace([plane]);\n\n   // adjust result to body\n   return {body: result.selectedFaces, vertices: result.vertices, halfEdges: result.halfEdges};\n};\n\n\nPreviewCage.prototype.sliceBody = function(planeNormal, numberOfPart) {\n   // first get tight bounding box.\n   const min = vec3.fromValues(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n   const max = vec3.fromValues(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n   this.geometry.getExtent(min, max);\n   const size = vec3.create();\n   vec3.sub(size, max, min);\n   // find the number of cuts.\n   const cutPlanes = [];\n   const center = vec3.create();\n   const numberOfCuts = numberOfPart-1;\n   for (let i = 1; i <= numberOfCuts; ++i) {\n      vec3.lerp(center, min, max, i/(numberOfCuts+1));\n      cutPlanes.push( new _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_0__[\"Plane\"](planeNormal, center) );\n   }\n\n   // iterate through the cut\n   const result = this._planeCutFace(cutPlanes);\n\n   // adjust result to body\n   return {body: result.selectedFaces, vertices: result.vertices, halfEdges: result.halfEdges};\n};\n\n\nPreviewCage.prototype.getBodySelection = function(selection, extent) {\n   // first get extent size\n   this.geometry.getExtent(extent.min, extent.max);\n   // now push all faces's sphere.\n   for (let polygon of this.selectedSet) {\n      selection.push( this.bench.boundingSpheres[polygon.index] );\n   }\n};\n\n\n// make holes\nPreviewCage.prototype.makeHolesFromBB = function(selection) {\n   const restore = [];\n   for (let sphere of selection) {\n      this.selectedSet.delete(sphere.polygon);              // remove from selection. also selection off(not done)?\n      restore.unshift( this.geometry.makeHole(sphere.polygon) );  // restore has to be done in reverse\n   }\n   return restore;\n};\n\n\n// the real workhorse\nPreviewCage.findWeldContours = function(overlap) {\n   // combinedCages\n   const combinedCages = new Map;\n   const combines = [];\n   function combineCage(source, target) {\n      let cages;\n      if (source.cage === target.cage) {  // same cage\n         if (combinedCages.has(source.cage)) {\n            cages = combinedCages.get(source.cage);\n         } else {\n            cages = [];\n            combines.push( cages );\n            cages.push(source.cage);\n            combines.set(source.cage, cages);\n            combines.set(target.cage, cages);             \n         }\n      } else {\n         if (combinedCages.has(source.cage)) {\n            cages = combinedCages.get(source.cage);\n            if (!combinedCages.has(target.cage)) {\n               combinedCages.set(target.cage, cages);\n               cages.push( target.cage );\n            }\n         } else if (combinedCages.has(target.cage)) {\n            cages = combinedCages.get(target.cage);\n            combinedCages.set(source.cage, cages);\n            cages.push( source.cages );\n            loopUse.push();\n         } else {\n            cages = [];\n            combines.push( cages );\n            cages.push(source.cage, target.cage);\n            combinedCages.set(source.cage, cages);\n            combinedCages.set(target.cage, cages);\n         }\n      }     \n      return cages;\n   };\n   // find edgeLoops\n   const loopUsed = [];\n   const hEdge2Loop = new Map;\n   const edgeLoops = _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_1__[\"WingedTopology\"].findContours(overlap.selection);\n   // find inner, outer, then combined.\n   for (let edgeLoop of edgeLoops) {\n      const source = overlap.pair.get(edgeLoop[0].outer);\n      const target = overlap.pair.get(source.hEdge)\n      if (hEdge2Loop.has(source.hEdge)) { // now check if matching hEdge already saved\n         const result = hEdge2Loop.get(source.hEdge);\n         if (result.length === edgeLoop.length) {   // move hEdge to match and checked.\n            for (let i = 0; i < edgeLoop.length; ++i) {  // could not just loop both because they are in reverse order.\n               let inner = overlap.pair.get(edgeLoop[i].outer);  \n               if (!overlap.pair.has(inner.hEdge)) {// no matching not possible, bad\n                  return false;\n               }\n               edgeLoop[i].inner = inner.hEdge.pair;\n            } // ok, done\n            // now combined Cage\n            loopUsed.push( {combine: combineCage(source, target), edgeLoop: edgeLoop} );\n         } else { // bad match, could be 3+ cage involvement, don't handle it now.\n            return false;\n         }\n      } else { // save all to hEdge2Loop\n         for (let i = 0; i < edgeLoop.length; ++i) {\n            const outer = edgeLoop[i].outer;\n            hEdge2Loop.set(outer, edgeLoop);\n         }\n      } // also won't handle self weld contours.\n   }\n\n   return {combineCages: combines, edgeLoops: loopUsed};\n};\n\n\nPreviewCage.weldableFace = function(target, compare, tolerance) {\n   // check number of vertex\n   if (target.polygon.numberOfVertex !== compare.polygon.numberOfVertex) {\n      return false;\n   }\n   // check direction\n   if (vec3.dot(target.polygon.normal, compare.polygon.normal) > 0) {\n      return false;\n   }\n   // check center distance and radisu\n   const toleranceSquare = tolerance * tolerance;\n   if (vec3.sqrDist(target.center, compare.center) > toleranceSquare) {\n      return false;\n   }\n   if (Math.abs(target.radius - compare.radius) > tolerance) {\n      return false;\n   }\n   // check all vertex distance\n   const reverse2 = []; \n   for (let current2 of compare.polygon.hEdges()) {  // get reverse order\n      reverse2.unshift(current2);\n   }\n   for (let hEdge of target.polygon.hEdges()) {  // find the closest pair first\n      for (let i = 0; i < reverse2.length; ++i) {\n         let current = hEdge;\n         let current2 = reverse2[i];\n         let match = [];\n         let j = i;\n         do {  // iterated through the loop\n            if (vec3.sqrDist(current.origin.vertex, current2.destination().vertex) > toleranceSquare) {\n               match = undefined;\n               break;\n            }\n            match.push( {target: current, source: current2} );\n            current = current.next;\n            j = (++j)%reverse2.length;\n            current2 = reverse2[j];\n         } while (current !== hEdge);\n         if (match) {\n            return match;\n         }\n      }\n   }\n\n   return false;\n};\n\nPreviewCage.findOverlapFace = function(order, selection, tolerance) {\n   const merged = new Set;\n   const retSelection = new Set;\n   const pair = new Map;\n   for (let i = 0; i < selection.length; ++i) {  // walk through the whole list\n      const target = selection[i];\n      if (!merged.has(target)) {\n         for (let j = i+1; j < selection.length; j++) {// walk till the end, or \n            const compare = selection[j];\n            if (compare.isLive() && !merged.has(compare)) {\n               if (Math.abs(target.center[order[0]]-compare.center[order[0]]) > tolerance) {  // out of bounds\n                  break;\n               }\n                // weld compare to target if possibled\n               const weld = PreviewCage.weldableFace(target, compare, tolerance);  // weldable\n               if (weld) {\n                  merged.add(compare);\n                  merged.add(target);\n                  retSelection.add(compare.polygon);\n                  retSelection.add(target.polygon);\n                  for (let match of weld) {                     \n                     pair.set(match.target, {hEdge: match.source, cage: compare.octree.bvh});\n                     pair.set(match.source, {hEdge: match.target, cage: target.octree.bvh});\n                  }\n               }\n            }\n         }\n      }\n   }\n   return {pair: pair, merged: merged, selection: retSelection};\n};\n\n// get the merged sphere, and remove the polygon.\nPreviewCage.weldHole = function(merged) {\n   const holesOfCages = new Map;\n   for (let sphere of merged.merged) { // sort holes to cages.\n      let holes = holesOfCages.get(sphere.octree.bvh);\n      if (holes === undefined) {\n         holes = [];\n         holesOfCages.set(sphere.octree.bvh, holes);\n      }\n      holes.push(sphere);\n   }\n\n   // now remove holes from each cages.\n   const result = [];\n   for (let [cage, holes] of holesOfCages) {\n      result.push( [cage, cage.makeHolesFromBB(holes)] );\n      cage._updatePreviewAll();\n   }\n   return result;\n};\nPreviewCage.undoWeldHole = function(weldHoles) {\n   for (let [cage, holes] of weldHoles) {\n      for (let restore of holes) {\n         cage.geometry.undoHole(restore);\n      }\n      cage._updatePreviewAll();\n   }\n};\n\nPreviewCage.weldBody = function(combines, weldContours) {\n   const result = [];\n   // then weld contour.\n   for (let {combine, edgeLoop} of weldContours.edgeLoops) {\n      const cage = combines.get(combine);\n      cage.combine.geometry.weldContour(edgeLoop);\n      cage.combine._updatePreviewAll();\n      // compute snapshot\n      cage.preview = cage.combine;  // smuglling snapshot. should we rename (combine to preview)?\n      if (!cage.snapshot) {\n         cage.snapshot = {vertices: new Set};\n      }\n      for (let edge of edgeLoop) {\n         cage.snapshot.vertices.add(edge.outer.origin);\n      }\n      // weldContour saved restore info\n      result.push( [cage.preview, edgeLoop] );\n   }\n   return result;\n};\nPreviewCage.undoWeldBody = function(weldContours) {\n   for (let [cage, edgeLoop] of weldContours) {\n      cage.geometry.restoreContour(edgeLoop);   // liftContour will restore innerLoop for us\n      cage._updatePreviewAll();\n   }\n};\n\n/**\n * change selectedEdge's state\n * @param {number} operand - 0=soft, 1=hard, 2=invert \n */\nPreviewCage.prototype.hardnessEdge = function(operand) {\n   let ret = {operand: operand, selection: []};\n\n   for (let wEdge of this.selectedSet) {\n      if (this.bench.setHardness(wEdge, operand)) {   // check set successfully\n         ret.selection.push(wEdge);\n      }\n   }\n   // return ret\n   if (ret.selection.length > 0) {\n      return ret;\n   } else {\n      return null;\n   }\n};\n\n/**\n * restore selection's edge state\n * @param {number} operand - 0=soft, 1=hard, 2=invert\n * @param {array} selection - the edges that needs to restore\n */\nPreviewCage.prototype.undoHardnessEdge = function(result) {\n   let operand = result.operand;\n   if (operand === 0) { // soft restore to hard\n      operand = 1;\n   } else if (operand === 1) {   // hard restore to soft\n      operand = 0;\n   }\n   for (let wEdge of result.selection) {   // restore edges state\n      this.bench.setHardness(wEdge, operand);\n   }\n};\n\n//----------------------------------------------------------------------------------------------------------\n\n\n\nclass CreatePreviewCageCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(previewCage) {\n      super();\n      this.previewCage = previewCage;\n   }\n\n   free() {\n      this.previewCage.freeBuffer();\n   }\n\n   doIt() {\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"addToWorld\"](this.previewCage);\n   }\n\n   undo() {\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_2__[\"removeFromWorld\"](this.previewCage);\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_model.js?");

/***/ }),

/***/ "./js/wings3d_multimads.js":
/*!*********************************!*\
  !*** ./js/wings3d_multimads.js ***!
  \*********************************/
/*! exports provided: MultiMadsor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiMadsor\", function() { return MultiMadsor; });\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/* harmony import */ var _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_facemads */ \"./js/wings3d_facemads.js\");\n/* harmony import */ var _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_edgemads */ \"./js/wings3d_edgemads.js\");\n/* harmony import */ var _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_vertexmads */ \"./js/wings3d_vertexmads.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/*\n *\n * MADS (Modify, Add, Delete, Select) operation. only toggling function\n *\n**/\n\n\n\n\n\n\n\n\n\n\nclass MultiMadsor extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"Madsor\"] {\n   constructor() {\n      super('Multi');\n   }\n\n   isFaceSelectable() { return true; }\n   isEdgeSelectable() { return true; }\n   isVertexSelectable() { return true; }\n\n   toggleMulti(hilite) {\n      if (hilite.face) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"toggleFaceMode\"]();\n      } else if (hilite.vertex) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"toggleVertexMode\"]();\n      } else {    // if (hilite.edge) {   \n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"toggleEdgeMode\"]();\n      } // not body possible.\n   }\n\n   toggleFunc(toMadsor) {\n      let redoFn;\n      let snapshots;\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.changeFromMultiToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.changeFromMultiToVertexSelect);\n      } else if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_2__[\"EdgeMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.changeFromMultiToEdgeSelect);\n      } else { // bodyMadsor\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.changeFromMultiToBodySelect);\n      }\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"ToggleModeCommand\"](redoFn, _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreMultiMode\"], snapshots));\n   }\n\n   restoreMode(toMadsor, snapshots) {\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.restoreFromMultiToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_3__[\"VertexMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.restoreFromMultiToVertexSelect);\n      } else if (toMadsor instanceof EdgeVertex) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.restoreFromMultiToEdgeSelect);\n      } else {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_4__[\"PreviewCage\"].prototype.restoreFromMultiToBodySelect);      \n      }\n   }\n\n   drawExtra(_gl, _draftBench) {\n      // no hilite\n   }\n};\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_multimads.js?");

/***/ }),

/***/ "./js/wings3d_render.js":
/*!******************************!*\
  !*** ./js/wings3d_render.js ***!
  \******************************/
/*! exports provided: renderText, needToRedraw, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderText\", function() { return renderText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"needToRedraw\", function() { return needToRedraw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony import */ var _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_gl */ \"./js/wings3d_gl.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_camera */ \"./js/wings3d_camera.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/*\n//    Render all objects and helpers (such as axes) in the scene.\n//     Used for the Geometry and AutoUV windows.\n//\n//  Original Erlang Version: Bjorn Gustavsson\n*/\n\n\n\n\n\n\n\n\n\n// my.shader = initShaders();\n// wings_pref:set_default(multisample, true), <- why set default here? shouldn't bunch of defaults set together?\n// initPolygonStipple(); no webgl support. shader replacement? ignore for now\nlet lineProg;        // to be replaced\nlet groundAxisProg;  // to be replaced\nlet textProg;        // to be replaced\n\nObject(_wings3d__WEBPACK_IMPORTED_MODULE_3__[\"onReady\"])(function() {\n   redrawFlag = true;\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].enable(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].DEPTH_TEST);\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].enable(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].CULL_FACE);   // enable cull face (2018-05-30) back face culling is default\n   // initialized glsl program, update data\n   // program source ShaderProg\n   // drawGrid, using LineProgram\n   // compile and link program\n   lineProg = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"uColorArray\"].vertexShader, _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"uColorArray\"].fragShader);\n\n   // compile and link program.\n   groundAxisProg = {handle: _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].compileGLSL(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"colorArray\"].vertexShader, _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"colorArray\"].fragShader)};\n\n   // get attribute handle.\n   groundAxisProg.vertexPosition = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getAttribLocation(groundAxisProg.handle, \"aVertexPosition\");\n   groundAxisProg.vertexColor = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getAttribLocation(groundAxisProg.handle, \"aVertexColor\");\n   groundAxisProg.uPMatrix = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getUniformLocation(groundAxisProg.handle, \"uPMatrix\");\n   groundAxisProg.uMVMatrix = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getUniformLocation(groundAxisProg.handle, \"uMVMatrix\");\n\n   // compute grid and axis, and write to vbo.\n   var mat = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"loadMatrices\"](true);\n   var yon = computeGroundAndAxes(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"], mat.projection, mat.modelView);    \n   initMiniAxis(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"], mat.modelView);\n\n   // init simpleText.\n   // compile and link program.\n   textProg = {handle: _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].compileGLSL(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"textArray\"].vertexShader, _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_4__[\"textArray\"].fragShader)};\n\n   // get attribute handle.\n   textProg.vertexPosition = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getAttribLocation(textProg.handle, \"aVertexPosition\");\n   textProg.texCoord = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getAttribLocation(textProg.handle, \"aTexCoord\");\n   textProg.uMVMatrix = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getUniformLocation(textProg.handle, \"uMVMatrix\");\n   textProg.uPMatrix = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getUniformLocation(textProg.handle, \"uPMatrix\");\n   textProg.uTexture = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].getUniformLocation(textProg.handle, \"u_texture\");\n   \n   initSimpleASCII(_wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"]);\n\n //  console.log(\"Render.init() success\");\n});\n\n\n\nfunction makeVerticesForString(s) {\n   var len = s.length;\n   var numVertices = len * 6;\n   var positions = textProg.bitmapTextVBO.verticesData;\n   var texcoords = textProg.bitmapTextVBO.texCoordData;\n   var numElements = positions.length / 2;\n   if (numVertices > numElements) {\n      // reallocated\n      positions = new Float32Array(numVertices * 2);\n      texcoords = new Float32Array(numVertices * 2);\n   }\n\n   var offset = 0;\n   var x = 0;\n   var maxX = textProg.bitmapTextVBO.fontInfo.textureWidth;\n   var maxY = textProg.bitmapTextVBO.fontInfo.textureHeight;\n   for (var ii = 0; ii < len; ++ii) {\n      var letter = s[ii];\n      var glyphInfo = textProg.bitmapTextVBO.fontInfo.glyphInfos[letter];\n      if (glyphInfo) {\n         var x2 = x + glyphInfo.width;\n         var u1 = glyphInfo.x / maxX;\n         var v1 = (glyphInfo.y + textProg.bitmapTextVBO.fontInfo.letterHeight - 1) / maxY;\n         var u2 = (glyphInfo.x + glyphInfo.width - 1) / maxX;\n         var v2 = glyphInfo.y / maxY;\n\n         // 6 vertices per letter, instead triangle strip, we use triangle, single call to webgl, faster that way.\n         positions[offset + 0] = x;\n         positions[offset + 1] = 0;\n         texcoords[offset + 0] = u1;\n         texcoords[offset + 1] = v1;\n\n         positions[offset + 2] = x2;\n         positions[offset + 3] = 0;\n         texcoords[offset + 2] = u2;\n         texcoords[offset + 3] = v1;\n\n         positions[offset + 4] = x;\n         positions[offset + 5] = textProg.bitmapTextVBO.fontInfo.letterHeight;\n         texcoords[offset + 4] = u1;\n         texcoords[offset + 5] = v2;\n\n         positions[offset + 6] = x;\n         positions[offset + 7] = textProg.bitmapTextVBO.fontInfo.letterHeight;\n         texcoords[offset + 6] = u1;\n         texcoords[offset + 7] = v2;\n\n         positions[offset + 8] = x2;\n         positions[offset + 9] = 0;\n         texcoords[offset + 8] = u2;\n         texcoords[offset + 9] = v1;\n\n         positions[offset + 10] = x2;\n         positions[offset + 11] = textProg.bitmapTextVBO.fontInfo.letterHeight;\n         texcoords[offset + 10] = u2;\n         texcoords[offset + 11] = v2;\n\n         x += glyphInfo.width + textProg.bitmapTextVBO.fontInfo.spacing;\n         offset += 12;\n      } else {\n         // we don't have this character so just advance\n         x += textProg.bitmapTextVBO.fontInfo.spaceWidth;\n      }\n   }\n\n   // return ArrayBufferViews for the portion of the TypedArrays\n   // that were actually used.\n   textProg.bitmapTextVBO.verticesData = positions;\n   textProg.bitmapTextVBO.texCoordData = texcoords;\n   textProg.bitmapTextVBO.numElements = offset / 2;\n}\n// \nfunction renderText(gl, x, y, color, s) {\n   gl.useProgram(textProg.handle);\n   gl.setBufferAndAttrib(textProg.bitmapTextVBO.position, textProg.vertexPosition, 2);\n   gl.setBufferAndAttrib(textProg.bitmapTextVBO.texCoord, textProg.texCoord, 2);\n\n   makeVerticesForString(s);\n\n   // update the buffers\n   gl.bindBuffer(gl.ARRAY_BUFFER, textProg.bitmapTextVBO.position);\n   gl.bufferData(gl.ARRAY_BUFFER, textProg.bitmapTextVBO.verticesData, gl.DYNAMIC_DRAW);\n   gl.bindBuffer(gl.ARRAY_BUFFER, textProg.bitmapTextVBO.texCoord);\n   gl.bufferData(gl.ARRAY_BUFFER, textProg.bitmapTextVBO.texCoordData, gl.DYNAMIC_DRAW);\n\n   // setup modelView\n   textProg.bitmapTextVBO.modelView[12] = x;\n   textProg.bitmapTextVBO.modelView[13] = y;\n   textProg.bitmapTextVBO.modelView[14] = 0.0;\n   // set uniforms\n   gl.uniformMatrix4fv(textProg.uPMatrix, false, textProg.bitmapTextVBO.projection);\n   gl.uniformMatrix4fv(textProg.uMVMatrix, false, textProg.bitmapTextVBO.modelView);\n   gl.activeTexture(gl.TEXTURE0);\n   gl.bindTexture(gl.TEXTURE_2D, textProg.bitmapTextVBO.uTexture);\n   gl.uniform1i(textProg.uTexture, 0);\n\n   // Draw the text.\n   gl.drawArrays(gl.TRIANGLES, 0, textProg.bitmapTextVBO.numElements);\n};\n\nfunction initSimpleASCII(gl) {\n   var fontInfo = {\n      letterHeight: 8,\n      spaceWidth: 8,\n      spacing: -1,\n      textureWidth: 64,\n      textureHeight: 40,\n      glyphInfos: {\n         'a': { x:  0, y:  0, width: 8, }, 'b': { x:  8, y:  0, width: 8, }, \n         'c': { x: 16, y:  0, width: 8, }, 'd': { x: 24, y:  0, width: 8, },\n         'e': { x: 32, y:  0, width: 8, }, 'f': { x: 40, y:  0, width: 8, },\n         'g': { x: 48, y:  0, width: 8, }, 'h': { x: 56, y:  0, width: 8, },\n         'i': { x:  0, y:  8, width: 8, }, 'j': { x:  8, y:  8, width: 8, },\n         'k': { x: 16, y:  8, width: 8, }, 'l': { x: 24, y:  8, width: 8, },\n         'm': { x: 32, y:  8, width: 8, }, 'n': { x: 40, y:  8, width: 8, },\n         'o': { x: 48, y:  8, width: 8, }, 'p': { x: 56, y:  8, width: 8, },\n         'q': { x:  0, y: 16, width: 8, }, 'r': { x:  8, y: 16, width: 8, },\n         's': { x: 16, y: 16, width: 8, }, 't': { x: 24, y: 16, width: 8, },\n         'u': { x: 32, y: 16, width: 8, }, 'v': { x: 40, y: 16, width: 8, },\n         'w': { x: 48, y: 16, width: 8, }, 'x': { x: 56, y: 16, width: 8, },\n         'y': { x:  0, y: 24, width: 8, }, 'z': { x:  8, y: 24, width: 8, },\n         '0': { x: 16, y: 24, width: 8, }, '1': { x: 24, y: 24, width: 8, },\n         '2': { x: 32, y: 24, width: 8, }, '3': { x: 40, y: 24, width: 8, },\n         '4': { x: 48, y: 24, width: 8, }, '5': { x: 56, y: 24, width: 8, },\n         '6': { x:  0, y: 32, width: 8, }, '7': { x:  8, y: 32, width: 8, },\n         '8': { x: 16, y: 32, width: 8, }, '9': { x: 24, y: 32, width: 8, },\n         '-': { x: 32, y: 32, width: 8, }, '*': { x: 40, y: 32, width: 8, },\n         '!': { x: 48, y: 32, width: 8, }, '?': { x: 56, y: 32, width: 8, },\n      },\n   };\n\n   // ready VBO and Image.\n   var vertices = new Float32Array(8*6*2);\n   var texCoord = new Float32Array(8*6*2);\n  // Create a texture.\n   var glyphTex = gl.createTexture();\n   gl.bindTexture(gl.TEXTURE_2D, glyphTex);\n   // Fill the texture with a 1x1 blue pixel.\n   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\n   // Asynchronously load an image\n   var image = new Image();\n   image.src = \"../img/8x8-font.png\";\n   image.onload = function() {   // image loaded, copy it to the texture.\n      gl.bindTexture(gl.TEXTURE_2D, glyphTex);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n   };   \n   textProg.bitmapTextVBO = {\n      verticesData: vertices,\n      texCoordData: texCoord,\n      numElements: 0,\n      position: gl.createBufferHandle(vertices),\n      texCoord: gl.createBufferHandle(texCoord),\n      modelView: mat4.create(),\n      projection: mat4.create(),\n      uTexture: glyphTex,\n      fontInfo: fontInfo\n   };\n}\n\n// it seems erlang version use 2d(w) line - line intersection (wikipedia). \n// we changed it to blinn's homogenous clipping. we are only interest in clip to end-out region. \nfunction clipLine(pt0, pt1) {\n   var tIn = 0.0, tOut = 1.0, tHit;\n   // bc, boundary code.\n   var bc = {pt0: [pt0[3]+pt0[0], pt0[3]-pt0[0], pt0[3]+pt0[1], pt0[3]-pt0[1], pt0[3]+pt0[2], pt0[3]-pt0[2]],\n             pt1: [pt1[3]+pt1[0], pt1[3]-pt1[0], pt1[3]+pt1[1], pt1[3]-pt1[1], pt1[3]+pt1[2], pt1[3]-pt1[2]]};\n   var outCode = {pt0: 0, pt1: 0};\n   for (var i = 0; i < 6; ++i) {\n      var tmp = (bc.pt0[i] < 0) << i;\n      outCode.pt0 |= tmp;\n      outCode.pt1 |= (bc.pt1[i] < 0) << i;\n   }\n\n   if ((outCode.pt0 & outCode.pt1) != 0) { // trivial reject, both point outside the same plane\n      return false;\n   }\n   if ((outCode.pt0 | outCode.pt1) == 0) { // trivial accept\n      return true;\n   }\n   // now, do 3D line clipping\n   for (i=0; i < 6; i++) {  // clip against 6 planes\n      if (bc.pt1[i] < 0) {  // C is outside wall i (exit so tOut)\n         tHit = bc.pt0[i]/(bc.pt0[i] - bc.pt1[i]);      // calculate tHit\n         tOut = Math.min(tOut, tHit);\n      } else if(bc.pt0[i] < 0) { // A is outside wall I (enters so tIn)\n         tHit = bc.pt0[i]/(bc.pt0[i] - bc.pt1[i]);      // calculate tHit\n         tIn = Math.max(tIn, tHit);\n      }\n      if (tIn > tOut) {\n         return false; // CI is empty: early out\n      }\n   }\n\n   var tmp = vec4.create();  // stores homogeneous coordinates\n   if (outCode.pt0 != 0) { // A is outside: tIn has changed. Calculate A_chop\n      for (i = 0; i < 4; ++i) { // compute x, y, z, w component\n         tmp[i] = pt0[i] + tIn * (pt1[i] - pt0[i]);\n      }\n   }\n   if (outCode.pt1 != 0) { // C is outside: tOut has changed. Calculate C_chop\n      for (i = 0; i < 4; ++i) { // compute x, y, z, w component\n         pt1[i] = pt0[i] + tOut * (pt1[i] - pt0[i]);\n      }\n   }\n   pt0 = tmp;\n   return true; // some of the edges lie inside CVV\n};\n\nfunction renderASCII(gl, origin, end, c, color, viewport) {\n   if (clipLine(origin, end)) {\n      // line inside view volume\n      //console.log(end[0], end[1], end[2], end[3]);\n      var x = Math.trunc((0.5*end[0]/end[3]+0.5)*(viewport[2]-20) + 10);\n      var y = viewport[3] - Math.trunc((0.5*end[1]/end[3]+0.5)*(viewport[3]-16) + 7);\n      //console.log(\"x:\", x, \"y:\", y);\n      renderText(gl, x, y, color, c);\n   }\n};\n\nfunction renderAxisLetter(gl, zFar) {\n   if (_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"prop\"].showAxes){\n      var viewPort = gl.getViewport();\n      var start = vec4.fromValues(0.0, 0.0, 0.0, 1.0);\n      var origin = gl.transformVertex(start);\n\n      //gl:matrixMode(?GL_PROJECTION),\n      //gl:loadIdentity(),\n      //{_,_,W,H} = ViewPort,\n      //glu:ortho2D(0.0, W, H, 0.0, -1, 1);\n      mat4.ortho(textProg.bitmapTextVBO.projection, 0.0, viewPort[2], viewPort[3], 0.0, -1.0,  1.0);\n      //gl:matrixMode(?GL_MODELVIEW),\n      //gl:loadIdentity(),\n      zFar = zFar + _wings3d__WEBPACK_IMPORTED_MODULE_3__[\"GROUND_GRID_SIZE\"];\n      //gl:polygonMode(?GL_FRONT_AND_BACK, ?GL_FILL),\n      \n      var color = [_wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorX), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorY), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorZ)];\n      var endx = gl.transformVertex(vec4.fromValues(zFar, 0.0, 0.0, 1.0)), \n          endy = gl.transformVertex(vec4.fromValues(0.0, zFar, 0.0, 1.0)), \n          endz = gl.transformVertex(vec4.fromValues(0.0, 0.0, zFar, 1.0));\n      renderASCII(gl, origin, endx, 'x', color[0], viewPort);\n      renderASCII(gl, origin, endy, 'y', color[1], viewPort);\n      renderASCII(gl, origin, endz, 'z', color[2], viewPort);\n   }\n};\n\n// ignore along_axis for now. fixed it later when we get to set the preference.\nfunction initMiniAxis(gl, inModelView) {\n   //#view{along_axis=Along} = wings_view:current(),\n   // mini axis and arrow\n   var PA = 0.08, PB = 0.01;\n   var arry = [].concat(\n      [0.0, 0.0, 0.0], [0.1, 0.0, 0.0], // x\n      [0.0, 0.0, 0.0], [0.0, 0.1, 0.0], // y\n      [0.0, 0.0, 0.0], [0.0, 0.0, 0.1], // z\n      [ PA, 0.0, -PB], [0.1, 0.0, 0.0], [PA, 0.0,  PB], [0.1, 0.0, 0.0], // x arrow\n      [-PB,  PA, 0.0], [0.0, 0.1, 0.0], [PB,  PA, 0.0], [0.0, 0.1, 0.0], // y arrow\n      [-PB, 0.0,  PA], [0.0, 0.0, 0.1], [PB, 0.0,  PA], [0.0, 0.0, 0.1]   // z arrow\n   );\n   // ready color\n   var clr = [_wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorX), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorY), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorZ)];\n   var color = [], arrow = [];\n   for (var i=0; i< 3; ++i) {\n      color = color.concat(clr[i], clr[i]);\n      arrow = arrow.concat(clr[i], clr[i], clr[i], clr[i]);\n   }\n   color = color.concat(arrow);\n   // bindVBO\n   groundAxisProg.miniAxisVBO = {\n       position: gl.createBufferHandle(new Float32Array(arry)),\n       color: gl.createBufferHandle(new Float32Array(color)),\n       length: 3*2 + 3*4\n   };\n   // compute ortho projection, and modelView.\n   var ratio = gl.canvas.clientWidth / gl.canvas.clientHeight;\n   var modelView = mat4.clone(inModelView);\n   modelView[12] = 0.11-ratio;\n   modelView[13] = -1.0+0.11;\n   modelView[14] = 0.0;\n   groundAxisProg.miniAxisVBO.modelView = modelView;\n   groundAxisProg.miniAxisVBO.projection = mat4.create();\n   mat4.ortho(groundAxisProg.miniAxisVBO.projection, -ratio, ratio, -1.0, 1.0, 0.00001,  10000000.0);\n}\nfunction renderMiniAxis(gl, inModelView) {\n   if (_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"prop\"].miniAxis) {\n      var ratio = gl.canvas.clientWidth / gl.canvas.clientHeight;\n      // set current rotation.\n      var modelView = groundAxisProg.miniAxisVBO.modelView;\n      mat4.copy(modelView, inModelView);\n      modelView[12] = 0.11-ratio;\n      modelView[13] = -1.0+0.11;\n      modelView[14] = 0.0;\n      // save attribute\n      var length = groundAxisProg.miniAxisVBO.length;\n\n      // render mini axis, use groundAxisProg\n      gl.useProgram(groundAxisProg.handle);\n      // bind attribute, vertex, color, matrix\n      gl.uniformMatrix4fv(groundAxisProg.uPMatrix, false, groundAxisProg.miniAxisVBO.projection);\n      gl.uniformMatrix4fv(groundAxisProg.uMVMatrix, false, groundAxisProg.miniAxisVBO.modelView);\n      gl.setBufferAndAttrib(groundAxisProg.miniAxisVBO.position, groundAxisProg.vertexPosition);\n      gl.setBufferAndAttrib(groundAxisProg.miniAxisVBO.color, groundAxisProg.vertexColor);\n      // draw line segments\n      gl.drawArrays(gl.LINES, 0, length);\n      // pop attribute\n   }\n}\n// recompute groundplanegrid, given the size of grid. size is mutiple of GROUND_GRID_SIZE. default\n// GROUND_GRID_SIZE=1, so size=10, grid is 10x10.\nfunction computeGroundGrid(size, gridSize) {\n   var data = [];\n   for (var xz= size; xz > 0; xz-=gridSize) {\n      data = data.concat([xz, 0.0, size], [xz, 0.0, -size],\n                         [-xz, 0.0, size], [-xz, 0.0, -size],\n                         [size, 0.0, xz], [-size, 0.0, xz],\n                         [size, 0.0, -xz], [-size, 0.0, -xz]  \n                        );\n   }\n   // final x, z, axis lines.\n   return data.concat([0.0, 0.0, size], [0.0, 0.0, -size],\n                      [size, 0.0, 0.0], [-size, 0.0, 0.0]);\n}\nfunction calcGridSize(projection, modelView) {\n   var width = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].canvas.clientWidth;\n   var height = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].canvas.clientHeight;\n   var w1 = Math.max(width, height);// /2.0;\n   var coord = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].unProject(w1, 0.0, 0.0, modelView, projection, [0, 0, width, height]);\n   var ret = _wings3d__WEBPACK_IMPORTED_MODULE_3__[\"GROUND_GRID_SIZE\"] * \n           Math.max(Math.round(Math.max(Math.max(Math.abs(coord[0]), Math.abs(coord[1])), Math.abs(coord[2]))), 10.0);\n   // hacked an value that just cover the screen space.\n   ret *= width/height * 0.7;\n   return Math.round(ret);\n}\nfunction computeGroundAndAxes(gl, projection, modelView) {\n   var gridSize = calcGridSize(projection, modelView);\n   //console.log(\"gridsize \" + gridSize.toString());\n   var data = computeGroundGrid(gridSize, _wings3d__WEBPACK_IMPORTED_MODULE_3__[\"GROUND_GRID_SIZE\"]);\n   // bindVBO.\n   lineProg.groundGridVBO = {\n      position: gl.createBufferHandle(new Float32Array(data)),\n      length: data.length/3\n   };\n\n   // compute Axes, bindVBO.\n   groundAxisProg.axisVBO = {\n      position: gl.createBufferHandle(getAxis()),\n      color: gl.createBufferHandle(getAxisColor()),\n      length: 3*2*2\n   };\n\n   return gridSize;\n}\nfunction getAxis() {\n   var yon = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].zFar;\n   var arry = [[yon, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [-yon, 0.0, 0.0], \n               [0.0, yon, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, -yon, 0.0],\n               [0.0, 0.0, yon], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, -yon]];\n   return new Float32Array([].concat.apply([],arry));\n}\nfunction getAxisColor() {\n    const color = [_wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorX), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorY), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].colorZ)],\n       negColor = [_wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].negColorX), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].negColorY), _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGB\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].negColorZ)];\n   var arry = [];\n   for (var i = 0; i < 3; i++) {\n      arry = arry.concat(color[i], color[i], negColor[i], negColor[i]);\n   }\n   return new Float32Array(arry);\n}\nfunction renderGroundAndAxes(gl, projection, modelView) {\n   const showAxes = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"prop\"].showAxes;\n   // draw groundPlane\n   const show = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"prop\"].showGroundplane; // || \n      //(wings_pref:get_value(force_show_along_grid) andalso\n      //(Camera.view.alongAxis =/= none);      \n   if (show) {\n      var alongAxis = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].alongAxis;\n      const color = _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGBA\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].gridColor);\n         //case view.AlongAxis of\n         // x -> gl:rotatef(90.0, 0.0, 1.0, 0.0);\n         // z -> ok;\n         // _ -> gl:rotatef(90.0, 1.0, 0.0, 0.0)\n      var length = lineProg.groundGridVBO.length;\n      if (showAxes) {\n         length -= 4;            // skip the axes line\n      }\n      // data\n      // use line segment program\n      gl.useProgram(lineProg.progHandle);\n      // bind attribute, vertex, color, matrix\n      gl.setBufferAndAttrib(lineProg.groundGridVBO.position, lineProg.attribute.position.loc);\n      gl.uniform4fv(lineProg.uniform.uColor.loc, color);\n      gl.uniformMatrix4fv(lineProg.transform.projection, false, projection);\n      gl.uniformMatrix4fv(lineProg.transform.worldView, false, modelView);\n      // draw line segments\n      gl.drawArrays(gl.LINES, 0, length);\n   }\n\n   var yon;\n   //if (View.prop.constrainAxes) {\n   //   yon = gridSize;\n   //} else {\n      yon = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].zFar;\n   //}\n   if (showAxes) {\n      // use line segment program\n      gl.useProgram(groundAxisProg.handle);\n      // bind attribute, vertex, color, matrix\n      gl.uniformMatrix4fv(groundAxisProg.uPMatrix, false, projection);\n      gl.uniformMatrix4fv(groundAxisProg.uMVMatrix, false, modelView);\n      gl.setBufferAndAttrib(groundAxisProg.axisVBO.position, groundAxisProg.vertexPosition);\n      gl.setBufferAndAttrib(groundAxisProg.axisVBO.color, groundAxisProg.vertexColor);\n      // draw line segment\n      gl.drawArrays(gl.LINES, 0, groundAxisProg.axisVBO.length);\n   }\n\n   return yon;\n};\n\nlet redrawFlag = false;\n\nfunction needToRedraw() {\n   redrawFlag = true;\n};\n\nfunction render(gl, drawWorldFn) {\n   if (gl.resizeToDisplaySize() || _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].isModified || redrawFlag) {\n      redrawFlag = false; \n      const backColor = _wings3d_util__WEBPACK_IMPORTED_MODULE_5__[\"hexToRGBA\"](_wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"theme\"].geometryBackground);\n      gl.clearColor(backColor[0], backColor[1], backColor[2], backColor[3]);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      gl.polygonOffset(0.0, 0.0);\n      gl.enable(gl.POLYGON_OFFSET_FILL);\n      //?CHECK_ERROR(),\n      // no support for pushAttrib()\n      //gl.pushAttrib(?GL_CURRENT_BIT bor ?GL_ENABLE_BIT bor\n      //                        ?GL_TEXTURE_BIT bor ?GL_POLYGON_BIT bor\n      //\t\t                   ?GL_LINE_BIT bor ?GL_COLOR_BUFFER_BIT bor\n      //\t\t                   ?GL_LIGHTING_BIT).enable(?GL_DEPTH_TEST).enable(?GL_CULL_FACE);\n      // no support for dynamic anti aliasing. only setup in creatingContext\n      var mat = _wings3d_view__WEBPACK_IMPORTED_MODULE_1__[\"loadMatrices\"](true);\n      if (_wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].isModified) {\n         _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"].isModified = false;\n         computeGroundAndAxes(gl, mat.projection, mat.modelView);\n      }\n      var yon = renderGroundAndAxes(gl, mat.projection, mat.modelView);\n      renderMiniAxis(gl, mat.modelView);\n      //show_saved_bb(St),\n      //show_bb_center(St),\n      //user_clipping_planes(on),\n      drawWorldFn(gl); // and scenelights.\n      //user_clipping_planes(off),\n      renderAxisLetter(gl, yon);\n      //show_camera_image_plane(),\n      //wings_develop:gl_error_check(\"Rendering scene\")\n   }\n};\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_render.js?");

/***/ }),

/***/ "./js/wings3d_shaderprog.js":
/*!**********************************!*\
  !*** ./js/wings3d_shaderprog.js ***!
  \**********************************/
/*! exports provided: uColorArray, colorArray, selectedColorLine, selectedColorPoint, textArray, cameraLight, solidColor, simplePoint, colorPoint, solidWireframe, edgeSolidWireframe, colorSolidWireframe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uColorArray\", function() { return uColorArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorArray\", function() { return colorArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectedColorLine\", function() { return selectedColorLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectedColorPoint\", function() { return selectedColorPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textArray\", function() { return textArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cameraLight\", function() { return cameraLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solidColor\", function() { return solidColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"simplePoint\", function() { return simplePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorPoint\", function() { return colorPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solidWireframe\", function() { return solidWireframe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeSolidWireframe\", function() { return edgeSolidWireframe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorSolidWireframe\", function() { return colorSolidWireframe; });\n/* harmony import */ var _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_gl */ \"./js/wings3d_gl.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n// program as text .\n\n\n\n\nlet uColorArray = {\n   vertexShader:[\n      'attribute vec3 position;',\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\n      'void main(void) {',\n      '   gl_Position = projection * worldView * vec4(position, 1.0);',\n      '}'].join(\"\\n\"),\n   fragShader:[\n      'uniform lowp vec4 uColor;',\n      'void main(void) {',\n      '   gl_FragColor = uColor;',\n      '}'].join(\"\\n\"),\n};\nlet colorArray = {\n   vertexShader: [\n      'attribute vec3 aVertexPosition;',\n      'attribute vec3 aVertexColor;',\n\n      'uniform mat4 uMVMatrix;',\n      'uniform mat4 uPMatrix;',\n\n      'varying lowp vec4 vColor;',\n\n      'void main(void) {',\n      '   gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);',\n      '   vColor = vec4(aVertexColor, 1.0);',\n      '}'].join(\"\\n\"),\n   fragShader: [\n      'varying lowp vec4 vColor;',\n\n      'void main(void) {',\n      '   gl_FragColor = vColor;',\n      '}'].join(\"\\n\"),\n};\nlet selectedColorLine =  {  // we don't have geometry shader, so we have to manually pass barycentric to do 'single pass wireframe' \nvertex: [       // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n   'attribute vec3 position;', \n   'attribute vec3 barycentric;',\n   'uniform mat4 projection;', \n   'uniform mat4 worldView;',\n\n   'varying vec3 vBC;',\n   'void main(){',\n      'vBC = barycentric;',\n      'gl_Position = projection * worldView * vec4(position, 1.0);',\n   '}'].join(\"\\n\"),\n\nfragment:[\n   '#extension GL_OES_standard_derivatives : enable',\n   'precision mediump float;',\n   'uniform vec4 faceColor;',\n   'uniform vec4 color;',\n   'uniform float lineWidth;',\n   'varying vec3 vBC;',\n\n   'float edgeFactor(){',\n      'vec3 d = fwidth(vBC);',\n      'vec3 a3 = smoothstep(vec3(0.0), d*lineWidth, vBC);',\n      'return min(min(a3.x, a3.y), a3.z);',\n   '}',\n\n   'void main(){',\n      // coloring by edge\n      'float edge = edgeFactor();',\n      'if (edge < 1.0) {',\n        'gl_FragColor = mix(color, faceColor, edge);',\n      '} else {',\n         'discard;',\n      '}',\n   '}'].join(\"\\n\"),\n};\nlet selectedColorPoint = {\n   vertex: [\n      'attribute vec3 position;',\n      'attribute float vertexState;',\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\n      'uniform float vertexSize;',\n      'uniform float selectedVertexSize;',\n      'uniform float maskedVertexSize;',\n\n      'varying lowp float vState;',\n\n      'void main(void) {',\n      '   gl_Position = projection * worldView * vec4(position, 1.0);',\n      '   vState = vertexState;',\n      '   if (vertexState == 0.0) {',\n      '      gl_PointSize = vertexSize;',\n      '   } else if (vertexState < 1.0) {',\n      '      gl_PointSize = selectedVertexSize;',\n      '   } else {',\n      '      gl_PointSize = maskedVertexSize;',\n      '   }',\n      '}'].join(\"\\n\"),\n   fragment: [\n      'precision lowp float;',\n      'varying lowp float vState;',\n      'uniform vec4 vertexColor;',\n      'uniform vec4 unselectedHilite;',\n      'uniform vec4 selectedHilite;',\n      'uniform vec4 selectedColor;',\n      'uniform vec4 maskedVertexColor;',\n\n      'void main(void) {',\n      '   if (vState < 0.0) {',\n      '      discard;',\n      '   } else if (vState == 0.0) {',\n      '      gl_FragColor = vertexColor;',     // unselected color         \n      '   } else if (vState == 0.25) {',\n      '      gl_FragColor = selectedColor;',\n      '   } else if (vState == 0.5) {',\n      '      gl_FragColor = unselectedHilite;',\n      '   } else if (vState == 0.75) {',\n      '      gl_FragColor = selectedHilite;',     \n      '   } else {',\n      '      gl_FragColor = maskedVertexColor;',\n      '   }',\n      '}'].join(\"\\n\"),\n};\nlet textArray = {\n   vertexShader:[\n      'attribute vec4 aVertexPosition;',\n      'attribute vec2 aTexCoord;',\n      'uniform mat4 uMVMatrix;',\n      'uniform mat4 uPMatrix;',\n      'varying vec2 v_texcoord;',\n      'void main() {',\n         'gl_Position =  uPMatrix * uMVMatrix * aVertexPosition;',\n         'v_texcoord = aTexCoord;',\n      '}'].join(\"\\n\"),\n   fragShader:[\n      'precision mediump float;',\n      'varying vec2 v_texcoord;',\n      'uniform sampler2D u_texture;',\n      'void main() {',\n         'gl_FragColor = texture2D(u_texture, v_texcoord);',\n      '}'].join(\"\\n\")\n};\nlet cameraLight = {\n   vertex:[\n      'attribute vec3 position;',\n\n      'uniform vec3 faceColor;',\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\n\n      'varying vec3 vPosition;',\n      'varying vec3 vLight;',\n      'varying vec3 vColor;',\n\n      'void main(void) {',\n      '   gl_Position = projection * worldView * vec4(position, 1.0);',\n      '   vPosition =  (worldView * vec4(position, 1.0)).xyz;',\n      '   vColor = faceColor;',\n      '   vLight = vec3(0.0, 0.0, -1.0);',\n      '}'].join(\"\\n\"),\n   fragment:[\n      '#extension GL_OES_standard_derivatives : enable',\n      'precision mediump float;\\n',\n      'varying vec3 vPosition;',\n      'varying vec3 vLight;',  // light direction\n      'varying vec3 vColor;',\n\n      'void main() {',\n      '  vec3 n = normalize(cross(dFdy(vPosition), dFdx(vPosition)));', // N is the world normal\n      //'  vec3 l = normalize(v_Light);' + // no needs, v_Light is always normalized.\n      '  float diffuseFactor = dot(normalize(n), vLight);',\n      '  if (diffuseFactor > 0.0) {',\n      '    gl_FragColor = vec4(vColor * diffuseFactor, 1.0);',\n      '  } else {',\n      '    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',\n      '  }',\n      '}'].join(\"\\n\"),\n};\nlet solidColor = {\n   vertex:[\n      'attribute vec3 position;',\n\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\n\n      'void main(void) {',\n      '  gl_Position = projection * worldView * vec4(position, 1.0);',\n      '}'].join(\"\\n\"),\n   fragment:[\n      'precision mediump float;',\n      'uniform vec4 faceColor;',\n      'void main(void) {',\n      '  gl_FragColor = faceColor;',\n      '}'].join(\"\\n\")\n};\nlet simplePoint = { \n   vertex: [\n      'attribute vec3 position;',\n      'attribute vec3 color;',\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\t\t\t\n      \n      'varying vec3 vColor;',\n      'void main() {',\n      '  vColor = color;',\n      '  gl_Position = projection * worldView * vec4(position, 1.0);',\n      '  gl_PointSize = 8.8;',\n      '}'].join(\"\\n\"),\n   fragment: [\n      'precision mediump float;',\n      'varying vec3 vColor;',\n\n      'void main() {',\n         ' gl_FragColor = vec4(vColor, 1.0);',\n      '}'].join(\"\\n\")\n};\nlet colorPoint = {\n   vertex: [\n      'attribute vec3 position;',\n      'uniform mat4 worldView;',\n      'uniform mat4 projection;',\t\t\t\n      \n      'void main() {',\n      '  gl_Position = projection * worldView * vec4(position, 1.0);',\n      '  gl_PointSize = 8.8;',\n      '}'].join(\"\\n\"),\n   fragment: [\n      'precision lowp float;',\n      'uniform vec4 uColor;',\n\n      'void main() {',\n      // http://stackoverflow.com/questions/17274820/drawing-round-points-using-modern-opengl\n         'float distance = distance( gl_PointCoord, vec2(0.5,0.5) );',\n         'if ( distance >= 0.5 ) {',\n            'discard;',  \n         '}',\n         'gl_FragColor = uColor;',\n      '}'].join(\"\\n\"),\n};\nlet solidWireframe = {  // we don't have geometry shader, so we have to manually pass barycentric to do 'single pass wireframe' \n   vertex: [       // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n      'attribute vec3 position;', \n      'attribute vec3 barycentric;',\n      'uniform mat4 projection;', \n      'uniform mat4 worldView;',\n\n      'varying vec3 vBC;',\n      'void main(){',\n         'vBC = barycentric;',\n         'gl_Position = projection * worldView * vec4(position, 1.0);',\n      '}'].join(\"\\n\"),\n\n   fragment:[\n      '#extension GL_OES_standard_derivatives : enable',\n      'precision mediump float;',\n      'uniform vec4 color;',\n      'uniform vec4 faceColor;',\n      'varying vec3 vBC;',\n\n      'float edgeFactor(){',\n         'vec3 d = fwidth(vBC);',\n         'vec3 a3 = smoothstep(vec3(0.0), d*1.1, vBC);',\n         'return min(min(a3.x, a3.y), a3.z);',\n      '}',\n\n      'void main(){',\n         // coloring by edge\n         'gl_FragColor = mix(color, faceColor, edgeFactor());',\n      '}'].join(\"\\n\"),\n};\nlet edgeSolidWireframe = {  // we don't have geometry shader, so we have to manually pass barycentric to do 'single pass wireframe' \n      vertex: [       // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n         'attribute vec3 position;', \n         'attribute vec3 barycentric;',\n         'uniform mat4 projection;', \n         'uniform mat4 worldView;',\n\n         'varying vec3 vBC;',\n         'void main(){',\n            'vBC = barycentric;',\n            'gl_Position = projection * worldView * vec4(position, 1.0);',\n         '}'].join(\"\\n\"),\n\n      fragment:[\n         '#extension GL_OES_standard_derivatives : enable',\n         'precision mediump float;',\n         'uniform vec4 color;',\n         'uniform vec4 faceColor;',\n         'uniform float lineWidth;',\n         'varying vec3 vBC;',\n\n         'float edgeFactor(){',\n            'vec3 d = fwidth(vBC);',\n            'vec3 a3 = smoothstep(vec3(0.0), d*lineWidth, vBC);',\n            'return min(min(a3.x, a3.y), a3.z);',\n         '}',\n\n         'void main(){',\n            // coloring by edge\n            'gl_FragColor = mix(color, faceColor, edgeFactor());',\n         '}'].join(\"\\n\"),\n};\nlet colorSolidWireframe = {  // we don't have geometry shader, so we have to manually pass barycentric to do 'single pass wireframe' \n   vertex: [       // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n      'attribute vec3 position;', \n      'attribute vec3 barycentric;',\n      'attribute float selected;',  // (x,y), x is for edge, y is for interior. (y>0 is turnon), (x==1 is turnon).\n      'uniform mat4 projection;', \n      'uniform mat4 worldView;',\n\n      'varying vec3 vBC;',\n      'varying float vSelected;',\n      'void main(){',\n         'vSelected = selected;',\n         'vBC = barycentric;',\n         'gl_Position = projection * worldView * vec4(position, 1.0);',\n      '}'].join(\"\\n\"),\n\n   fragment:[\n      '#extension GL_OES_standard_derivatives : enable',\n      'precision mediump float;',\n      'uniform vec4 faceColor;',\n      'uniform vec4 selectedColor;',  // hilite color\n      'varying vec3 vBC;',\n      'varying float vSelected;',\n\n      'float edgeFactor(){',\n         'vec3 d = fwidth(vBC);',\n         'vec3 a3 = smoothstep(vec3(0.0), d*1.5, vBC);',\n         'return min(min(a3.x, a3.y), a3.z);',\n      '}',\n\n      'void main(){',\n         'vec4 interiorColor = faceColor;',\n         'if (vSelected == 1.0) {',\n         '  interiorColor = selectedColor;',\n         '}',\n         // coloring by edge\n         'gl_FragColor.rgb = mix(vec3(0.0), vec3(interiorColor), edgeFactor());',\n         'gl_FragColor.a = interiorColor[3];',\n      '}'].join(\"\\n\"),\n};\n\n_wings3d__WEBPACK_IMPORTED_MODULE_1__[\"onReady\"](function() {\n   // compiled the program\n   cameraLight = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(cameraLight.vertex, cameraLight.fragment);\n\n   solidColor = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(solidColor.vertex, solidColor.fragment);\n\n   simplePoint = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(simplePoint.vertex, simplePoint.fragment);\n\n   colorPoint = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(colorPoint.vertex, colorPoint.fragment);\n\n   solidWireframe = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(solidWireframe.vertex, solidWireframe.fragment);\n\n   edgeSolidWireframe = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(edgeSolidWireframe.vertex, edgeSolidWireframe.fragment);\n\n   colorSolidWireframe = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(colorSolidWireframe.vertex, colorSolidWireframe.fragment);\n\n   selectedColorLine = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(selectedColorLine.vertex, selectedColorLine.fragment);\n\n   selectedColorPoint = _wings3d_gl__WEBPACK_IMPORTED_MODULE_0__[\"gl\"].createShaderProgram(selectedColorPoint.vertex, selectedColorPoint.fragment);\n});\n\n\n\n//# sourceURL=webpack:///./js/wings3d_shaderprog.js?");

/***/ }),

/***/ "./js/wings3d_similar.js":
/*!*******************************!*\
  !*** ./js/wings3d_similar.js ***!
  \*******************************/
/*! exports provided: SimilarFace, SimilarVertex, SimilarWingedEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimilarFace\", function() { return SimilarFace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimilarVertex\", function() { return SimilarVertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SimilarWingedEdge\", function() { return SimilarWingedEdge; });\n// \n// similar comparison\n//\n\nclass SimilarGeometry {\n   constructor() {\n      this.set = new Set;\n   }\n\n   // https://stackoverflow.com/questions/10015027/javascript-tofixed-not-rounding\n   static _toFixed(num, precision) {\n      return (+(Math.round(+(num + 'e' + precision)) + 'e' + -precision)).toFixed(precision);\n   }\n\n   static _discreetAngle(val) {\n      function findDiscreet(radian) {\n         let degree = radian * 180 / Math.PI;\n         degree = Math.round(degree);     // round to nearest degree\n         if (degree < 0) { // convert to 360, from (0, 2PI).\n            degree = 360 + degree;\n         }\n         return (degree / 180 * Math.PI); // return radian.\n      }\n      let radian = 2 * Math.atan(val);\n      // convert from [-pi, pi] to [0, 2pi].\n      return findDiscreet(radian);\n   }\n\n   // W. Kahan suggested in his paper \"Mindeless.pdf\". numerically better formula.\n   static _computeAngle(m) {   // m = {a, b, aLengthB, bLengthA};\n      // 2 * atan(norm(x*norm(y) - norm(x)*y) / norm(x * norm(y) + norm(x) * y));\n      vec3.scale(m.aLengthB, m.a, m.bLength);\n      vec3.scale(m.bLengthA, m.b, m.aLength);\n      let dist = vec3.distance(m.bLengthA, m.aLengthB);\n      vec3.add(m.aLengthB, m.aLengthB, m.bLengthA);\n      const mag = vec3.length(m.aLengthB);\n      return SimilarGeometry._discreetAngle(dist / mag);\n   }\n\n   static computeRatio(m) {\n      const rad = SimilarGeometry._computeAngle(m);\n      const ratio = SimilarGeometry._toFixed(m.bLength/m.aLength, 2) * rad;      // needFixing: possible collision, but should be fairly uncommon\n      const ratioR = SimilarGeometry._toFixed(m.aLength/m.bLength, 2) * rad;  \n      if (m.fwd.index === -1) {\n         m.fwd.index = 0;\n         m.rev.index = 0;\n      } else {\n         if (ratio < m.fwd.angle[m.fwd.index]) {\n            m.fwd.index = m.fwd.angle.length;\n         } \n         if (ratioR < m.rev.angle[m.rev.index]) {\n            m.rev.index = 0;\n         } else {\n            ++m.rev.index;\n         }\n      }\n      m.fwd.angle.push( ratio );\n      m.rev.angle.unshift( ratioR  );\n   }\n\n   static computeMetric(m, initial = 0.0) {\n      // rotate the array, so the smallest angle start at index 0. so we can compare directly\n      m.fwd.angle.unshift( ...(m.fwd.angle.splice(m.fwd.index, m.fwd.angle.length)) ); // spread operator to explode array.\n      m.rev.angle.unshift( ...(m.rev.angle.splice(m.rev.index, m.rev.angle.length)) ); // spread operator to explode array.\n\n      // convert to string, or really hash.\n      let metric = initial;\n      let metricR = initial;\n      for (let i = 0; i < m.fwd.angle.length; ++i) {\n         metric = (metric*(m.fwd.angle[i]+0.1)) + m.fwd.angle[i];                     // needFixing. better unique computation.\n         metricR = (metricR*(m.rev.angle[i]+0.1)) + m.rev.angle[i];\n      }\n\n      return [metric, metricR];\n   }\n\n   static mStruct() {\n      // shared computation resource\n      return { a: vec3.create(), aLength: -1,\n               b: vec3.create(), bLength: -1,\n               aLengthB: vec3.create(),\n               bLengthA: vec3.create(),\n               fwd: {index: -1, angle: []},\n               rev: {index: -1, angle: []},\n             };\n   }\n\n   // find if selection has similar target\n   find(target) {\n      const metric = this.getMetric(target);\n      return this.set.has(metric);\n   }\n}\n\n\nclass SimilarFace extends SimilarGeometry {\n   constructor(selection) {\n      super();\n      for (let polygon of selection) {\n         const metrics = this.getMetric(polygon, true);\n         this.set.add( metrics[0] );\n         this.set.add( metrics[1] );\n      }\n   }\n\n   // metric return all the angle and side as a unique number.\n   getMetric(polygon, reflect=false) {\n      const m = SimilarGeometry.mStruct();\n      polygon.eachEdge( function(edge) {\n         if (m.aLength === -1) {\n            vec3.sub(m.a, edge.prev().origin.vertex, edge.origin.vertex);\n            m.aLength = vec3.length(m.a);\n         } else {\n            vec3.negate(m.a, m.b);\n            m.aLength = m.bLength;\n         }\n         vec3.sub(m.b, edge.destination().vertex, edge.origin.vertex);\n         m.bLength = vec3.length(m.b);\n         SimilarGeometry.computeRatio(m);\n      });\n      const result = SimilarGeometry.computeMetric(m);\n      if (reflect) {\n         return result;\n      } else {\n         return result[0];\n      }\n   }\n}\n\n\nclass SimilarWingedEdge extends SimilarGeometry {\n   constructor(selection) {\n      super();\n      for (let wingedEdge of selection) {\n         const metrics = this.getMetric(wingedEdge, true);\n         this.set.add( metrics[0] );\n         this.set.add( metrics[1] );\n      }\n   }\n\n   getMetric(wingedEdge, reflect=false) {\n      const metric = SimilarGeometry.mStruct();\n      const normal2 = [];\n      for (let hEdge of wingedEdge) {  // left, right side \n         // down side.\n         const hEdgeA = hEdge.prev();\n         const hEdgeB = hEdge.next;\n         vec3.sub(metric.a, hEdgeA.origin.vertex, hEdge.origin.vertex);\n         metric.aLength = vec3.length(metric.a); \n         vec3.sub(metric.b, hEdgeB.origin.vertex, hEdge.origin.vertex);\n         metric.bLength = vec3.length(metric.b);\n         SimilarGeometry.computeRatio(metric);\n         const norm = vec3.create();\n         vec3.cross(norm, metric.b, metric.a);\n         vec3.normalize(norm, norm);\n         normal2.push(norm);\n         // up\n         vec3.negate(metric.a, metric.b);\n         metric.aLength = metric.bLength;\n         vec3.sub(metric.b, hEdgeB.destination().vertex, hEdgeB.origin.vertex);\n         metric.bLength = vec3.length(metric.b);\n         SimilarGeometry.computeRatio(metric);\n      }\n      // we should also check the difference of the  normal of the 2 side of the edge? differing from original implementation.\n      const dot = vec3.dot(normal2[1], normal2[0]);\n      const result = SimilarGeometry.computeMetric(metric, dot);\n      if (reflect) {\n         return result;\n      } else {\n         return result[0];\n      }\n   }\n}\n\n\nclass SimilarVertex extends SimilarGeometry {\n   constructor(selection) {\n      super();\n      for (let vertex of selection) {\n         const metric = this.getMetric(vertex, true);\n         this.set.add( metric[0] );\n         this.set.add( metric[1] );\n      }\n   }\n\n   getMetric(vertex, reflect=false) {\n      const m = SimilarGeometry.mStruct();\n      vertex.eachOutEdge( function(edge) {\n         if (m.aLength === -1) {\n            vec3.sub(m.a, edge.destination().vertex, vertex.vertex);  // similar to SimilarFace, but everything point outEdge.\n            m.aLength = vec3.length(m.a);\n         } else {\n            vec3.copy(m.a, m.b);\n            m.aLength = m.bLength;\n         }\n         vec3.sub(m.b, edge.destination().vertex, vertex.vertex);\n         m.bLength = vec3.length(m.b);\n         SimilarGeometry.computeRatio(m);\n      });\n      const result = SimilarGeometry.computeMetric(m);\n      if (reflect) {\n         return result;\n      } else {\n         return result[0];\n      }\n   }\n}\n\n\n\n//# sourceURL=webpack:///./js/wings3d_similar.js?");

/***/ }),

/***/ "./js/wings3d_triangulate.js":
/*!***********************************!*\
  !*** ./js/wings3d_triangulate.js ***!
  \***********************************/
/*! exports provided: triangulatePreview */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triangulatePreview\", function() { return triangulatePreview; });\n/* harmony import */ var _wings3d_wingededge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_wingededge */ \"./js/wings3d_wingededge.js\");\n//\n// triangulate polygon - our own modified ear-cutting method.\n//\n// the algorithm worked most of time without checking diagonal. good for our usage, previewPolyogn, not suitable for real triangulation.\n// first cut off concave edge, keep cutting until not concave.\n// when all the concave edges were processed, the remaining polygon is convex polygon.\n//\n//\"use strict\";\n\n\n// helper class for triangulate\nconst InternalHEdge = function(vertex, next) {\n   this.origin = vertex;\n   this.next = next;\n};\n\nInternalHEdge.prototype.destination = function() {\n   return this.next.origin;\n}\n\n//\n// check if v1 vertex lies on concave edges.\n//\nlet edge0 = vec3.create();\nlet edge1 = vec3.create();\nlet crossNorm = vec3.create();\nfunction isConcave(v0, v1, v2) {\n// angle = pi - atan2(v[i] x v[i+1].magnitude, v[i] * v[i+1]);\n   vec3.sub(edge0, v0.vertex, v1.vertex);\n   vec3.sub(edge1, v2.vertex, v1.vertex);\n   vec3.cross(crossNorm, edge0, edge1);\n   let angle = Math.atan2(vec3.length(crossNorm), vec3.dot(edge0, edge1));\n   return (angle <= 0);\n};\n\n\nfunction triangulatePreview(polygon) {\n   let concave = 0;    // accumulate incomplete processing.\n   let convex = [];\n   let triangles = [];\n\n   let end = polygon.halfEdge;\n   let hEdge = polygon.halfEdge;\n   let current;\n   do {  // find the first concave.\n      if (lastHEdge) {\n         if (lastHEdge.origin, current.origin, current.destination()) {\n            convex.push(lastHEdge);\n            concave++;\n            break;\n         }\n      } else {\n         lastHEdge = current;\n      }\n      current = current.next;\n   } while (current !== end);\n   // now process concave.\n   if (current !== end) {\n      end = current;\n      lastHEdge = current;\n      current = current.next;\n      do {\n         if (isConcave(lastHEdge.origin,current.origin, current.destination())) {   // push it onto concave, and let later edge connected it\n            convex.push( current );\n            concave++;\n         } else { // connect back to concave if any.\n            if (concave > 0) {\n               do { // keep slicing off concave if convex\n                  let connect = new InternalHEdge(lastHEdge.origin, current.next); // triangle is lastHedge->hEdge->connect\n                  triangles.push(lastHEdge.origin, current.origin, curret.destination());\n                  convex.pop();  // popout lastHEdge.\n                  lastHEdge = convex[convex.length-1];\n                  current = connect;\n               } while (!isConcave(lastHEdge.origin, connect.origin, connect.destination()) && (--concave > 0));\n               // cleanup\n               if (concave == 0) {\n                  convex.push( current );\n               }\n            } else {\n               convex.push( current );\n            }\n         }\n         lastHEdge = current;\n         current = current.next;\n      } while (current !== end);\n   }\n   // only convex polygon left. process it.\n   if (convex.length >= 3) {\n      lastHEdge = convex[0];\n      const end = convex.length -1;\n      lastHEdge.triPt = convex[2].origin;\n      for (let i = 1; end > i; ++i) { // add triangle\n         const current = convex[i];\n         triangles.push(lastHEdge.origin, current.origin, current.destination());\n         current.triPt = lastHEdge.origin;\n      }\n   } else { // something wrong\n      console.log(\"something wrong in triangulatePreview\");\n   }\n\n\n   \n   // return the  triangle list.\n   return triangles;\n};\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_triangulate.js?");

/***/ }),

/***/ "./js/wings3d_ui.js":
/*!**************************!*\
  !*** ./js/wings3d_ui.js ***!
  \**************************/
/*! exports provided: styleSheet, getArrow, placement, getPosition, positionDom, addMenuItem, bindMenuItem, bindMenuItemMMB, bindMenuItemRMB, bindMenuItemMode, extractDialogValue, runDialog, runDialogCenter, openFile, showContextMenu, queuePopupMenu, toggleSubmenu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"styleSheet\", function() { return styleSheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getArrow\", function() { return getArrow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"placement\", function() { return placement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPosition\", function() { return getPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"positionDom\", function() { return positionDom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addMenuItem\", function() { return addMenuItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindMenuItem\", function() { return bindMenuItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindMenuItemMMB\", function() { return bindMenuItemMMB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindMenuItemRMB\", function() { return bindMenuItemRMB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindMenuItemMode\", function() { return bindMenuItemMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extractDialogValue\", function() { return extractDialogValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"runDialog\", function() { return runDialog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"runDialogCenter\", function() { return runDialogCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openFile\", function() { return openFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"showContextMenu\", function() { return showContextMenu; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"queuePopupMenu\", function() { return queuePopupMenu; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleSubmenu\", function() { return toggleSubmenu; });\n/* harmony import */ var _wings3d_hotkey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_hotkey */ \"./js/wings3d_hotkey.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/*\n   wings3d, ui and ui utility functions. including tutor.\n\n*/\n\n\n\n\nfunction _bindMenuItem(mode, menuItem, button, id, fn, hotkey, meta) {\n   _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"bindAction\"](menuItem, button, id, fn);\n   if (hotkey !== undefined) {\n      _wings3d_hotkey__WEBPACK_IMPORTED_MODULE_0__[\"setHotkey\"](mode, id, hotkey, meta);\n      // now put it on meta\n      const data = meta ? `${meta}+${hotkey}` : hotkey;\n      menuItem.classList.add(\"hotkey\");\n      menuItem.setAttribute(\"data-hotkey\", data.toUpperCase());\n   }\n}\n\n\nfunction bindMenuItem(id, fn, hotkey, meta) {\n   const menuItem = document.querySelector('#' + id);\n   if (menuItem) {\n      _bindMenuItem(null, menuItem, 0, id, fn, hotkey, meta);\n   } else {\n      console.log(\"Click: could not find menuItem \" + id);\n   }\n}\nfunction bindMenuItemMMB(id, fn) {\n   const menuItem = document.querySelector('#' + id);\n   if (menuItem) {\n      _bindMenuItem(null, menuItem, 1, id, fn);\n   } else {\n      console.log(\"AuxClick: could not find menuItem \" + id);\n   }\n}\nfunction bindMenuItemRMB(id, fn) {\n   const menuItem = document.querySelector('#' + id);\n   if (menuItem) {\n      _bindMenuItem(null, menuItem, 2, id, fn);\n   } else {\n      console.log(\"ContextClick: could not find menuItem \" + id);\n   }\n}\nfunction bindMenuItemMode(id, fn, mode, hotkey, meta) {\n   const menuItem = document.querySelector('#' + id);\n   if (menuItem) {\n      _bindMenuItem(mode, menuItem, 0, id, fn, hotkey, meta);\n   } else {\n      console.log(\"Click: could not find menuItem \" + id);\n   }\n}\n\n\n\nfunction addMenuItem(menuId, id, menuItemText, fn, hotkey, meta) {\n   const menu = document.querySelector('#' + menuId);\n   // insert the menuItem \n   const menuItem = document.createElement('li');\n   const a = document.createElement('a');\n   a.id = id;\n   a.textContent = menuItemText;\n   // append to submenu\n   menuItem.appendChild(a);\n   menu.appendChild(menuItem);\n   _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"addActionConstant\"](id);\n   _bindMenuItem(a, 0, id, fn, hotkey, meta);\n}\n\n\nfunction getArrow(placement) {\n      if (placement === \"bottom\") {\n         return \"top\";\n      } else if (placement === \"bottom-start\") {\n         return \"top\";\n      } else if (placement === \"top\") {\n         return \"bottom\";\n      } else if (placement === \"top-start\") {\n         return \"bottom\";\n      } else if (placement === \"left\") {\n         return \"right\";\n      } else if (placement === \"right\") {\n         return \"left\";\n      }\n      return \"\";\n};\n\n// placement.\nfunction placement(targetId, placement, bubble) {\n      // get the size of bubble.\n      const bubbleRect = bubble.getBoundingClientRect();\n\n      let target;\n      let targetRect;\n      if (targetId === \"\") { // no target, then point at the workarea's center\n         target = document.getElementById(\"glcanvas\");\n         const rect = target.getBoundingClientRect();\n         targetRect = {left: Math.round(rect.left+rect.width/2), \n                       top: Math.round(rect.top+rect.height/2), \n                       width: 1, height: 1};\n      } else {\n         target = document.getElementById(targetId);\n         // get the location and size of target\n         targetRect = target.getBoundingClientRect();\n      }\n\n      let x=targetRect.left - window.scrollX, y=targetRect.top - window.scrollY;\n      // now compute the target position.\n      if (placement === \"bottom\") {\n         x += Math.round((targetRect.width / 2) - (bubbleRect.width /2));\n         y += targetRect.height;\n         return { top: y, left: x };\n      } else if (placement ===\"bottom-start\") {\n         x += Math.round((targetRect.width / 8) - (bubbleRect.width /2));\n         y += targetRect.height;\n         return { top: y, left: x};\n      } else if (placement === \"top\") {\n         x += Math.round((targetRect.width / 2) - (bubbleRect.width /2));\n         y -= bubbleRect.height;\n         return { top: y, left: x };\n      } else if (placement === \"top-start\") {\n         x += Math.round((targetRect.width / 8) - (bubbleRect.width /2));\n         y -= bubbleRect.height;\n         return { top: y, left: x};\n      } else if (placement === \"right\") {\n         x += targetRect.width;\n         y += Math.round((targetRect.height/2) - (bubbleRect.height/2));\n         return {top: y, left: x};\n      } else if (placement === \"left\") {        \n         x -= bubbleRect.width;\n         y += Math.round((targetRect.height/2) - (bubbleRect.height/2));\n         return {top: y, left: x};\n      }\n};\n\n  /**\n   * Get's exact position of event.\n   * \n   * @param {Object} e The event passed in\n   * @return {Object} Returns the x and y position\n   */\n  function getPosition(e) {\n   const pos = {x: 0, y: 0};\n    \n    if (e.pageX || e.pageY) {\n      pos.x = e.pageX;\n      pos.y = e.pageY;\n    } else if (e.clientX || e.clientY) {\n      pos.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      pos.y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n\n    return pos;\n  }\n  /**\n   * Positions the menu properly. If outside the windows, tried to move backin.\n   * \n   * @param {Object} e The event\n   */\nfunction positionDom(element, mousePosition) {\n   var elementWidth = element.offsetWidth + 4;\n   var elementHeight = element.offsetHeight + 4;\n\n   var windowWidth = window.innerWidth;\n   var windowHeight = window.innerHeight;\n\n   if ( (windowWidth - mousePosition.x) < elementWidth ) {\n      element.style.left = windowWidth - elementWidth + \"px\";\n   } else {\n      element.style.left = mousePosition.x + \"px\";\n   }\n\n   if ( (windowHeight - mousePosition.y) < elementHeight ) {\n      element.style.top = windowHeight - elementHeight + \"px\";\n   } else {\n      element.style.top = mousePosition.y + \"px\";\n   }\n};\n\n\nfunction extractDialogValue(form) {\n   // get form's input data.\n   const obj = {};\n   for (let element of form.elements) {\n      if ((element.name) && (element.value)) {  // should we check the existence of .name? no name elements automatically excludede? needs to find out.\n         obj[element.name] = element.value;\n      }\n   }\n   return obj;\n};\nfunction runDialog(formID, ev, submitCallback, setup) {\n   runDialogCenter(formID, submitCallback, setup, ev);\n};\n\nfunction runDialogCenter(formID, submitCallback, setup, _ev) {\n   const form = document.querySelector(formID);\n   if (form) {\n      const _pvt = {submitSuccess: false};\n      // create overlay\n      const overlay = document.createElement(\"div\");\n      overlay.classList.add(\"overlay\");   \n      overlay.appendChild(form); \n      form.style.display = 'block';\n      if (_ev) {\n         overlay.classList.add(\"realCenterModal\");\n      } else {\n         overlay.classList.add(\"centerModal\");\n      }\n      form.reset();\n      if (setup) {\n         setup(form);\n      }\n      // we need this because submit event won't tell which submit buttons we clicked.\n      const submits = form.querySelectorAll('[type=submit]');\n      for (let submit of submits) {\n         if ('ok'.localeCompare(submit.value, 'en', {'sensitivity': 'base'}) == 0) {\n            submit.addEventListener('click', function oked(ev) {\n               _pvt.submitSuccess = true;\n               submit.removeEventListener('click', oked);\n            });\n         } else if ('cancel'.localeCompare(submit.value, 'en', {'sensitivity': 'base'}) == 0) {\n\n         } else {\n            console.log('submit ' + submit.value + ' type not supported');\n         }\n      }\n      document.body.appendChild(overlay);\n      \n      // wait for handling event.\n      form.addEventListener('submit', function submitted(ev) {\n         if ((_pvt.submitSuccess)) {\n            // get form's input data.\n            submitCallback(form);     // ask function to extract element's value.\n         }\n         // hide the dialog, prevent default.\n         ev.preventDefault();\n         form.style.display = 'none';\n         form.removeEventListener('submit', submitted);\n         document.body.appendChild(form);\n         document.body.removeChild(overlay);\n      });\n   }\n};\n\n\n// fileInput helper\nfunction openFile(fn) {\n   const fileInput = document.querySelector('#importFile');    // <input type=\"file\" id=\"wavefrontObj\" style=\"display:none\"/> \n   if (fileInput) {\n      fileInput.click();\n      fileInput.addEventListener('change', function ok(ev) {\n         let fileList = this.files;    // = ev.target.files;\n         for (let file of fileList) {\n            fn(file);\n         }\n      });\n   }\n};\n\n\nlet styleSheet = (function(){\n   let style = document.createElement('style');\n   document.head.appendChild(style);\n   // webkit hack, still needs in 2018?\n   style.appendChild(document.createTextNode(''));\n   return style.sheet;\n}());\n\n\nconst submenu = [];\nfunction slideBack() {\n   if (submenu.length === 0) {\n      return false;\n   }\n   // hide current ul\n   const ul = submenu.pop();\n   ul.style.visibility = \"hidden\";\n   // now toggle parent sibling\n   const dropside = ul.parentElement;  \n   dropside.classList.remove('hideAfter', 'showBefore');\n   // hide all dropside sibling \n   const grandParent = dropside.parentElement;\n   let element = grandParent.firstElementChild;\n   do {\n      //if (element !== dropside) {\n         element.style.visibility = \"inherit\";\n      //}\n   } while (element = element.nextElementSibling);\n   if (submenu.length > 0) {\n      const grandA = grandParent.previousElementSibling;\n      if (grandA && grandA.tagName == \"A\") { \n         grandA.style.visibility = \"inherit\";\n         grandA.parentElement.style.visibility = \"inherit\";\n      }\n   }\n   return true;\n};\n//dropside, slide in/out\nfunction toggleSubmenu(ul) {\n   if ((submenu.length > 0) && (submenu[submenu.length-1] === ul)) { // is toggling\n      slideBack();\n   } else {\n      // now toggle on\n      const dropside = ul.parentElement;\n      dropside.classList.add(\"showBefore\", \"hideAfter\");\n      // hide grandParent if needed \n      const grandParent = dropside.parentElement;\n      if (submenu.length > 0) {\n         const grandA = grandParent.previousElementSibling;\n         if (grandA && grandA.tagName == \"A\") {\n            grandA.style.visibility = \"hidden\";\n            grandA.parentElement.style.visibility = \"hidden\";\n         }\n      }\n      // hide all dropside Sibling\n      let element = grandParent.firstElementChild;\n      do {\n         if (element !== dropside) {\n            element.style.visibility = \"hidden\";\n         }\n      } while (element = element.nextElementSibling);\n      submenu.push(ul);\n      ul.style.visibility = \"visible\";\n   }\n};\n\n// show popupMenu\nfunction clickInsideElement( e, className ) {\n   let target = e.target;\n   do {\n      if ( target.classList && target.classList.contains(className) ) {\n         return target;\n      }\n   } while ( target = target.parentNode )\n   return false;\n};\n\nlet currentMenu=false;\nlet nextPopup=false;\nfunction toggleMenuOff() {\n   if (currentMenu) {\n      currentMenu.style.visibility = \"hidden\";\n      currentMenu=false;\n      while (slideBack()) {}\n   }\n   if (nextPopup) {\n      currentMenu = nextPopup;\n      nextPopup=false;\n      currentMenu.style.visibility = \"visible\";   // toggleMenuOn\n   }\n};\nlet firstClick = 0;\nfunction clickListener() {\n   function callBack(e) {\n      if (firstClick) {\n         firstClick--;\n      } else {\n      //let clickeElIsLink = clickInsideElement( e, popupMenuClass );\n      //if ( !clickeElIsLink ) {\n         //if ( (e.button == 0) || (e.button == 1) ) {  // somehow, any click should \n            toggleMenuOff();\n            if (!currentMenu) {\n               // remove listening event\n               document.removeEventListener(\"mouseup\", callBack);\n            }\n         //}\n      }\n    }\n\n   document.addEventListener(\"mouseup\", callBack, false);\n};\nfunction showContextMenu(popupMenu) {\n   if (currentMenu) {\n      toggleMenuOff();\n   } else {\n      firstClick++;\n      clickListener();\n   }\n   currentMenu = popupMenu;\n   currentMenu.style.visibility = \"visible\";   // toggleMenuOn\n};\nfunction queuePopupMenu(popupMenu) {\n   if (popupMenu !==currentMenu) {\n      nextPopup = popupMenu;\n      if (!currentMenu) {\n         clickListener();\n      }\n   }\n};\n\n\n// moveable popup box,\n\n\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_ui.js?");

/***/ }),

/***/ "./js/wings3d_uitree.js":
/*!******************************!*\
  !*** ./js/wings3d_uitree.js ***!
  \******************************/
/*! exports provided: getTreeView, getListView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTreeView\", function() { return getTreeView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getListView\", function() { return getListView; });\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_bodymads */ \"./js/wings3d_bodymads.js\");\n/**\n * treeView gui\n\n*/\n\n\n\n\n\n\n// utility - handling event\nfunction dragOver(ev) {\n   ev.preventDefault();\n};\nfunction dragLeave(ev){\n   ev.preventDefault();\n   ev.stopPropagation();\n   if (ev.target === this) {  // won't handle child's bubbling phase\n      this.classList.remove('dropZone');\n   }\n};\nfunction dragEnter(ev){\n   ev.preventDefault();\n   ev.stopPropagation();\n   this.classList.add('dropZone');\n};\n\n/** \n * tree view\n*/\nclass TreeView {\n   constructor(label, treeView, world) {\n      this.label = label;\n      this.treeView = treeView;\n      this.world = world;\n      this.drag = {cage: null, li:null};\n      // add drop zone\n      const self = this;\n      // get the resultCount\n      if (world) {\n         world.guiStatus.count = label.querySelector('.resultCount');\n      }\n      world.guiStatus.ul = treeView;\n      // drop target, dragEnter, dragLeave\n      label.addEventListener('drop', function(ev){\n      dragLeave.call(this, ev);\n         // check if belong to same treeView\n         if (self.treeView.id === ev.dataTransfer.getData(\"text\")) {\n            // now move to UL.\n            self.treeView.insertBefore(self.drag.li, self.treeView.firstChild);\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"moveCage\"](world, self.drag.cage);\n            self.drag.li = self.drag.cage = null;\n         }\n       });\n      label.addEventListener('dragover', dragOver);\n      label.addEventListener('dragenter',dragEnter);\n      label.addEventListener('dragleave', dragLeave); \n      // context menu\n      label.addEventListener('contextmenu', function(ev) {\n         ev.preventDefault();\n         let contextMenu = document.querySelector('#geometryGraphWorld');\n         if (contextMenu) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"positionDom\"](contextMenu, _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"getPosition\"](ev));\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"showContextMenu\"](contextMenu);\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](world, [world]);\n         }\n       }, false);\n   }\n\n   /**\n    * \n    * @param {PreviewCage or PreviewGroup} model - . \n    */\n   static addRenameListener(text, model) {\n      text.textContent = model.name;\n      model.guiStatus.textNode = text;\n      const entry = function(ev) {\n         if (ev.keyCode == 13) {\n            // rename if different\n            if (this.textContent !== model.name) {\n               const data = {};\n               data[model.uuid] = this.textContent;\n               const command = new _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_3__[\"RenameBodyCommand\"]([model], data);\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"undoQueue\"]( command );\n               command.doIt();   // rename\n            }\n            this.contentEditable = false;\n            this.removeEventListener('keydown', entry);  // remove keyListening event\n         }\n      };\n      text.addEventListener('dblclick', function(ev){\n         this.contentEditable = true;\n         this.focus();\n         this.addEventListener('keydown', entry);\n       });\n      text.addEventListener('blur', function(ev) {\n         // restore \n         this.textContent = model.name;   // restore name\n         this.contentEditable = false;\n         this.removeEventListener('keydown', entry);\n       });\n\n      return text;\n   }\n\n\n   /**\n    * \n    * @param {PreviewCage} sibling - insert after sibling \n    * @param {PreviewGroup} folder -  todo: later to be replace by TransformGroup\n    */\n   addGroup(parentUL, group) {\n      const self = this;\n      let li = group.guiStatus.li;\n      if (!li) {\n         li = document.createElement('li');\n         group.guiStatus.li = li;\n         // input before label\n         const id = group.uuid;\n         const whole = document.createRange().createContextualFragment(`<input type=\"checkbox\" id=\"${id}\"><label for=\"${id}\" class=\"folder\"></label><p><span></span><span class=\"resultCount\">0</span></p><ul></ul>`);\n         // span text\n         TreeView.addRenameListener(whole.querySelector('span'), group);\n         const ul = whole.querySelector('ul');\n         group.guiStatus.ul = ul;\n         const dropZone = whole.querySelector('p');\n         group.guiStatus.count = whole.querySelector('.resultCount');\n         li.appendChild(whole);\n         // drop target, dragEnter, dragLeave\n         dropZone.addEventListener('drop', function(ev){\n            dragLeave.call(this, ev);\n            // check if belong to same treeView\n            if (self.treeView.id === ev.dataTransfer.getData(\"text\")) {\n               // now move to UL.\n               ul.insertBefore(self.drag.li, ul.firstChild);\n               \n               _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"moveCage\"](group, self.drag.cage);\n\n               self.drag.li = self.drag.cage = null;\n            }\n          });\n         dropZone.addEventListener('dragover', dragOver);\n         dropZone.addEventListener('dragenter',dragEnter);\n         dropZone.addEventListener('dragleave', dragLeave);\n      }\n      parentUL.appendChild(li);\n   }\n\n   /**\n    * add previewCage to be displayed in TreeView\n    * @param {PreviewCage} model -target \n    */\n   addObject(model, parentUL = this.treeView) {\n      const self = this;\n      let li = model.guiStatus.li;\n      if (!li) {\n         li = document.createElement('li');\n         model.guiStatus.li = li;\n         li.classList.add('objectName');\n         li.draggable = true;\n         li.addEventListener('dragstart', function(ev){\n            //ev.preventDefault();\n            ev.stopPropagation()\n            ev.dataTransfer.setData('text', self.treeView.id);\n            self.drag.li = this;\n            self.drag.cage = model;\n          });\n         // select whole object\n         const whole = document.createRange().createContextualFragment('<label><input type=\"checkbox\"><span class=\"smallIcon\" style=\"background-image: url(\\'../img/bluecube/small_whole.png\\');\"></span></label>');\n         let input = whole.querySelector('input');\n         input.addEventListener('change', (ev)=> {  // whole is fragment. we want label.\n            if (model.isLock() || !model.isVisible()) {   // not actually changeable\n               ev.target.checked = !ev.target.checked;\n               return;\n            }\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](model.parent, [model]);\n            _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"runAction\"](0, \"toggleObjectSelect\", ev);\n          });\n         model.guiStatus.select = input;\n         li.appendChild(whole);\n         // span text\n         const text = TreeView.addRenameListener(document.createElement('span'), model);\n         text.addEventListener('contextmenu', function(ev) {\n            ev.preventDefault();\n            let contextMenu = document.querySelector('#geometryGraphText');\n            if (contextMenu) {\n               _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"positionDom\"](contextMenu, _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"getPosition\"](ev));\n               _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"showContextMenu\"](contextMenu);\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](model.parent, [model]);\n            }\n          }, false);\n         li.appendChild(text);\n         // eye label\n         const eyeLabel = document.createRange().createContextualFragment('<label><input type=\"checkbox\"><span class=\"smallIcon\" style=\"background-image: url(\\'../img/bluecube/small_show.png\\');\"></span></label>');\n         input = eyeLabel.querySelector('input');\n         input.addEventListener('change', (ev)=> {  // whole is fragment. we want label.\n            if (model.isLock()) {   // non modifiable object\n               ev.target.checked = !ev.target.checked;\n               return;\n            }\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](model.parent, [model]);\n            _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"runAction\"](0, \"toggleObjectVisibility\", ev);   \n          });\n         model.guiStatus.visibility = input;\n         li.appendChild(eyeLabel);\n         // lock/unlock\n         const lockLabel = document.createRange().createContextualFragment('<label><input type=\"checkbox\"><span class=\"smallIcon\" style=\"background-image: url(\\'../img/bluecube/small_unlock.png\\');\"></span></label>');\n         input = lockLabel.querySelector('input');\n         input.addEventListener('change', (ev)=> {  // whole is fragment. we want label.\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](mode.parent, [model]);\n            _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"runAction\"](0, \"toggleObjectLock\", ev);\n          });\n         li.appendChild(lockLabel);\n         model.guiStatus.locked = input;\n         // wireframe\n         const wireframe = document.createRange().createContextualFragment('<label><input type=\"checkbox\"><span class=\"smallIcon\" style=\"background-image: url(\\'../img/bluecube/small_wire.png\\');\"></span></label>');\n         input = wireframe.querySelector('input');\n         input.addEventListener('change', (ev)=> {  // whole is fragment. we want label.\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_0__[\"setObject\"](model.parent, [model]);\n            _wings3d__WEBPACK_IMPORTED_MODULE_1__[\"runAction\"](0, \"toggleWireMode\", ev);\n          });\n         li.appendChild(wireframe);\n      }\n      parentUL.appendChild(li);\n   }\n\n   /**\n    * remove PreviewCage from TreeView\n    * @param {PreviewCage} model - the previewCage to be removed from \n    */\n   removeObject(model) {\n      const li = model.guiStatus.li;\n      li.parentNode.removeChild(li);\n      model.removeFromParent();\n      //model._textNode = undefined;\n   }\n\n}\n\nfunction getTreeView(labelId, id, world) {\n   const label = document.querySelector(labelId);  // get <label>\n   const treeView = document.querySelector(id); // get <ul>\n   if (label && treeView) {\n      return new TreeView(label, treeView, world);\n   }\n   // console log error\n   return null;\n};\n\n/**\n * for material, image, lights\n */\nclass ListView {\n   constructor(label, listView) {\n      this.view = listView;\n      this.list = [];\n      // context menu\n      let contextMenu = document.querySelector('#importImageMenu');\n      if (contextMenu) {\n         label.addEventListener('contextmenu', function(ev) {\n            ev.preventDefault();\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"positionDom\"](contextMenu, _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"getPosition\"](ev));\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_2__[\"showContextMenu\"](contextMenu);\n          }, false);\n      }\n   }\n\n   loadImage(file) {\n      const self = this;\n      let reader = new FileReader();\n\n      const img = document.createElement(\"img\");\n      reader.onload = function(ev) {\n         img.src = reader.result;\n         //document.body.appendChild(img);\n         alert(img.src);\n      }\n\n      reader.readAsDataURL(file);\n   }\n\n}\n\nfunction getListView(labelId, id) {\n   const listView = document.querySelector(id); // get <ul>\n   const label = document.querySelector(labelId);\n   if (label && listView) {\n      return new ListView(label, listView);\n   }\n   // console log error\n   return null;\n};\n\n\n\n//# sourceURL=webpack:///./js/wings3d_uitree.js?");

/***/ }),

/***/ "./js/wings3d_undo.js":
/*!****************************!*\
  !*** ./js/wings3d_undo.js ***!
  \****************************/
/*! exports provided: EditCommand, EditSelectHandler, MouseMoveHandler, MoveableCommand, EditCommandCombo, EditCommandSimple */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditCommand\", function() { return EditCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditSelectHandler\", function() { return EditSelectHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseMoveHandler\", function() { return MouseMoveHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MoveableCommand\", function() { return MoveableCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditCommandCombo\", function() { return EditCommandCombo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EditCommandSimple\", function() { return EditCommandSimple; });\n/**\n *  abstract EditCommand class for undo, redo handling. also MouseMoveHandler class.\n * \n */\n\n// merge MouseMoveHandler to EditCommand\nclass EditCommand {\n   _calibrateMovement(mouseMove) {\n      // todo: instead of magic constant. should supply a scaling factor.\n      let move;\n      if (mouseMove == 0) {\n         move = 0;\n      } else if (mouseMove < 0) {\n         move = Math.log(-mouseMove) / 5.0;  // log to counteract mouse acceleration.\n         move = -move;\n      } else {\n         move = Math.log(mouseMove) / 5.0;\n      }\n\n      return move;\n   }\n\n   _xPercentMovement(ev) {\n      let width = window.innertWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      return (ev.movementX / width);\n   }\n\n   free() {}\n\n   isDoable() { return true; }\n\n   //doIt() {}\n\n   //undo() {}\n}\n\nclass MouseMoveHandler extends EditCommand {\n\n   //handleMouseMove(ev) {}\n\n/*   cancel() {\n      this._cancel();     // called descendant handler\n      // enable mouse cursor\n      document.body.style.cursor = 'auto';\n   }\n\n   commit() {\n      this._commit();\n      // enable mouse cursor\n      document.body.style.cursor = 'auto';\n   } */\n}\n\n// delegate mouse movement to MouseMoveHandler\nclass MoveableCommand extends EditCommand {\n\n   isMoveable() {\n      if (this.moveHandler) {\n         return true;\n      }\n      return false;\n   }\n\n   handleMouseMove(ev, cameraView) {\n      if (this.moveHandler) {\n         this.moveHandler.handleMouseMove(ev, cameraView);\n      }\n   }\n\n   doIt() {\n      if (this.moveHandler) {\n         this.moveHandler.doIt();\n      }\n   }\n\n   undo() {\n      if (this.moveHandler) {\n         this.moveHandler.undo();\n      }\n   }\n}\n\nclass EditSelectHandler extends MoveableCommand {\n   constructor(isVertex, isEdge, isFace, planeNormal) {\n      super();\n      this.selectable = {isVertex: isVertex, isEdge: isEdge, isFace: isFace};\n      this.planeNormal = planeNormal;\n   }\n\n   isVertexSelectable() { return this.selectable.isVertex; }\n   isEdgeSelectable() { return this.selectable.isEdge; }\n   isFaceSelectable() { return this.selectable.isFace; }\n   getPlaneNormal() { return this.planeNormal; }\n\n   // hilite(hilite, currentCage) - to be implemented by subclass\n   // select(hilite) - to be implemented by subclass\n}\n\nclass EditCommandSimple extends EditCommand {\n   constructor(command) {\n      super();\n      this.commandName = command;\n   }\n\n   doIt(currentMadsor) {\n      this.result = currentMadsor[this.commandName]();\n      return (this.result !== false);\n   }\n\n   undo(currentMadsor) {\n      this.result.undo.call(currentMadsor, this.result.snapshots);\n      //this.undo(currentMadsor);   // originally using return function, but now we needs to serialize EditCommand, so pass back function and argument.\n   }\n}\n\n\nclass EditCommandCombo extends EditCommand {\n   constructor(editCommands) {\n      super();\n      this.editCommands = editCommands;\n   }\n\n   doIt() {\n      // start from beginning\n      for (let cmd of this.editCommands) {\n         cmd.doIt();\n      }\n   }\n\n   undo() {\n      // walk from last to first\n      for (let i = this.editCommands.length-1; i >= 0; --i) {\n         this.editCommands[i].undo();\n      }\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_undo.js?");

/***/ }),

/***/ "./js/wings3d_util.js":
/*!****************************!*\
  !*** ./js/wings3d_util.js ***!
  \****************************/
/*! exports provided: closestPointToPlane, computeAngle, getAxisAngle, computeEdgeNormal, getAxisOrder, intersectTriangle, intersectRayAAExtent, intersectRaySphere, intersectPlaneSphere, intersectPlaneAABB, intersectPlaneHEdge, projectVec3, rotationFromToVec3, reflectionMat4, hexToRGB, hexToRGBA, hexToCssRGBA */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestPointToPlane\", function() { return closestPointToPlane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeAngle\", function() { return computeAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisAngle\", function() { return getAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeEdgeNormal\", function() { return computeEdgeNormal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisOrder\", function() { return getAxisOrder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectTriangle\", function() { return intersectTriangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRayAAExtent\", function() { return intersectRayAAExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRaySphere\", function() { return intersectRaySphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPlaneSphere\", function() { return intersectPlaneSphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPlaneAABB\", function() { return intersectPlaneAABB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPlaneHEdge\", function() { return intersectPlaneHEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projectVec3\", function() { return projectVec3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotationFromToVec3\", function() { return rotationFromToVec3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reflectionMat4\", function() { return reflectionMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hexToRGB\", function() { return hexToRGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hexToRGBA\", function() { return hexToRGBA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hexToCssRGBA\", function() { return hexToCssRGBA; });\n\n\n\nconst kEPSILON = 0.000001;\n\n// MllerTrumbore ray-triangle intersection algorithm\n// should I use float64array? \nfunction intersectTriangle(ray, triangle) {\n   var edge1 = vec3.create(), edge2 = vec3.create();\n   /* find vectors for two edges sharing vert0 */\n   vec3.sub(edge1, triangle[1], triangle[0]);\n   vec3.sub(edge2, triangle[2], triangle[0]);\n\n   /* begin calculating determinant - also used to calculate U parameter */\n   var pvec = vec3.create();\n   vec3.cross(pvec, ray.direction, edge2);\n\n   /* if determinant is near zero, ray lies in plane of triangle */\n   var det = vec3.dot(edge1, pvec);\n\n   if (det < kEPSILON) { // cull backface, and nearly parallel ray\n      return 0.0;\n   }\n   //if (det > -kEPSILON && det < kEPSILON), nearly parallel\n   //  return 0;\n\n   var inv_det = 1.0 / det;\n\n   /* calculate distance from vert0 to ray origin */\n   var tvec = vec3.create();\n   vec3.sub(tvec, ray.origin, triangle[0]);\n\n   /* calculate U parameter and test bounds */\n   var u = vec3.dot(tvec, pvec) * inv_det;\n   if (u < 0.0 || u > 1.0) {\n     return 0.0;\n   }\n\n   /* prepare to test V parameter */\n   var qvec = vec3.create();\n   vec3.cross(qvec, tvec, edge1);\n\n   /* calculate V parameter and test bounds */\n   var v = vec3.dot(ray.direction, qvec) * inv_det;\n   if (v < 0.0 || u + v > 1.0) {\n     return 0.0;\n   }\n\n   /* calculate t, ray intersects triangle */\n   var t = vec3.dot(edge2, qvec) * inv_det;\n   return t;\n};\n\n// http://psgraphics.blogspot.com/2016/02/new-simple-ray-box-test-from-andrew.html\nfunction intersectRayAAExtent(ray, aabb) {\n   let tmin = Number.NEGATIVE_INFINITY;\n   let tmax = Number.POSITIVE_INFINITY;\n   for (let axis = 0; axis < 3; ++axis) {\n      //const invD = 1.0 / ray.direction[axis];    // expect to be precalculate.\n      let t0 = (aabb.min[axis] - ray.origin[axis]) * ray.invDir[axis];\n      let t1 = (aabb.max[axis] - ray.origin[axis]) * ray.invDir[axis];\n      if (ray.invDir[axis] < 0.0) { // swap\n         let temp = t0; t0 = t1; t1 = temp;\n      }\n      tmin = t0 > tmin ? t0 : tmin;\n      tmax = t1 < tmax ? t1 : tmax;\n      if (tmax <= tmin) {\n         return false;\n      }\n   }\n   return (tmax > 0);\n};\n\nconst intersectRaySphere = (function() {\n\t//  Fast Ray Sphere Intersection - eric haine, realtimerendering, similar to graphic gem's Jeff Hultquist\n   const l = vec3.create();\n   return function(ray, sphere) {\n      vec3.sub(l, sphere.center, ray.origin);\n\t   const l2 = vec3.dot(l, l);\n\t   const projection = vec3.dot(l, ray.direction);\n      if ((projection < 0.0) && (l2 > sphere.radius2)) { // sphere is totally behind the camera, not just sphere's origin\n         return false;\n      }\n      if ((l2 - (projection*projection)) > sphere.radius2) {   // discriminant < 0.0f, no sqrt, no intersection.\n         return false;\n      }\n\n      // don't care about true intersection of the 2, just there is a intersection.\n      return true;\n   };\n})();\n\n\nconst intersectPlaneSphere = (function() {\n   const pt = vec3.create();\n   return function(plane, sphere) {\n      closestPointToPlane(pt, sphere.center, plane);\n      return vec3.squaredDistance(pt, sphere.center) < sphere.radius2;\n   }\n})();\n\n// gamephysics cookbook.\nfunction intersectPlaneAABB(plane, box) {\n   const pLen = box.halfSize[0] * Math.abs(plane.normal[0]) + box.halfSize[1] * Math.abs(plane.normal[1]) + box.halfSize[2] * Math.abs(plane.normal[2]);\n   const distance = vec3.dot(plane.normal, box.center) - plane.distance;\n   return Math.abs(distance) <= pLen;\n};\n\n// return value:\n// -2 for no intersection\n// -1 for co planar on the plane\n// 0-1 for intersection t.\n// 0.5 when no (out) intersection pt provided.\n// algorithm\n// paul burke explain the intersection code pretty clearly.\n// same side check and coplane check are from moller.\nfunction intersectPlaneHEdge(out, plane, hEdge) {\n   const pt0 = hEdge.origin.vertex;\n   const pt1 = hEdge.destination().vertex;\n\n   let d0 = vec3.dot(plane.normal, pt0) - plane.distance; \n   let d1 = vec3.dot(plane.normal, pt1) - plane.distance;\n   // coplanarity check\n   if (Math.abs(d0) < kEPSILON) { d0=0.0; }\n   if (Math.abs(d1) < kEPSILON) { d1=0.0; }\n   \n   let t;\n   if ((d0*d1) > 0) {  // check if on the same side\n      return -2;\n   } else if (d0 == 0.0) {\n      if (d1 == 0.0) {  // co planar\n         return -1;\n      }\n      t = 0;            // intersect at begin\n   } else if (d1 == 0.0) {\n      t = 1;            // intersect at end\n   }\n\n   // compute intersection pt (out).\n   if (out) {\n      if (t === undefined) {\n         // t = (plane.normal dot (plane.pt - pt0)) / (plane.normal dot (pt1-pt0))\n         vec3.sub(out, plane.pt, pt0);\n         const tDer = vec3.dot(plane.normal, out);\n         vec3.sub(out, pt1, pt0);\n         t = tDer / vec3.dot(plane.normal, out);\n      }\n      // out = pt0 + t(pt1-pt0)\n      vec3.scaleAndAdd(out, pt0, out, t);\n   }\n\n   return (t !== undefined)? t : 0.5;  // 0.5 for intersection not 0 or 1.\n};\n\n/* from\n * @article{MollerHughes99,\n  author = \"Tomas Mller and John F. Hughes\",\n  title = \"Efficiently Building a Matrix to Rotate One Vector to Another\",\n  journal = \"journal of graphics tools\",\n  volume = \"4\",\n  number = \"4\",\n  pages = \"1-4\",\n  year = \"1999\",\n}\nhttp://jgt.akpeters.com/papers/MollerHughes99/code.html\n*/\nfunction rotationFromToVec3(mtx, from, to) {\n\n  let e = vec3.dot(from, to);\n  if (Math.abs(e) > (1.0-kEPSILON) ) { // \"from\" and \"to\"-vector almost parallel\n      // find closest axis\n      const x = vec3.fromValues(Math.abs(from[0]), Math.abs(from[1]), Math.abs(from[2]));   // vector most nearly orthogonal to \"from\"\n      if (x[0] < x[1]) {\n         if( x[0] < x[2] ) {\n            x[0] = 1.0; x[1] = x[2] = 0.0;\n         } else {\n            x[2] = 1.0; x[0] = x[1] = 0.0;\n         }\n      } else {\n         if( x[1] < x[2] ) {\n            x[1] = 1.0; x[0] = x[2] = 0.0;\n         } else {\n            x[2] = 1.0; x[0] = x[1] = 0.0;\n         }\n      }\n\n      // compute the matrix\n      let ut = vec3.fromValues(x[0] - from[0], x[1] - from[1], x[2] - from[2]);  // sub(v, x, from);\n      let vt = vec3.fromValues(x[0] - to[0],   x[1] - to[1],   x[2] - to[2]);\n\n      let c1 = 2.0 / vec3.dot(ut, ut);       // coefficients\n      let c2 = 2.0 / vec3.dot(vt, vt);\n      let c3 = c1 * c2  * vec3.dot(ut, vt);\n      for (let i = 0; i < 3; i++) {\n         let k = i*4;      // stride.\n         for (let j = 0; j < 3; j++) {\n            mtx[k+j] =  -c1 * ut[i] * ut[j] - c2 * vt[i] * vt[j] + c3 * vt[i] * ut[j];\n         }\n         mtx[k+i] += 1.0;\n      }\n   } else  {// the most common case, unless \"from\"=\"to\", or \"from\"=-\"to\" \n      let v = vec3.create();\n      vec3.cross(v, from, to);\n      // ...otherwise use this hand optimized version (9 mults less)\n      //let h = 1.0 / (1.0 + e);      // optimization by Gottfried Chen\n      let h = (1.0 -e)/ vec3.dot(v, v);\n      let hvx = h * v[0];\n      let hvz = h * v[2];\n      let hvxy = hvx * v[1];\n      let hvxz = hvx * v[2];\n      let hvyz = hvz * v[1];\n      mtx[0] = e + hvx * v[0];\n      mtx[1] = hvxy + v[2];\n      mtx[2] = hvxz - v[1];\n\n      mtx[4] = hvxy - v[2];\n      mtx[5] = e + h * v[1] * v[1];\n      mtx[6] = hvyz + v[0];\n\n      mtx[8] = hvxz + v[1];\n      mtx[9] = hvyz - v[0];\n      mtx[10] = e + hvz * v[2];\n   }\n\n   return mtx;\n};\n\n/*\nReferences\nhttps://www.opengl.org/discussion_boards/showthread.php/147784-Mirror-Matrices\nhttps://www.opengl.org/discussion_boards/showthread.php/169605-reflection-matrix-how-to-derive\n\"3D Math Primer for Graphics andGame Development\" by Fletcher Dunn, Ian Parberry\n*/\nfunction reflectionMat4(mat, norm, pt) {\n   const d = -vec3.dot(norm, pt);\n\n\tmat[0] = -2 * norm[0] * norm[0] + 1;\n\tmat[1] = -2 * norm[1] * norm[0];\n\tmat[2] = -2 * norm[2] * norm[0];\n\tmat[3] = 0;\n \n\tmat[4] = -2 * norm[0] * norm[1];\n\tmat[5] = -2 * norm[1] * norm[1] + 1;\n\tmat[6] = -2 * norm[2] * norm[1];\n\tmat[7] = 0;\n \n\tmat[8] =\t-2 * norm[0] * norm[2];\n\tmat[9] = -2 * norm[1] * norm[2];\n\tmat[10] = -2 * norm[2] * norm[2] + 1;\n\tmat[11] = 0;\n \n\tmat[12] = -2 * norm[0] * d;\n\tmat[13] = -2 * norm[1] * d;\n\tmat[14] = -2 * norm[2] * d;\n   mat[15] = 1;\n   return mat;\n};\n\n\n// angle is between (-PI, PI). equivalent to (-180, 180) degree.\nfunction computeAngle(crossNorm, v0, v1, v2) {\n   let edge0 = vec3.create(), edge1 = vec3.create();\n   // angle = pi - atan2(v[i] x v[i+1].magnitude, v[i] * v[i+1]);\n   vec3.sub(edge0, v0.vertex, v1.vertex);\n   vec3.sub(edge1, v2.vertex, v1.vertex);\n   vec3.cross(crossNorm, edge0, edge1);\n   let rad = Math.atan2(vec3.length(crossNorm), vec3.dot(edge0, edge1));\n   vec3.normalize(crossNorm, crossNorm);\n   return rad;\n}\n\nfunction getAxisAngle(axis, vFrom, vTo) {\n   vec3.cross(axis, vFrom, vTo);\n   let rad = Math.atan2(vec3.length(axis), vec3.dot(vFrom, vTo));\n   vec3.normalize(axis, axis);\n   return rad;\n   //return 2*Math.acos( Math.abs( vec3.dot(vFrom, vTo), -1, 1 ) );\n}\n\n\n// the input (left, right) is on the same Vertex.\nfunction computeEdgeNormal(normal, leftHEdge, rightHEdge) {\n   //let normal = vec3.create();\n   let radian = computeAngle(normal, leftHEdge.destination(), leftHEdge.origin, rightHEdge.destination());\n   radian = Math.abs(radian);\n   if ((radian < kEPSILON) || (radian > (Math.PI-kEPSILON))) {   // nearly parallel, now get face\n      vec3.set(normal, 0, 0, 0);\n      if (leftHEdge.face) {\n         vec3.add(normal, normal, leftHEdge.face.normal);\n      }\n      if (rightHEdge.pair.face) {\n         vec3.add(normal, normal, rightHEdge.pair.face);\n      }\n   }\n   // compute normal\n   vec3.normalize(normal, normal);\n};\n\nfunction projectVec3(vertices, planeNormal, planeOrigin) {\n   const pt = vec3.create();\n\n   for (let vertex of vertices) {\n      vec3.sub(pt, vertex.vertex, planeOrigin);\n      let d = vec3.dot(pt, planeNormal);\n      vec3.scale(pt, planeNormal, d);\n      vec3.sub(vertex.vertex, vertex.vertex, pt);\n   }\n};\n\nfunction closestPointToPlane(out, point, plane) { // projection to plane\n   const distance = vec3.dot(plane.normal, point) - plane.distance;\n   vec3.scaleAndAdd(out, point, plane.normal, -distance);\n};\n\nfunction getAxisOrder(extent) {\n   let size = vec3.create();\n   vec3.sub(size, extent.max, extent.min);\n   let first, second, third;\n   if (size[0] > size[1]) {\n      if (size[0] > size[2]) {\n         first = 0;\n         if (size[1] > size[2]) {\n            second = 1;\n            third = 2;\n         } else {\n            second = 2;\n            third = 1;\n         }\n      }\n   } else if (size[1] > size[2]) {\n\n   } else {\n\n   }\n\n   return [first, second, third];\n};\n\nfunction hexToRGB(hex) {\n   return [parseInt(hex.slice(1, 3), 16)/255,\n           parseInt(hex.slice(3, 5), 16)/255,\n           parseInt(hex.slice(5, 7), 16)/255];\n };\nfunction hexToRGBA(hex) {\n  return [parseInt(hex.slice(1, 3), 16)/255,\n          parseInt(hex.slice(3, 5), 16)/255,\n          parseInt(hex.slice(5, 7), 16)/255,\n          1.0];\n};\n\nfunction hexToCssRGBA(hex) {  // microsft edge don't support #rrggbbaa format yet, so we convert to rgba() 2018/09/24.\n   const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);\n   const a = parseInt(hex.slice(7, 9), 16) / 255;\n   return `rgba(${r}, ${g}, ${b}, ${a})`;\n};\n\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_util.js?");

/***/ }),

/***/ "./js/wings3d_vertexmads.js":
/*!**********************************!*\
  !*** ./js/wings3d_vertexmads.js ***!
  \**********************************/
/*! exports provided: VertexMadsor, VertexConnectCommand */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexMadsor\", function() { return VertexMadsor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexConnectCommand\", function() { return VertexConnectCommand; });\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/* harmony import */ var _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_facemads */ \"./js/wings3d_facemads.js\");\n/* harmony import */ var _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_bodymads */ \"./js/wings3d_bodymads.js\");\n/* harmony import */ var _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_edgemads */ \"./js/wings3d_edgemads.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_view */ \"./js/wings3d_view.js\");\n/* harmony import */ var _wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_shaderprog */ \"./js/wings3d_shaderprog.js\");\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/**\n//    This module handle most vertex edit command.\n//\n//    \n**/\n\n   // for switching\n\n\n\n\n\n\n\n\n\n\n\nclass VertexMadsor extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"Madsor\"] {\n   constructor() {\n      super('Vertex');\n      const self = this;\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_8__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].vertexConnect.name, (ev) => {\n            const vertexConnect = this.connectVertex();\n            if (vertexConnect.doIt()) {\n               _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](vertexConnect);   // saved for undo\n            } else {\n               // show no connection possible message.\n            }\n         });\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_8__[\"bindMenuItemMode\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].vertexDissolve.name, function(ev) {\n            const dissolve = new VertexDissolveCommand(self);\n            dissolve.doIt();\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](dissolve);\n         }, this, 'Delete');\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_8__[\"bindMenuItemMode\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].vertexCollapse.name, function(ev) {\n            const dissolve = new VertexCollapseCommand(self);\n            dissolve.doIt();\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"](dissolve);\n         }, this, 'Backspace');\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_8__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_9__[\"action\"].vertexWeld.name, (ev)=> {\n         let snapshot = [];\n         for (let preview of this.selectedCage()) {\n            if (preview.selectionSize() == 1) {\n               snapshot.push( preview );\n            }\n          }\n         if (snapshot.length == 1) {\n            const weld = new VertexWeldCommand(this, snapshot[0]);\n            _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"attachHandlerMouseSelect\"](weld);\n         } else {\n            geometryStatus(\"You can only Weld one vertex\");\n         }\n        });\n   }\n\n   // get selected vertex snapshot. for doing, and redo queue. \n   snapshotPosition() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotVertexPosition);\n   }\n\n   snapshotPositionAndNormal() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotVertexPositionAndNormal);\n   }\n\n   snapshotTransformGroup() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.snapshotTransformVertexGroup);\n   }\n\n   bevel() {\n      let snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.bevelVertex);\n      // change to facemode.\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"](snapshots);\n      return snapshots;\n   \n   }\n\n   undoBevel(snapshots, selection) {\n      this.restoreSelectionPosition(snapshots);\n      // collapse extrudeEdge\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.collapseSplitOrBevelEdge);\n      // restore Vertex Selection\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"](selection); \n   }\n\n   // extrude Vertex\n   extrude() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.extrudeVertex);\n   }\n   undoExtrude(extrudeData) {\n      this.doAll(extrudeData, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoExtrudeVertex);\n   }\n\n   andConnectVertex(prevCmd) {\n      const vertexConnect = new VertexConnectCommand(this);\n      if (vertexConnect.doIt()) {\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueueCombo\"]([prevCmd, vertexConnect]);\n      } else { // no connection possible\n         prevCmd.undo();\n         // post on geomoetryStatus;\n      }\n   }\n\n   connectVertex() {\n      return  new VertexConnectCommand(this);\n   }\n\n   connect() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.connectVertex);\n   };\n\n   dissolveConnect(snapshots) {\n      this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.dissolveConnect);\n   }\n\n   dissolve() {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.dissolveSelectedVertex);\n   }\n\n   undoDissolve(dissolveArray) {\n      this.doAll(dissolveArray, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.undoDissolveVertex);\n   }\n\n   flatten(axis) {\n      return this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.flattenVertex, axis);\n   }\n\n   dragSelect(cage, hilite, selectArray, onOff) {\n      if (hilite.vertex !== null) {\n        if (cage.dragSelectVertex(hilite.vertex, onOff)) {\n            selectArray.push(hilite.vertex);\n        }\n      }\n   }\n\n   selectStart(cage, hilite) {\n      if (hilite.vertex !== null) {\n         var onOff = cage.selectVertex(hilite.vertex);\n         return new DragVertexSelect(this, cage, hilite.vertex, onOff);\n      }\n      return null;\n   }\n\n   isVertexSelectable() { return true; }\n\n   _resetSelection(cage) {\n      cage._resetSelectVertex();\n   }\n\n   _restoreSelection(cage, snapshot) {\n      cage.restoreVertexSelection(snapshot);\n   }\n\n   toggleFunc(toMadsor) {\n      var redoFn;\n      var snapshots;\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromVertexToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_3__[\"EdgeMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromVertexToEdgeSelect);\n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreBodyMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromVertexToBodySelect);\n      } else {\n         redoFn = _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreMultiMode\"];\n         snapshots = this.snapshotAll(_wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.changeFromVertexToMultiSelect);\n      }\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"undoQueue\"]( new _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"ToggleModeCommand\"](redoFn, _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"], snapshots) );\n   }\n\n\n   restoreMode(toMadsor, snapshots) {\n      if (toMadsor instanceof _wings3d_facemads__WEBPACK_IMPORTED_MODULE_1__[\"FaceMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromVertexToFaceSelect);\n      } else if (toMadsor instanceof _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_3__[\"EdgeMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromVertexToEdgeSelect);\n      } else if (toMadsor instanceof _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_2__[\"BodyMadsor\"]) {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromVertexToBodySelect);\n      } else {\n         this.doAll(snapshots, _wings3d_model__WEBPACK_IMPORTED_MODULE_5__[\"PreviewCage\"].prototype.restoreFromVertexToMultiSelect);\n      }\n   }\n\n   drawExtra(gl, draftBench) {\n      // draw hilite\n      //if (this.currentEdge) {\n         gl.useShader(_wings3d_shaderprog__WEBPACK_IMPORTED_MODULE_7__[\"selectedColorPoint\"]);\n         gl.bindTransform();\n         draftBench.drawVertex(gl, this);\n         gl.disableShader();\n      //}\n   }\n} \n\nclass DragVertexSelect extends _wings3d_mads__WEBPACK_IMPORTED_MODULE_0__[\"DragSelect\"] {\n   constructor(madsor, cage, vertex, onOff) {\n      super(madsor, cage, vertex, onOff);\n   }\n\n   finish() {\n      return new VertexSelectCommand(this.select);\n   }\n}\n\nclass VertexSelectCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(select) {\n      super();\n      this.select = select;\n   }\n\n   doIt() {\n      for (var [cage, vertices] of this.select) {\n         for (var i = 0; i < vertices.length; ++i) {\n            cage.selectVertex(vertices[i]);\n         }\n      }\n   }\n\n   undo() {\n      this.doIt();   // selectVertex, flip/flop, so\n   }  \n}\n\n\nclass VertexConnectCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      // reconnect\n      this.cageArray = this.madsor.connect();\n      if (this.cageArray.length > 0) { // goes to edgeMode.\n         _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreEdgeMode\"](this.cageArray);    // abusing the api?\n         return true;\n      }\n      return false;\n   }\n\n   undo() {\n      // restore to vertexMode.\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"]();\n      // dissolve the connect edges.\n      this.madsor.dissolveConnect(this.cageArray);\n   }  \n}\n\nclass VertexDissolveCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      // dissolve, guaranteed dissolveCount > 0\n      this.dissolve = this.madsor.dissolve();\n   }\n\n   undo() {\n      this.madsor.undoDissolve(this.dissolve);\n   }\n}\n\nclass VertexCollapseCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditCommand\"] {\n   constructor(madsor) {\n      super();\n      this.madsor = madsor;\n   }\n\n   doIt() {\n      // collapse, is just like dissolve, but switch to facemode\n      this.dissolve = this.madsor.dissolve();\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreFaceMode\"](this.dissolve);\n   }\n\n   undo() {\n      this.madsor.resetSelection();\n      _wings3d_view__WEBPACK_IMPORTED_MODULE_6__[\"restoreVertexMode\"]();\n      this.madsor.undoDissolve(this.dissolve);\n   }\n}\n\n\nclass VertexWeldCommand extends _wings3d_undo__WEBPACK_IMPORTED_MODULE_4__[\"EditSelectHandler\"] {\n   constructor(madsor, preview) {\n      super(true, false, false);\n      this.madsor = madsor;\n      this.preview = preview;\n   }\n\n   hilite(hilite, currentCage) {  // no needs for currentCage\n      if ((currentCage === this.preview) && hilite.vertex) {\n         return  this.preview.weldableVertex(hilite.vertex) !== false;\n      }\n      return false;\n   }\n\n   select(hilite) { // return true for accepting, false for continue doing things.\n      const vertex = hilite.vertex;\n      if (vertex) {\n         this.collapseHEdge = this.preview.weldableVertex(vertex);\n         if (this.collapseHEdge != false) {\n            return this.doIt();\n         }\n      }\n      return false;\n   }\n\n   doIt() {\n      this.restore = this.preview.weldVertex(this.collapseHEdge);\n      return true;\n   }\n\n   undo() {\n      this.preview.undoWeldVertex(this.restore);\n   }\n}\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_vertexmads.js?");

/***/ }),

/***/ "./js/wings3d_view.js":
/*!****************************!*\
  !*** ./js/wings3d_view.js ***!
  \****************************/
/*! exports provided: prop, theme, draftBench, toggleVertexMode, toggleFaceMode, toggleEdgeMode, toggleBodyMode, toggleMultiMode, restoreVertexMode, restoreFaceMode, restoreEdgeMode, restoreBodyMode, restoreMultiMode, currentMode, putIntoWorld, moveCage, addToWorld, removeFromWorld, getWorld, updateWorld, makeCombineIntoWorld, setObject, attachHandlerMouseMove, attachHandlerMouseSelect, doCommand, redoEdit, undoEdit, undoQueue, undoQueueCombo, loadMatrices, projection, modelView, drawWorld, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prop\", function() { return prop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"theme\", function() { return theme; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draftBench\", function() { return draftBench; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleVertexMode\", function() { return toggleVertexMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleFaceMode\", function() { return toggleFaceMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleEdgeMode\", function() { return toggleEdgeMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleBodyMode\", function() { return toggleBodyMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleMultiMode\", function() { return toggleMultiMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreVertexMode\", function() { return restoreVertexMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreFaceMode\", function() { return restoreFaceMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreEdgeMode\", function() { return restoreEdgeMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreBodyMode\", function() { return restoreBodyMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreMultiMode\", function() { return restoreMultiMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentMode\", function() { return currentMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"putIntoWorld\", function() { return putIntoWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveCage\", function() { return moveCage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addToWorld\", function() { return addToWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeFromWorld\", function() { return removeFromWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getWorld\", function() { return getWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateWorld\", function() { return updateWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeCombineIntoWorld\", function() { return makeCombineIntoWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setObject\", function() { return setObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachHandlerMouseMove\", function() { return attachHandlerMouseMove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachHandlerMouseSelect\", function() { return attachHandlerMouseSelect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"doCommand\", function() { return doCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"redoEdit\", function() { return redoEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoEdit\", function() { return undoEdit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoQueue\", function() { return undoQueue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"undoQueueCombo\", function() { return undoQueueCombo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadMatrices\", function() { return loadMatrices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projection\", function() { return projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modelView\", function() { return modelView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawWorld\", function() { return drawWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony import */ var _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_ui */ \"./js/wings3d_ui.js\");\n/* harmony import */ var _wings3d_render__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wings3d_render */ \"./js/wings3d_render.js\");\n/* harmony import */ var _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wings3d_camera */ \"./js/wings3d_camera.js\");\n/* harmony import */ var _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wings3d_gl */ \"./js/wings3d_gl.js\");\n/* harmony import */ var _plugins_wavefront_obj__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/wavefront_obj */ \"./js/plugins/wavefront_obj.js\");\n/* harmony import */ var _wings3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./wings3d */ \"./js/wings3d.js\");\n/* harmony import */ var _wings3d_undo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wings3d_undo */ \"./js/wings3d_undo.js\");\n/* harmony import */ var _wings3d_facemads__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wings3d_facemads */ \"./js/wings3d_facemads.js\");\n/* harmony import */ var _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./wings3d_edgemads */ \"./js/wings3d_edgemads.js\");\n/* harmony import */ var _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./wings3d_vertexmads */ \"./js/wings3d_vertexmads.js\");\n/* harmony import */ var _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./wings3d_bodymads */ \"./js/wings3d_bodymads.js\");\n/* harmony import */ var _wings3d_multimads__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./wings3d_multimads */ \"./js/wings3d_multimads.js\");\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var _wings3d_draftbench__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./wings3d_draftbench */ \"./js/wings3d_draftbench.js\");\n/* harmony import */ var _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./wings3d_boundingvolume */ \"./js/wings3d_boundingvolume.js\");\n/* harmony import */ var _wings3d_hotkey__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./wings3d_hotkey */ \"./js/wings3d_hotkey.js\");\n/* harmony import */ var _wings3d_util__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./wings3d_util */ \"./js/wings3d_util.js\");\n/* harmony import */ var _wings3d_uitree__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./wings3d_uitree */ \"./js/wings3d_uitree.js\");\n/* harmony import */ var _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./wings3d_mads */ \"./js/wings3d_mads.js\");\n/*\n//     This module implements most of the commands in the View menu. \n//\n// Original Erlang Version: Bjorn Gustavsson\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// \n// pref and theme\n//\n// init Prop\nconst prop = {\n      showEdges: true,\n      showBackfaces: true,\n      showNormals: false,\n      showBB: true,\n      showBBCenter: true,\n      showColors: true,\n      showMaterials: true,\n      showTextures: true,\n      showNormalMaps: true,\n      showWireBackfaces: false,\n      showGroundplane: true,\n      showCamImagePlane: false,\n      showAxes: true,\n      infoVerbose: false,\n      constrainAxes: true,\n      clipPlane: false,\n      orthogonalView: false,\n      filterTexture: true,\n      frameDisregardsMirror: false,\n      useSceneLights: false,\n      forceOrthoAlongAxis: false,\n      workmode: true,\n      //wireFramedObjects: gb_sets:empty(),\n      //currentView: DEFAULT_VIEW,   // goes to camera\n      allowRotation: true,\n      allowInfoText: true,\n      miniAxis: true\n   };\nconst propExtend = {\n   numberOfLights: 1,\n   activeShader: 1,\n};\nconst theme = {\n       activeVectorColor: [0.0, 1.0, 0.0],\n       clipPlaneColor: [0.8, 0.3, 0.0],\n       defaultAxis: [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]],\n       gridColor: '#4D4D4D',\n       \n       draftBench: {\n         edgeColor: '#000000',\n         hardEdgeColor: '#FF8000',\n         selectedColor: '#A60000',\n         selectedHilite: '#B3B300',\n         unselectedHilite: '#00A600',\n         vertexColor: '#000000',\n         //maskedVertexColor: '#80FF00', // alpha #0.8,\n         faceColor: '#C9CFB1',   // materialDefault\n         sculptMagnetColor: '#0000FF',  // alpha #0.1\n         tweakMagnetColor: '#0000FF',  // alpha #0.06\n         tweakVectorColor: '#FF8000',\n       },\n\n       draftBenchPref: {\n         vertexSize: 4.0,\n         selectedVertexSize: 5.0,\n         maskedVertexSize: 8.0,\n         edgeWidth: 2.0,\n         selectedEdgeWidth: 2.0,\n         hardEdgeWidth: 2.0,\n       },\n\n       normalVectorColor: [0.0, 1.0, 0.0],\n       colorX: '#B3001A',\n       colorY: '#5FD100',\n       colorZ: '#004DCC',\n       negColorX: '#CCCCCC',\n       negColorY: '#CCCCCC',\n       negColorZ: '#CCCCCC',\n       // UserInterface'\n       geometryBackground: '#CCCCCC',\n       css: {\n         menubarBackground: '#3C3B37',\n         menubarText: '#FFFFFF',\n         menuBackground: '#3C3B37',\n         menuText: '#FFFFFF',\n         menuHighlight: '#F07746',\n         menuHighlightText: '#FFFFFF',\n         infoLineBackground: '#F2F1F0',\n         infoLineText: '#4C4C4C',\n         infoBackground: '#6161617F',\n         infoText: '#FFFFFF',\n       },\n   };\nconst themeAlpha = {\n   geometryBackground: 'FF',\n   infoBackground: '7F',\n};\n/*const getThemeProp = (path) => (\n   path.split('.').reduce((acc, part) => acc && acc[part], theme)\n);*/\nfunction traverse(obj, loadStore) {\n   Object.entries(obj).forEach(([key, value]) => {\n      if ((typeof value === \"object\") && !Array.isArray(value)) {\n         traverse(value, loadStore);\n      } else {\n         loadStore(obj, key, value);\n      }\n    });\n}\nfunction loadPref(form) {\n   traverse(theme, (_obj, key, value)=> {\n      let data = form.querySelector(`input[type=color][name=${key}]`);\n      if (data) {\n         if (value.length === 9) {  // no support of #rrggbbaa yet, for colorpicker.\n            data.value = value.slice(0, 7);\n         } else {\n            data.value = value;\n         }\n      }\n      data = form.querySelector(`input[type=number][name=${key}]`);\n      if (data) {\n         data.value = value;\n      }    \n    });\n   // load prop\n   traverse(prop, (_obj, key, value)=> {\n      const data = form.querySelector(`input[type=checkbox][name=${key}]`);\n      if (data) {\n         data.checked = value;\n      }\n    });\n   // load pref\n   traverse(prop, (_obj, key, value)=> {\n\n    });\n};\nfunction storePref(form) {\n   traverse(theme, (obj, key, _value) => {\n      let data = form.querySelector(`input[type=color][name=${key}]`);\n      if (data) {\n         obj[key] = themeAlpha[key] ? (data.value + themeAlpha[key]) : data.value;\n      }\n      data = form.querySelector(`input[type=number][name=${key}]`);\n      if (data) {\n         obj[key] = data.value;\n      }\n    });\n   // now update css variable.\n   const root = document.documentElement;\n   Object.entries(theme.css).forEach(([key, value]) => {\n      // put the css to styleSheet\n      if (value.length === 7) {\n         root.style.setProperty(`--${key}`, value);\n      } else if (value.length === 9) {\n         root.style.setProperty(`--${key}`, _wings3d_util__WEBPACK_IMPORTED_MODULE_16__[\"hexToCssRGBA\"](value));\n      }\n    });\n   // store draftBench\n   draftBench.setTheme(theme.draftBench, theme.draftBenchPref);\n   // store prop\n   traverse(prop, (obj, key, _value)=> {\n      const data = form.querySelector(`input[type=checkbox][name=${key}]`);\n      if (data) {\n         obj[key] = data.checked;\n      }\n    });\n    _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n};\n\n//--  end of pref and theme --------------------------------------------------------------------------\n\n// \n// editing mode management\n//\nconst mode = {             // private variable, needed to initialize after gl, \n   face: null,//new FaceMadsor, \n   edge: null,//new EdgeMadsor,\n   vertex: null,//new VertexMadsor,\n   body: null,//new BodyMadsor,\n   multi: null,//new Multimode\n   current: null,\n};\nfunction initMode() {\n   mode.face = new _wings3d_facemads__WEBPACK_IMPORTED_MODULE_7__[\"FaceMadsor\"];\n   mode.edge = new _wings3d_edgemads__WEBPACK_IMPORTED_MODULE_8__[\"EdgeMadsor\"];\n   mode.vertex = new _wings3d_vertexmads__WEBPACK_IMPORTED_MODULE_9__[\"VertexMadsor\"];\n   mode.body = new _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_10__[\"BodyMadsor\"];\n   mode.multi = new _wings3d_multimads__WEBPACK_IMPORTED_MODULE_11__[\"MultiMadsor\"];\n   mode.current = mode.multi;\n};\n\n\nfunction toggleMode(mode) {\n   let button = document.getElementById('toggle'+mode+'Mode');  // :checked property only existed on <input>\n   if (button && !button.checked) {\n      button.click();         // https://stackoverflow.com/questions/8206565/check-uncheck-checkbox-with-javascript\n   }\n}\nfunction isMultiMode() {\n   return mode.current === mode.multi;\n};\nfunction toggleVertexMode() {\n   // change current mode to \n   if (mode.current !== mode.vertex) {\n      mode.current.toggleFunc(mode.vertex);\n      mode.current = mode.vertex;\n      toggleMode('Vertex');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction toggleFaceMode() {\n   if (mode.current !== mode.face) {\n      mode.current.toggleFunc(mode.face);\n      mode.current = mode.face;\n      toggleMode('Face');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction toggleEdgeMode() {\n   if (mode.current !== mode.edge) {\n      mode.current.toggleFunc(mode.edge);\n      mode.current = mode.edge;\n      toggleMode('Edge');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction toggleBodyMode() {\n   if (mode.current !== mode.body) {\n      mode.current.toggleFunc(mode.body);\n      mode.current = mode.body;\n      toggleMode('Body');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction toggleMultiMode() {\n   if (mode.current !== mode.multi) {\n      mode.current.toggleFunc(mode.multi);\n      mode.current = mode.multi;\n      toggleMode('Multi');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction restoreVertexMode(snapshots) {\n   if (mode.current !== mode.vertex) {\n      mode.current.restoreMode(mode.vertex, snapshots);\n      mode.current = mode.vertex;\n      toggleMode('Vertex');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // bad state. should always be in other mode. \n   }\n};\n\nfunction restoreFaceMode(snapshots) {\n   if (mode.current !== mode.face) {\n      mode.current.restoreMode(mode.face, snapshots);\n      mode.current = mode.face;\n      toggleMode('Face');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // bad state. should always be in other mode. \n   }\n};\n\nfunction restoreEdgeMode(snapshots) {\n   if (mode.current !== mode.edge) {\n      mode.current.restoreMode(mode.edge, snapshots);\n      mode.current = mode.edge;\n      toggleMode('Edge');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // bad state. should always be in other mode. \n   }\n};\n\nfunction restoreBodyMode(snapshots) {\n   if (mode.current !== mode.body) {\n      mode.current.restoreMode(mode.body, snapshots);\n      mode.current = mode.body;\n      toggleMode('Body');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // bad state. should always be in other mode. \n   }\n};\n\nfunction restoreMultiMode(snapshots) {\n   if (mode.current !== mode.multi) {\n      mode.current.restoreMode(mode.multi, snapshots);\n      mode.current = mode.multi;\n      toggleMode('Multi');\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // bad state. should always be in other mode. \n   }\n};\n\nconst currentMode = () => mode.current;\n//- End of editing Mode ----------\n\n//\n// world objects management\n//\nconst world = new _wings3d_model__WEBPACK_IMPORTED_MODULE_12__[\"PreviewGroup\"];    // private var\nlet draftBench;      // = new DraftBench; wait for GL\nlet geometryGraph;   // tree management of world; \nlet imageList;       // list management of image List.\nlet currentObjects;\nlet currentParent;\nfunction putIntoWorld() {\n   let model = new _wings3d_model__WEBPACK_IMPORTED_MODULE_12__[\"PreviewCage\"](draftBench);\n   return addToWorld(model);\n};\nfunction moveCage(newParent, model) {  // drag & drop\n   model.removeFromParent();\n   newParent.insert(model);\n   world.numberOfCage();   // update Count Status\n};\n\nfunction addToWorld(model, parent = world) { // default parent is world\n   parent.insert( model );\n   geometryGraph.addObject(model, parent.guiStatus.ul);\n   model.setVisible(true);\n   draftBench.updatePreview();\n   _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   world.numberOfCage();   // update CountStatus\n   return model;\n}\n\nfunction removeFromWorld(previewCage) {\n   const deleted = previewCage.removeFromParent();\n   if (deleted) {\n      previewCage.setVisible(false);\n      draftBench.updatePreview();\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n      // remove from geometryGraph\n      geometryGraph.removeObject(previewCage);\n      world.numberOfCage();   // update CountStatus.\n   }\n   return deleted;\n};\nfunction getWorld() {\n   return world.getCage();\n}\nfunction updateWorld() {\n   draftBench.updatePreview();\n   _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n};\nfunction makeCombineIntoWorld(cageSelection) {\n   let combine = new _wings3d_model__WEBPACK_IMPORTED_MODULE_12__[\"PreviewCage\"](draftBench);\n   for (let cage of cageSelection) {\n      removeFromWorld(cage);\n   }\n   combine.merge(cageSelection); // new cage + merged polygons.\n   addToWorld(combine);\n   return combine;\n}\nfunction setObject(parent, objects) { // objects is array\n   currentObjects = objects;\n   currentParent = parent;\n}\n//-- End of World objects management ----------------dra---------\n\n//\n// mouse handling hilite\n//\nconst hilite = {cage: null, edge: null, vertex: null, face: null, plane: null};\nlet currentCage;\nconst handler = {camera: null, mousemove: null, mouseSelect: null};\nconst planeRect = {center: vec3.create(), halfSize: vec3.create(), normal: vec3.create(), hilite: false};\n\n\nconst isVertexSelectable = () => handler.mouseSelect ? handler.mouseSelect.isVertexSelectable() : (mode.current ? mode.current.isVertexSelectable() : true);\nconst isEdgeSelectable = () => handler.mouseSelect ? handler.mouseSelect.isEdgeSelectable() : (mode.current ? mode.current.isEdgeSelectable() : true);\nconst isFaceSelectable = () => handler.mouseSelect ? handler.mouseSelect.isFaceSelectable() : (mode.current ? mode.current.isFaceSelectable() : true);\nconst isPlaneShown = ()=> handler.mouseSelect ? handler.mouseSelect.getPlaneNormal() : false;\n\nfunction setCurrent(edge, intersect, center) {\n   // find out origin, dest. which is closer.\n   let hiliteVertex = null, hiliteEdge = null, hiliteFace = null, hiliteCage = null;\n   hilite.plane = null;\n   if (edge !== null) {\n      const a = vec3.create(), b = vec3.create(), c = vec3.create();\n      const destination = edge.destination().vertex; // find out if we are within the distance threshold\n      const origin = edge.origin.vertex;\n      vec3.sub(a, intersect, origin);\n      vec3.sub(b, intersect, destination);\n      vec3.sub(c, destination, origin);\n      const dist0 = vec3.length(a);\n      const dist1 = vec3.length(b);\n      const dist2 = vec3.length(c);\n      const threshold = dist2 / 4.0;\n      const isVertex = isVertexSelectable();\n      const isEdge = isEdgeSelectable();\n      const isFace = isFaceSelectable();\n      const isPlane = isPlaneShown();\n      const sphere = draftBench.boundingSpheres[edge.face.index];\n      if (isPlane) {\n         vec3.copy(planeRect.halfSize, sphere.getBVHRoot().getHalfSize());\n         vec3.copy(planeRect.normal, handler.mouseSelect.getPlaneNormal());\n      }\n      if (isVertex) {\n         if (dist0 < dist1) {\n            if (!(isEdge || isFace) || (dist0 < threshold)) {  // only multiple selectable needs to check threshold\n               hiliteVertex = edge.origin;\n            }\n         } else {\n            if (!(isEdge || isFace) || (dist1 < threshold)) {\n               hiliteVertex = edge.destination();\n            }\n         }\n         if (hiliteVertex && isPlane) {\n            vec3.copy(planeRect.center, hiliteVertex.vertex);\n            hilite.plane = planeRect;\n         }\n      }\n      if (isEdge && (hiliteVertex === null)) { // check out if edge is close enough\n         vec3.cross(a, a, b);\n         vec3.sub(b, destination, origin);\n         const distance = vec3.length(a) / dist2;\n         if (!(isVertex || isFace) || (distance < threshold)) {\n            hiliteEdge = edge;\n            if (isPlane) {\n               vec3.add(planeRect.center, hiliteEdge.origin.vertex, hiliteEdge.destination().vertex);\n               vec3.scale(planeRect.center, planeRect.center, 0.5);\n               hilite.plane = planeRect;\n            }\n         }\n      }\n      if (isFace && (hiliteVertex === null) && (hiliteEdge === null)) {   // now hilite face\n         hiliteFace = edge.face;\n         if (isPlane) {\n            vec3.copy(planeRect.center, sphere.center);\n            hilite.plane = planeRect;\n         }\n      }\n      if (!(isVertex || isEdge || isFace)) {    // all 3 mode not true then only bodyMode possible.\n         hiliteCage = currentCage;\n      }\n   }\n   // now do hilite.\n   if (hiliteVertex !== hilite.vertex) {  \n      if (hilite.vertex !== null) {\n         draftBench.hiliteVertex(hilite.vertex, false);\n      }\n      if (hiliteVertex !== null) {\n         if (handler.mouseSelect && !handler.mouseSelect.hilite( {vertex: hiliteVertex, plane: hilite.plane}, currentCage)) {\n            hiliteVertex = null;\n         } else {\n            draftBench.hiliteVertex(hiliteVertex, true);\n         }\n      }\n      hilite.vertex = hiliteVertex;\n   }\n   if (hiliteEdge !== hilite.edge) {\n      if (hilite.edge !== null) {\n         draftBench.hiliteEdge(hilite.edge, false);\n      }\n      if (hiliteEdge !== null) {\n         if (handler.mouseSelect && !handler.mouseSelect.hilite( {edge: hiliteEdge, plane: hilite.plane}, currentCage)) {\n            hiliteEdge = null;\n         } else {\n            draftBench.hiliteEdge(hiliteEdge, true);\n         }\n      }\n      hilite.edge = hiliteEdge;\n   }\n   if (hiliteFace !== hilite.face) {\n      if (hilite.face !== null) {\n         draftBench.hiliteFace(hilite.face, false); // hiliteFace(null, false)?\n      }\n      if (hiliteFace !== null) {\n         if (handler.mouseSelect && !handler.mouseSelect.hilite( {face: hiliteFace, plane: hilite.plane}, currentCage)) {\n            hiliteFace = null;\n         } else {\n            draftBench.hiliteFace(hiliteFace, true);\n         }\n      }\n      hilite.face = hiliteFace;\n   }\n   if (hiliteCage !== hilite.cage) {\n      if (hilite.cage !== null) {\n         hilite.cage.hiliteBody(false);\n      }\n      if (hiliteCage) {\n         hiliteCage.hiliteBody(true);\n      }\n      hilite.cage = hiliteCage;\n   }\n   if (!(hilite.vertex || hilite.edge || hilite.face)) {\n      hilite.plane = null;\n   }\n}\n\n\n//\n// mouse handling\n//\nlet lastPick = null;\n\nfunction rayPick(ray) {\n   let pick = null;\n   for (let model of world.getCage()) {\n      if (!model.isLock() && model.isVisible()) {\n         const newPick = model.rayPick(ray);\n         if (newPick !== null) {\n            if ((pick === null) || (pick.t > newPick.t)) {\n               pick = newPick;\n            }\n         }\n      }\n   }\n   if (pick !== null) {\n      currentCage = pick.model;\n      //if (lastPick !== null && lastPick.model !== pick.model) {\n      //   lastPick.model.setCurrentSelect(null);\n      //}\n      // now set current edge again.\n      lastPick = pick;\n      let intersect = vec3.create();\n      vec3.scaleAndAdd(intersect, ray.origin, ray.direction, pick.t);\n      setCurrent(pick.edge, intersect, pick.center);\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      if (lastPick !== null) {\n         // deselect last selection\n         setCurrent(null);\n         _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n      }\n   }\n   // now the currentPick will be the next lastPick.\n   lastPick = pick;\n};\n\nlet dragMode = null;\nfunction selectStart() {\n   if (lastPick !== null) {   \n      // first check if we needs to autoToggle\n      mode.current.toggleMulti(hilite);\n      // now we can safely dragStart\n      dragMode = mode.current.selectStart(lastPick.model, hilite);\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction selectDrag() {\n   if ((dragMode !== null)) {// &&\n       if ((lastPick !== null)) {\n         dragMode.dragSelect(lastPick.model, hilite);\n         _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n      }\n   }\n}\n\nfunction selectFinish() {\n   if (dragMode !== null) {\n      undoQueue(dragMode.finish());\n      dragMode = null;\n   }\n}\n\nfunction canvasHandleMouseDown(ev) {\n   if (ev.button == 0) {\n      if (handler.camera !== null) {\n         handler.camera.doIt();  \n         handler.camera = null;\n         _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"log\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].cameraModeExit, _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"]);\n         help('L:Select   M:Start Camera   R:Show Menu   [Alt]+R:Tweak menu');      \n      } else if (handler.mousemove !== null) {\n         undoQueue( handler.mousemove );  // put on queue, commit()?\n         handler.mousemove = null;\n      } else if (handler.mouseSelect !== null) {\n         if (handler.mouseSelect.select(hilite)) {\n            if (handler.mouseSelect.isMoveable()) {   // now do mousemove.\n               // handler.mousemove must be null.\n               handler.mousemove = handler.mouseSelect;\n            } else {\n               undoQueue( handler.mouseSelect );\n            }\n            handler.mouseSelect = null;\n         }\n      } else {\n         //e.stopImmediatePropagation();\n         // ask view to select current hilite if any.\n         selectStart();\n      }\n   }\n};\n\nfunction canvasHandleMouseEnter(ev) {\n   if (handler.camera !== null) {\n      help('L:Accept   M:Drag to Pan  R:Cancel/Restore to View   Move mouse to tumble');\n   } else {\n      help('L:Select   M:Start Camera   R:Show Menu   [Alt]+R:Tweak menu');\n   }\n};\n\nfunction canvasHandleMouseLeave(ev) {\n   selectFinish();       // we can't caputre mouseup when mouse leave, so force to finish the selection.\n};\n\n// event handling, switching state if needs to be\nfunction canvasHandleMouseUp(ev) {\n   if (ev.button == 0) {\n      selectFinish();\n   } else if (ev.button == 1) { // check for middle button down\n      if (handler.camera === null) {\n         ev.stopImmediatePropagation();\n         // let camera handle the mouse event until it quit.\n         handler.camera = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"getMouseMoveHandler\"]();\n         // tell tutor step, we are in camera mode\n         _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"log\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].cameraModeEnter, _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"]);\n         help('L:Accept   M:Drag to Pan  R:Cancel/Restore to View   Move mouse to tumble');\n         // disable mouse cursor\n         //document.body.style.cursor = 'none';\n      } \n   }\n};\n\nfunction canvasHandleMouseMove(e) {\n   if (handler.camera !== null) {\n      handler.camera.handleMouseMove(e);\n   } else if (handler.mousemove !== null) {\n      handler.mousemove.handleMouseMove(e, _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"]);\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   } else {\n      // handle pick selection\n      var viewport = _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].getViewport();\n      var winx = e.pageX - e.currentTarget.offsetLeft;\n      var winy = (viewport[3]+1) - (e.pageY - e.currentTarget.offsetTop);   // y is upside-down\n      // yes, sometimes mouse coordinate is outside of the viewport. firefox is larger than width, height.\n      if (winx < 0) { winx = 0; }\n      if (winx > viewport[2]) { winx = viewport[2];}\n      if (winy < 0) { winy = 0; }\n      if (winy > viewport[3]) { winy = viewport[3];}\n\n      var mat = loadMatrices(false);\n      var ptNear = _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].unProject(winx, winy, 0.0, mat.modelView, mat.projection);\n      var ptFar = _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].unProject(winx, winy, 1.0, mat.modelView, mat.projection);\n\n      vec3.sub(ptFar, ptFar, ptNear);\n      vec3.normalize(ptFar, ptFar);\n      const ray = new _wings3d_boundingvolume__WEBPACK_IMPORTED_MODULE_14__[\"Ray\"](ptNear, ptFar);\n      //geometryStatus(\"mouse position: \" + ptNear[0] + \", \" + ptNear[1] + \",\" + ptNear[2] + \", <br />\"+ ptFar[0] + \", \" + ptFar[1] + \", \" + ptFar[2]);\n      rayPick(ray);\n      // selectDrag if left button mousedown\n      selectDrag();\n   }\n};\n\n// contextMenu, mouse right click.\nfunction canvasHandleContextMenu(ev) {\n   if (handler.camera || handler.mousemove || handler.mouseSelect) {\n      // prevent propagation.\n      ev.preventDefault();\n      ev.stopImmediatePropagation();      // prevent document's contextmenu popup\n      if (handler.camera) {\n         handler.camera.undo();\n         handler.camera = null;\n         _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"log\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].cameraModeExit, _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"]);   // log action\n         help('L:Select   M:Start Camera   R:Show Menu   [Alt]+R:Tweak menu');\n      } else if (handler.mousemove) {\n         handler.mousemove.undo();\n         handler.mousemove = null;\n         _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n      } else {\n         handler.mouseSelect = null;   // no needs to undo because we havent doIt() yet.\n         _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n      }\n      return true;\n   }\n   // let wings3d_contextmenu handle the event.\n   return false;\n};\n\n// handling in reverse order. the newest one will handle the event. (should be at most 2 handler)\nfunction attachHandlerMouseMove(mousemoveHandler) {\n   // should we make sure handler.mousemove is null?\n   handler.mousemove = mousemoveHandler;\n};\nfunction attachHandlerMouseSelect(mouseSelectHandler) {\n   handler.mouseSelect = mouseSelectHandler;\n};\n\nfunction canvasHandleWheel(e) {\n   // adjusting to scroll pixels, inspiration from facebook's estimate.\n   var px = e.deltaX, py = e.deltaY, pz = e.deltaZ;\n   if ((px || py || pz) && e.deltaMode) {\n      var scale = 360;        // page scaler\n      if (e.deltaMode == 1) {\n         scale = 18;          // line scaler, should be line height\n      }\n      px *= scale;\n      py *= scale;\n      pz *= scale;\n   }\n   \n   // asks camera to zoomIn/Out.\n   _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"zoomStep\"](py);\n};\n\n//-- end of mouse handling-----------------------------------------------\n\n// \n// undo/redo handling\n//\nconst undo = {queue: [], current: -1};\n// undo queueCombo, convenient functions\nfunction undoQueueCombo(editCommands) {\n   // wrap the array in a combo\n   const combo = new _wings3d_undo__WEBPACK_IMPORTED_MODULE_6__[\"EditCommandCombo\"](editCommands);\n   undoQueue( combo );\n};\n// undo queue\nfunction undoQueue(editCommand) {\n   //if (!editCommand.doIt()) {  // move all check here.\n   //   return;\n   //}\n   // editCommand = new CheckPoint(draftBench, editCommand);      // debug purpose. \n\n   while ( (undo.queue.length-1) > undo.current ) {\n      // remove branch not taken\n      const cmd = undo.queue.pop();\n      cmd.free();\n   }\n   // now push the new command back\n   undo.queue.push(editCommand);\n   undo.current++;\n   _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n};\n\nfunction redoEdit() {\n   if ( (undo.queue.length-1) > undo.current) {\n      undo.queue[++undo.current].doIt(mode.current);\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction undoEdit() {\n   if (undo.current >= 0) {\n      const cmd = undo.queue[undo.current--];\n      cmd.undo(mode.current);\n      _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n   }\n};\n\nfunction doCommand(command) {\n   if (command.doIt()) {\n      undoQueue(command);\n      return true;\n   } else {\n      // todo: pop messages, said command not workable.\n      return false;\n   }\n}\n\n// -- end of undo/redo handling ----------------------------------------------------------------------------------\n\n\n//\n// world rendering and utility functions\n//\nfunction loadMatrices(includeLights) {\n   let proj = projection(mat4.create()); // passed identity matrix.\n   let tmm = modelView(includeLights);\n   return { projection: proj, modelView: tmm.modelView, useSceneLights: tmm.useSceneLights };\n};\n\n//projection() ->\n//     OP0 = gl:getDoublev(?GL_PROJECTION_MATRIX),\n//     projection(e3d_transform:init(list_to_tuple(OP0))).\nfunction projection(In) {\n   const size = _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].getViewport();\n   const aspect = (size[2]-size[0]) / (size[3]-size[1]);\n   const view = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"];\n   const ortho = prop.orthogonalView;\n   if (!ortho && view.alongAxis) {\n      ortho = prop.force_ortho_along_axis;\n   }\n   var tp = mat4.create();\n   if (ortho) {\n      const sz = view.distance * Math.tan(view.fov * Math.PI  / 180 / 2);\n      mat4.ortho(tp, -sz * aspect, sz * aspect, -sz, sz, view.zNear, view.zFar);      \n   } else {\n      mat4.perspective(tp, view.fov, aspect, view.zNear, view.zFar);\n   }\n\n   mat4.mul(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].projection, In, tp);\n   return _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].projection;\n};\n\nfunction modelView(includeLights = false) {\n   const view = _wings3d_camera__WEBPACK_IMPORTED_MODULE_2__[\"view\"];\n\n   let useSceneLights = false;\n   if (includeLights) {\n      useSceneLights = prop.useSceneLights; // && Wings3D.light.anyEnabledLights();\n      if (!useSceneLights) {\n         //Wings3D.light.cameraLights();\n      }\n   }\n\n   // fromTranslation, identity * vec3. modelView rest.\n   mat4.fromTranslation(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, vec3.fromValues(view.panX, view.panY, -view.distance));\n   mat4.rotateX(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, view.elevation * Math.PI / 180);\n   mat4.rotateY(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, view.azimuth * Math.PI / 180);\n   mat4.translate(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView, view.origin);\n\n   if (useSceneLights) {\n      //Wings3D.light.globalLights();\n   }\n   return {useScentLights: useSceneLights, modelView: _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].modelView};\n};\n\nfunction drawWorld(gl) {\n   //if (world.length > 0) {\n      // update selectStatus\n      let count = 0;\n      for (let model of world.getCage()) {\n         model.updateStatus();\n         ++count;\n      }\n      if (count === 0) {\n         return;\n      }\n\n      //gl.enable(gl.BLEND);\n      //gl.blendFunc(gl.SRC_COLOR, gl.DST_COLOR);\n      // draw Current Select Mode (vertex, edge, or face)\n      //if (hilite.vertex || hilite.edge || hilite.face || hilite.cage) {\n         mode.current.drawExtra(gl, draftBench);\n      //}\n      // hack -- draw other hilite selection if any, really should move to multimode\n      if (hilite.vertex && (mode.current !== mode.vertex)) {\n         mode.vertex.drawExtra(gl, draftBench);\n      }\n      if (hilite.edge && (mode.current !== mode.edge)) {\n         mode.edge.drawExtra(gl, draftBench);\n      }\n      if (hilite.face && (mode.current !== mode.face)) {\n         mode.face.drawExtra(gl, draftBench);\n      }\n      // hack - draw plane\n      if (hilite.plane) {\n         draftBench.drawPlane(gl, hilite.plane);\n      }\n      // end of hack ----\n      //gl.disable(gl.BLEND);\n\n      // draw all other edge (extra, hardEdge, wireframeEdge) if applicable\n      draftBench.drawHardEdgeEtc(gl, mode.current === mode.edge, mode.current);\n\n      //gl.polygonOffset(1.0, 1.0);          // Set the polygon offset\n      //gl.enable(gl.POLYGON_OFFSET_FILL);\n      mode.current.previewShader(gl);\n      //world.forEach(function(model, _index, _array){\n         gl.bindTransform();\n         draftBench.draw(gl, mode.current);\n      //});\n      gl.disableShader();\n      //gl.disable(gl.POLYGON_OFFSET_FILL);\n   //}\n}\n\nfunction render(gl) {\n   _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"render\"](gl, drawWorld);\n};\n\n//-- end of world rendering and utility functions ---------------------------------------------------------------\n\n//\n// initialization\n//\nfunction init() {\n   initMode();\n   // init menu\n   const selectionMenu = [ {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].deselect, fn: 'resetSelection', hotKey: ' '},\n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].more, fn: 'moreSelection', hotKey: '+'},\n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].less, fn: 'lessSelection', hotKey: '-'},\n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].similar, fn: 'similarSelection', hotkey: 'i'},\n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].all, fn: 'allSelection', hotKey: 'a', meta: 'ctrl'}, \n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].invert, fn: 'invertSelection', hotKey: 'i', meta: 'ctrl+shift'},\n                         {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].adjacent, fn: 'adjacentSelection'}\n                        ];\n   for (let select of selectionMenu) {\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](select.id.name, function(ev) {\n         const command = new _wings3d_undo__WEBPACK_IMPORTED_MODULE_6__[\"EditCommandSimple\"](select.fn);\n         if(command.doIt(mode.current)) {\n            undoQueue( command );\n         }\n      }, select.hotKey, select.meta);\n   }\n\n   // toggle sidebar\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].openSidebar.name, (ev) => {\n      const sidebar = document.querySelector('#sidebar');\n      const toggle = document.querySelector('#openSidebarFor');\n      if (sidebar && toggle) {\n         if (toggle.checked) {\n            sidebar.style.display = \"none\";\n         } else {\n            sidebar.style.display = \"flex\";\n         }\n      }\n    });\n   const toolBar = [ {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].undoEdit, fn: undoEdit, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].redoEdit, fn: redoEdit, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleVertexMode, fn: toggleVertexMode, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleEdgeMode, fn: toggleEdgeMode, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleFaceMode, fn: toggleFaceMode, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleBodyMode, fn: toggleBodyMode, hotKey: ' '},\n                     {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleMultiMode, fn: toggleMultiMode, hotkey: ' '},\n                   ];\n   // bindMenu toolbar\n   for (let button of toolBar) {\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](button.id.name, function(ev) {\n         //ev.preventDefault();\n         help( \"wings3d - \" + ev.currentTarget.id);\n         button.fn();\n       });\n   }\n   const propBar = [{id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleGround, propName: 'showGroundplane', selector: '#toggleGroundFor'},\n                    {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleAxes, propName: 'showAxes', selector: '#toggleAxesFor'},\n                    {id: _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleOrtho, propName: 'orthogonalView', selector: '#toggleOrthoFor'}];\n   for (let button of propBar) {\n      // bind showGrid/showAxes/persp-ortho button\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](button.id.name, (_ev)=> {\n         const data = document.querySelector(button.selector);\n         if (data) {\n            prop[button.propName] = !data.checked;  // click event is earlier than input.checked event, so the value hasn't toggle yet.\n            _wings3d_render__WEBPACK_IMPORTED_MODULE_1__[\"needToRedraw\"]();\n         }\n       });\n   }\n   // bind pref button\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].preferenceButton.name, (_ev)=>{\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"runDialogCenter\"]('#preferenceForm', storePref, loadPref);\n    });\n\n   // bind createMaterial button.\n\n   // bind geometryGraph\n   geometryGraph = _wings3d_uitree__WEBPACK_IMPORTED_MODULE_17__[\"getTreeView\"]('#objectListLabel','#objectList', world);\n   // selectObject\n   _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"bindAction\"](null, 0, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleObjectSelect.name, (ev) => {\n      if (isMultiMode()) {\n         toggleFaceMode(); // todo: see if we can capture the toggling cmd.\n      }\n      const toggle = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"ToggleCheckbox\"](ev.target);\n      const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"GenericEditCommand\"](currentMode(), currentMode().selectObject, [currentObjects, ev.target], \n                                                        currentMode().undoSelectObject, [ev.target]);\n      cmd.doIt();\n      undoQueueCombo([toggle, cmd]);\n    });\n   // hide/show Object\n   _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"bindAction\"](null, 0, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleObjectVisibility.name, (ev) => {\n      const toggle = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"ToggleCheckbox\"](ev.target);\n      const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"GenericEditCommand\"](currentMode(), currentMode().toggleObjectVisibility, [currentObjects, ev.target], \n                                                        currentMode().undoObjectVisibility);\n      cmd.doIt();\n      undoQueueCombo([toggle, cmd]);\n    });\n   // lock/unlock Object\n   _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"bindAction\"](null, 0, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleObjectLock.name, (ev) => {\n      const toggle = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"ToggleCheckbox\"](ev.target);\n      const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"GenericEditCommand\"](currentMode(), currentMode().toggleObjectLock, [currentObjects, ev.target], \n                                                        currentMode().undoToggleObjectLock);\n      cmd.doIt();\n      undoQueueCombo([toggle, cmd]);\n    });\n   // toggle wire only mode.\n   _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"bindAction\"](null, 0, _wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].toggleWireMode.name, (ev)=>{\n      const toggle = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"ToggleCheckbox\"](ev.target);\n      const cmd = new _wings3d_mads__WEBPACK_IMPORTED_MODULE_18__[\"GenericEditCommand\"](currentMode(), currentMode().toggleObjectWireMode, [currentObjects, ev.target.checked], \n                                                        currentMode().undoToggleObjectWireMode);\n      cmd.doIt();\n      undoQueueCombo([toggle, cmd]);\n    });\n   // objectDelete, gui\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].objectDelete.name, (_ev)=>{\n      const command = new _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_10__[\"DeleteBodyCommand\"](currentObjects);\n      undoQueue( command );\n      command.doIt(); // delete current selected.\n    });\n   // objectDuplicate, gui\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].objectDuplicate.name, (_ev)=>{\n      const command = new _wings3d_bodymads__WEBPACK_IMPORTED_MODULE_10__[\"DuplicateBodyCommand\"](currentObjects);\n      undoQueue( command );\n      command.doIt(); // delete current selected.\n    });\n   // createGroup. replacement for folder.\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].createGroup.name, (_ev)=>{\n      // createGroup\n      const group = new _wings3d_model__WEBPACK_IMPORTED_MODULE_12__[\"PreviewGroup\"];\n      group.name = \"new_folder\";\n      let parent = currentParent;\n      if (!parent) {\n         parent = world;\n      }\n      parent.insert( group ); // later: change to addToWorld()\n      geometryGraph.addGroup(parent.guiStatus.ul, group);\n     });\n   // CreateGroup-World\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].createGroupWorld.name, (_ev)=>{\n      // createGroup\n      const group = new _wings3d_model__WEBPACK_IMPORTED_MODULE_12__[\"PreviewGroup\"];\n      group.name = \"new_folder\";\n      let parent = world;\n      parent.insert( group ); // later: change to addToWorld()\n      geometryGraph.addGroup(parent.guiStatus.ul, group);\n     });\n\n   // Image List.\n   imageList = _wings3d_uitree__WEBPACK_IMPORTED_MODULE_17__[\"getListView\"]('#imageListLabel','#imageList');\n   _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"action\"].importImageFileGUI.name, function(ev) {\n      _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"openFile\"](function(file) { // open file Dialog, and retrive data\n            imageList.loadImage(file);\n         });      \n   });\n\n\n   // bind .dropdown, click event.\n   let buttons = document.querySelectorAll(\"li.dropdown > a\");\n   for (let button of buttons) {\n      if (button.id) {\n         let ul = button.nextElementSibling;  // popupMenu\n         if (ul && ul.classList.contains(\"popup\") && ul.classList.contains(\"menu\")) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](button.id, function(ev) {\n               _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"queuePopupMenu\"](ul);  // show popupMenu\n             });\n         }\n      }\n   }\n   // bind li.dropside > a.\n   buttons = document.querySelectorAll(\"li.dropside > a\");\n   for (let button of buttons) {\n      if (button.id) {\n         let ul = button.nextElementSibling;  // popupMenu\n         if (ul && ul.classList.contains(\"popup\") && ul.classList.contains(\"menu\")) {\n            _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"bindMenuItem\"](button.id, function(ev) {\n               _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"toggleSubmenu\"](ul);  // slide in popup menu, replace the original one\n               ev.stopPropagation();\n             });\n         }\n      }\n   }\n\n\n   //Renderer.init(gl, drawWorld);  // init by itself\n   draftBench = new _wings3d_draftbench__WEBPACK_IMPORTED_MODULE_13__[\"DraftBench\"](theme.draftBench, theme.draftBenchPref);\n\n   // capture keyevent.\n   document.addEventListener('keydown', function(event) {\n      //event.preventDefault();\n      //event.stopPropagation();\n      //      Don't fire in text-accepting inputs that we didn't directly bind to\n      _wings3d_hotkey__WEBPACK_IMPORTED_MODULE_15__[\"runHotkeyAction\"](currentMode(), event);\n    });\n\n   // capture click mouse event.\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"mouseenter\", canvasHandleMouseEnter, false);\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"mousedown\", canvasHandleMouseDown, false); \n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"mouseup\", canvasHandleMouseUp, false);\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"mouseleave\", canvasHandleMouseLeave, false);\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"mousemove\", canvasHandleMouseMove, false);\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"wheel\", canvasHandleWheel, false);\n   // bind context-menu\n   let createObjectContextMenu = {menu: document.querySelector('#create-context-menu')};\n   _wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"].canvas.addEventListener(\"contextmenu\", function(e) {\n      if(!canvasHandleContextMenu(e)) {\n         e.preventDefault();\n         let contextMenu = currentMode().getContextMenu();\n         if (!contextMenu || !contextMenu.menu) {\n            contextMenu = createObjectContextMenu;\n         }\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"positionDom\"](contextMenu.menu, _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"getPosition\"](e));\n         _wings3d_ui__WEBPACK_IMPORTED_MODULE_0__[\"showContextMenu\"](contextMenu.menu);\n      }\n   }, false);\n   //console.log(\"Workspace init successful\");\n   let wavefront = new _plugins_wavefront_obj__WEBPACK_IMPORTED_MODULE_4__[\"WavefrontObjImportExporter\"]();\n\n   // handle redrawingLoop\n   function updateFrame(timestamp) {\n      render(_wings3d_gl__WEBPACK_IMPORTED_MODULE_3__[\"gl\"]);\n      requestAnimationFrame(updateFrame);\n   };\n   requestAnimationFrame(updateFrame);\n};\n\n\n \n\n// register for initialization\n_wings3d__WEBPACK_IMPORTED_MODULE_5__[\"onReady\"](init);\n\n//# sourceURL=webpack:///./js/wings3d_view.js?");

/***/ }),

/***/ "./js/wings3d_wingededge.js":
/*!**********************************!*\
  !*** ./js/wings3d_wingededge.js ***!
  \**********************************/
/*! exports provided: WingedEdge, HalfEdge, Vertex, Polygon, MeshAllocator, WingedTopology */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WingedEdge\", function() { return WingedEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HalfEdge\", function() { return HalfEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return Vertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polygon\", function() { return Polygon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshAllocator\", function() { return MeshAllocator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WingedTopology\", function() { return WingedTopology; });\n/* harmony import */ var _wings3d_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wings3d_model */ \"./js/wings3d_model.js\");\n/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vm */ \"./node_modules/vm-browserify/index.js\");\n/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vm__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n/* require glmatrix\n* http://kaba.hilvi.org/homepage/blog/halfedge/halfedge.htm. very nicely written half-edge explanation and pseudo code.\n* https://fgiesen.wordpress.com/2012/02/21/half-edge-based-mesh-representations-theory/\n* https://fgiesen.wordpress.com/2012/03/24/half-edge-based-mesh-representations-practice/\n* https://fgiesen.wordpress.com/2012/04/03/half-edges-redux/ coder's perspective from requirement to implementation.\n*\n* http://mrl.nyu.edu/~dzorin/ig04/lecture24/meshes.pdf\n* winged edge can have consistent orientation of edge. contray to what commonly believed.\n* we composed WingedEdge using 2 half edge. slightly easier traversal, don't needs to test for which side we are on.\n%% Edge in Wing3d a winged-edge object.\n%%\n%%                \\       /           \n%%                 \\     /            \n%%            ltpr  \\   / rtsu        \n%%                   \\ /              \n%%                   ve  b            \n%%                    |               \n%%                    |               \n%%       lf           |          rf   \n%%                    |               \n%%                    |               \n%%                 a  vs              \n%%                   / \\              \n%%            ltsu  /   \\ rtpr        \n%%                 /     \\            \n%%                /       \\           \n%%                             \n* our face is oriented counter clockwise.  \n*\n*/\n\"use strict\";\n\nvar WingedEdge = function(orgVert, toVert) {\n   this.index = -1;\n   this.left = new HalfEdge(orgVert, this);\n   this.right = new HalfEdge(toVert, this);\n   this.left.pair = this.right;\n   // link together for a complete loop\n   this.left.next = this.right;\n   // this.left.prev = this.right;\n   this.right.pair = this.left;\n   this.right.next = this.left;\n   // this.right.prev = this.left;\n   this.state = 0;\n};\n\nWingedEdge.prototype[Symbol.iterator] = function* () {\n   yield this.left;\n   yield this.right;\n};\n\n/**\n * buildup drawingLine using triangle\n * @param {Uint32Array} data - array\n * @param {number} idx - start index\n * @param {number} vertexLength - center is after vertexLength.\n * @return {number} - current index position.\n */\nWingedEdge.prototype.buildIndex = function(data, idx, vertexLength) {\n   if (this.left.face && this.left.face.isVisible()) {\n      data[idx++] = this.left.origin.index;\n      data[idx++] = this.right.origin.index;\n      data[idx++] = this.left.face.index + vertexLength;\n   }\n   if (this.right.face && this.right.face.isVisible()) {\n      data[idx++] = this.right.origin.index;\n      data[idx++] = this.left.origin.index;\n      data[idx++] = this.right.face.index + vertexLength;\n   }\n   return idx;\n}\n\nWingedEdge.prototype.isLive = function() {\n   return (this.left.origin !== null) && (this.right.origin !== null);\n};\n\nWingedEdge.prototype.adjacent = function* () {\n   let next = this.left.next.wingedEdge;\n   yield next;\n   let prev = this.left.prev().wingedEdge;\n   if (prev !== next) {\n      yield prev;\n   }\n   next = this.right.next.wingedEdge;\n   yield next;\n   prev = this.right.prev().wingedEdge;\n   if (prev !== next) {\n      yield prev;\n   }\n};\n\nWingedEdge.prototype.oneRing = function* () {\n   for (let start of this) {\n      let current = start.next;\n      start = start.pair;\n      do {\n         yield current.wingedEdge;\n         current = current.pair.next;\n      } while (current !== start);\n   }\n};\n\nWingedEdge.prototype.eachVertex = function* () {\n   yield this.left.origin;\n   yield this.right.origin;\n};\n\n// return left wing then right wing. \\   right0-> /\n//                                   |            |\n//                          left0->  /            \\ \nWingedEdge.prototype.wing = function* () {\n   yield this.left.prev();\n   yield this.left;\n   yield this.left.next;\n   yield this.right.prev();\n   yield this.right;\n   yield this.right.next;\n};\n\nWingedEdge.prototype.getNormal = function(normal) {\n   if (this.left.face) {\n      vec3.add(normal, normal, this.left.face.normal);\n   }\n   if (this.right.face) {\n      vec3.add(normal, normal, this.right.face.normal);\n   }\n   vec3.normalize(normal, normal);\n};\n\nvar HalfEdge = function(vert, edge) {  // should only be created by WingedEdge\n   this.next = null;\n//   this.prev = null;       // not required, but very nice to have shortcut\n   this.origin = vert;     // origin vertex, \n//   if (vert.outEdge === null) {\n//     vert.outEdge = this;\n//   }\n   this.face = null;       // face pointer, not required, but useful shortcut\n   this.pair = null;\n   this.wingedEdge = edge; // parent winged edge\n};\n\n// boundary edge if no assigned face.\nHalfEdge.prototype.isBoundary = function() {\n   return this.face === null;\n};\nHalfEdge.prototype.isNotBoundary = function() {\n   return this.face !== null;\n};\n\n/*Object.defineProperty(HalfEdge.prototype, 'pair', {\n   get: function() {\n      if (this.wingedEdge.left === this) {\n         return this.wingedEdge.right;\n      } else {\n         return this.wingedEdge.left;\n      }\n    },\n});*/\n\n\nHalfEdge.prototype.destination = function() {\n   return this.pair.origin;\n}\n\n// using polygon to find prev\nHalfEdge.prototype.prevAux = function() {\n   if (this.face !== null) {\n      let current = this;\n      while (current.next !== this) {\n         current = current.next;\n      }\n      return current;\n   }\n   return null;\n};\n\n// using vertex to find prev\nHalfEdge.prototype.prev = function() {\n   if (this.pair.next === this)  {  // check for dangling edge.\n      return this.pair; // we need this behavior.\n   }\n   var that = this;\n   var ret = this.origin.findInEdge(function(inEdge, vertex) {\n      if (inEdge.next === that) {   // found the prev\n         return true;\n      }\n      return false;\n   });\n   if (ret === null) {\n      // impossible condition, link list is broken\n      console.log(\"HalfEdge.prev: link list is broken, cannot find prev\");\n   }\n   return ret;\n};\n\nHalfEdge.prototype.eachEdge = function(callbackfn) {\n   var start = this;\n   var edge = start;\n   if (edge) {\n      do {  // counter clockwise ordering\n         callbackfn(edge);\n         edge = edge.pair.next;\n      } while (edge && (edge !== start));\n   }\n};\n\n\n//\nvar Vertex = function(pt) {\n   this.vertex = pt;       // vec3. Float32Array. convenient function.\n   this.outEdge = null;\n //  this.index = -1;\n};\n\nObject.defineProperty(Vertex.prototype, 'index', {\n   get: function() {\n      return (this.vertex.byteOffset / (this.vertex.BYTES_PER_ELEMENT*3));\n   },\n});\n\nObject.defineProperty(Vertex.prototype, 'valence', {\n   get: function() {\n      let valence = 0;\n      let start = this.outEdge;\n      let edge = start;\n      if (edge) {\n         do {  // face edge is ccw. walking around vertex is cw.\n            ++valence;\n            edge = edge.pair.next;      // pair's next is outEdge too.\n         } while (edge && (edge !== start));\n      }\n      return valence;\n   },\n});\n\n//\n// compute normal(later) and adjust outEdge to lowest index edge.\n//\nVertex.prototype.reorient = function() {\n   let outEdge = this.outEdge;\n   let current = this.outEdge;\n   do {\n      if (current.index < outEdge.index) {\n         outEdge = current;\n      }\n      current = current.pair.next;\n   } while (current !== this.outEdge);\n   this.outEdge = outEdge;    // get the lowest index outEdge;\n};\n\nVertex.prototype.isLive = function() {\n   return (this.outEdge !== null);\n};\n\nVertex.prototype.oneRing = function* (start) {\n   if (!start) {\n      start = this.outEdge; // we want inEdge.\n   }\n   let current = start;\n   do {\n      const inEdge = current.pair;\n      yield inEdge.origin;\n      current = inEdge.next;\n   } while(current !== start);\n};\n\nVertex.prototype.edgeRing = function* (start) {\n   if (!start) {\n      start = this.outEdge;\n   }\n   let current = start;\n   do {\n      yield current;\n      current = current.pair.next;\n   } while(current !== start);\n};\n\n// utility functions for traversing all incident edge,\nVertex.prototype.eachInEdge = function(callbackfn) {\n   // i am in\n   var start = this.outEdge;\n   var edge = start;\n   if (edge) {\n      do { // ccw ordering\n         const inEdge = edge.pair;\n         edge = edge.pair.next;   // my pair's next is outEdge. \n         callbackfn(inEdge, this);\n      } while (edge && (edge !== start));\n   }\n};\n\nVertex.prototype.findInEdge = function(callbackfn) {\n   // this.halfEdge is inEdge\n   var start = this.outEdge;\n   var edge = start;\n   if (edge) {\n      do { // ccw ordering\n         if (callbackfn(edge.pair, this)) {\n            return edge.pair;\n         }\n         edge = edge.pair.next;   // my pair's tail is in too. \n      } while (edge && (edge !== start));\n   }\n   return null;\n};\n\n// utility functions for traversing all direct out edge.\nVertex.prototype.eachOutEdge = function(callbackfn) {\n   // i am in, so my pair is out.\n   var start = this.outEdge;\n   var edge = start;\n   if (edge) {\n      do {  // counter clockwise ordering\n         callbackfn(edge, this);\n         edge = edge.pair.next;      // pair's next is outEdge too.\n      } while (edge && (edge !== start));\n   }\n};\n\n// find first matching OutEdge\nVertex.prototype.findOutEdge = function(callbackfn) {\n   // i am in, so my pair is out.\n   var start = this.outEdge;\n   var edge = start;\n   if (edge) {\n      do {  // counter clockwise ordering\n         if (callbackfn(edge, this)) {\n            return edge;\n         }\n         edge = edge.pair.next;\n      } while (edge && (edge !== start));\n   }\n   return null;\n};\n\n// freeEdge meant no polygon face attach yet.\n// find any freeInEdge.\nVertex.prototype.findFreeInEdge = function() {\n   return this.findInEdge( function(halfEdge, vert) {\n      if (halfEdge.face === null) {\n         return true;\n      }\n      return false;\n   });\n};\n\nVertex.prototype.linkEdge = function(outHalf, inHalf) { // left, right of winged edge.\n   if (this.outEdge === null) { // isolated vertex.\n      this.outEdge = outHalf;\n   } else {\n      var inEdge = this.findFreeInEdge();\n      if (inEdge === null) {\n         console.log(\"Error: Vertex.linkEdge: complex vertex \" + this.index);\n         return false;\n      }\n      // else insert into circular list.\n      var outEdge = inEdge.next;\n      inEdge.next = outHalf;\n      //fromHalf.prev = inEdge;\n      inHalf.next = outEdge;\n      //outEdge.prev = toHalf;\n   }\n   // link edge successful.\n   return true;\n};\n\nVertex.prototype.unlinkEdge = function(outHalf, inHalf)  {// left, right of winged edge\n   const prev = outHalf.prev();\n//   if (prev === null) {\n//      console.log(\"bad prev\");\n//      return;\n//   }\n   if (this.outEdge === outHalf) {\n      if (prev === inHalf) {\n         this.outEdge = null;\n         return;\n      }\n      this.outEdge = prev.pair;\n   }\n   // remove from circular list.\n   prev.next = inHalf.next;\n};\n\nVertex.prototype.isIsolated = function() {\n   return (this.outEdge === null);\n};\n\nVertex.prototype.numberOfEdge = function() {\n   const limits = 1001;\n   let count = 0;\n   const start = this.outEdge;\n   let current = start;\n   do {\n      count++;\n      current = current.pair.next;\n   } while ((current !== start) || (count > limits));\n   return count;\n};\n\nVertex.prototype.getNormal = function(normal) {\n   const start = this.outEdge;\n   let current = start;\n   const a = vec3.create(), b = vec3.create(), temp = vec3.create();\n   vec3.sub(a, current.destination().vertex, current.origin.vertex);\n   do {\n      current = current.pair.next;\n      vec3.sub(b, current.destination().vertex, current.origin.vertex);\n      vec3.cross(temp, b, a);\n      vec3.add(normal, normal, temp);\n      vec3.copy(a, b);\n   } while (current !== start);\n   vec3.normalize(normal, normal);\n};\n\n\n\n\nvar Polygon = function(startEdge, size) {\n   this.halfEdge = startEdge;\n   this.numberOfVertex = size;       // how many vertex in the polygon\n   this.update(); //this.computeNormal();\n   this.index = -1;\n   this.visible = true;\n};\n\n// not on free list. not deleted and visible\nPolygon.prototype.isLive = function() {\n   return (this.halfEdge !== null);\n};\n\nPolygon.prototype.isVisible = function() {\n   return this.visible && (this.halfEdge !== null);\n}\n\nPolygon.prototype.buildIndex = function(data, index, center) {\n   for (let edge of this.hEdges()) {\n      data[index++] = edge.origin.index;\n      data[index++] = edge.destination().index;\n      data[index++] = center;\n   }\n   return index;\n}\n\nPolygon.prototype.eachVertex = function(callbackFn) {\n   // get every vertex of the face.\n   var begin = this.halfEdge;\n   var current = begin;\n   do {\n      callbackFn(current.origin);\n      current = current.next;\n   } while (current !== begin);\n};\n\nPolygon.prototype.eachEdge = function(callbackFn) {\n   var begin = this.halfEdge;\n   var current = begin;\n   do {\n      let next = current.next;\n      callbackFn(current);\n      current = next;\n   } while (current !== begin);\n};\n\nPolygon.prototype.hEdges = function* (modify = false) {\n   if (modify) {\n      const unmodify = [];\n      let current = this.halfEdge; \n      do {\n         unmodify.push(current);\n         current = current.next;\n      } while (current !== this.halfEdge);\n      for (let current of unmodify) {\n         yield current;\n      }\n   } else {\n      const begin = this.halfEdge;\n      let current = begin;\n      do {\n         let next = current.next;\n         yield current;\n         current = next;\n      } while (current !== begin);\n   }\n}\n\n// adjacent face, along the edge\nPolygon.prototype.adjacent = function* () {\n   const check = new Set;\n   const start = this.halfEdge;\n   let current = start;\n   do {\n      let face = current.pair.face;\n      if (face !== null && !check.has(face)) {\n         check.add(face);\n         yield face;\n      }\n      current = current.next;\n   } while (current !== start);\n};\n\n// one ring faces. all the vertex's face\nPolygon.prototype.oneRing = function* () {\n   const check = new Set; check.add(this);\n   const start = this.halfEdge;\n   let current = start;\n   do {\n      const vertex = current.origin;\n      for (let outEdge of vertex.edgeRing()) {\n         const face = outEdge.face;\n         if ((face !== null) && !check.has(face)) {\n            check.add(face);\n            yield face;\n         }\n      }\n      current = current.next;\n   } while (current !== start);\n\n};\n\n// ccw ordering\nPolygon.prototype.computeNormal = function() {\n   const U = vec3.create();\n   const V = vec3.create();\n   const v1 = this.halfEdge.origin.vertex;\n   const v0 = this.halfEdge.next.origin.vertex;\n   const v2 = this.halfEdge.next.destination().vertex;\n   vec3.sub(U, v1, v0);\n   vec3.sub(V, v2, v0);\n   if (!this.normal) {\n      this.normal = vec3.create();\n   }\n   vec3.cross(this.normal, V, U);\n   vec3.normalize(this.normal, this.normal);\n};\n\n\n// recompute numberOfVertex and normal. and reorient.\nPolygon.prototype.update = function() {\n   const begin = this.halfEdge;\n   let halfEdge = begin;\n   let current = begin;\n   this.numberOfVertex = 0;\n   do {\n      current.face = this;\n      //current.origin.reorient();\n      ++this.numberOfVertex;\n      if (current.index < halfEdge.index) {\n         halfEdge = current;\n      }\n      if (this.numberOfVertex > 1001) {   // break;   \n         console.log(\"something is wrong with polygon link list\");\n         return;\n      }\n      current = current.next;\n   } while (current !== begin);\n   this.halfEdge = halfEdge;              // the lowest index.\n   // compute normal.\n   if (this.numberOfVertex > 2) {\n      this.computeNormal();\n   }\n};\n\n//\n// getCentroid - not really centroid, but center of points.\n// todo - find a good centroid algorithm. like tessellate to triangles. and use triangle's centroid to find real centroid.\n//\nPolygon.prototype.getCentroid = function(centroid) {\n   const begin = this.halfEdge;\n   let current = begin;\n   let numberOfVertex = 0;\n   do {\n      vec3.add(centroid, centroid, current.origin.vertex);\n      ++numberOfVertex;\n      current = current.next;\n   } while (current !== begin);\n   // compute centroid.\n   vec3.scale(centroid, centroid, 1.0/numberOfVertex);\n};\n\n\n/*let PolygonHole = function() {\n   const ret = new Polygon();\n   ret.visible = false;\n\n};*/\n\n\n\n\n//\n// \n//\nlet MeshAllocator = function(allocatedSize = 1024) {\n   var buf = new ArrayBuffer(allocatedSize*3 * Float32Array.BYTES_PER_ELEMENT);  // vertices in typedArray\n   this.buf = { buffer: buf, data: new Float32Array(buf), len: 0, }; // vertex's pt buffer. to be used for Vertex.\n   this.vertices = [];     // class Vertex\n   this.edges = [];        // class WingedEdge\n   this.faces = [];        // class Polygon\n   this.free = {vertices: [], edges: [], faces: []};\n   this.affected = {vertices: new Set, edges: new Set, faces: new Set};// affected is when reuse, deleted, or change vital stats.\n};\n// allocation,\nMeshAllocator.prototype.allocVertex = function(pt, delVertex) {\n   if (this.free.vertices.length > 0) {\n      let vertex;\n      if (typeof delVertex === 'undefined') {\n         vertex = this.vertices[this.free.vertices.pop()];\n      } else {\n         const index = delVertex.index;   // remove delOutEdge from freeEdges list\n         this.free.vertices = this.free.vertices.filter(function(element) {\n            return element !== index;\n         });\n         vertex = delVertex;\n      }\n      vertex.vertex.set(pt);\n      this.affected.vertices.add( vertex );\n      return vertex;\n   } else {\n      if ((this.buf.len+3) >= (this.buf.data.length)) {\n         // reached maximum buff size, resize, double the size\n         var buffer = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT*this.buf.len*2);\n         var data = new Float32Array(buffer);\n         // copy data to new buffer.\n         data.set(this.buf.data);\n         // update Vertex.position;\n         this.vertices.forEach(function(element, index, arry) {\n            element.vertex = new Float32Array(buffer, Float32Array.BYTES_PER_ELEMENT*index*3, 3);\n         });\n         // replace\n         this.buf.data = data;\n         this.buf.buffer = buffer;\n      }\n      // vec3 is 3 float32. mapped into the big buffer. float32=4 byte.\n      let vertex = new Float32Array(this.buf.buffer, Float32Array.BYTES_PER_ELEMENT*this.buf.len, 3);\n      this.buf.len += 3;\n      vertex[0] = pt[0];\n      vertex[1] = pt[1];\n      vertex[2] = pt[2];\n      var _vert = new Vertex(vertex);\n      //_vert.index = this.vertices.length;\n      this.vertices.push( _vert );\n      //this.affected.vertices.add( _vert );\n      return _vert;\n   }\n};\n\nMeshAllocator.prototype.allocEdge = function(begVert, endVert, delOutEdge) {\n   let edge;\n   let outEdge;\n   if (this.free.edges.length > 0) { // prefered recycle edge.\n      if (typeof delOutEdge !== \"undefined\") {\n         const index = delOutEdge.wingedEdge.index;   // remove delOutEdge from freeEdges list\n         this.free.edges = this.free.edges.filter(function(element) {\n            return element !== index;\n         });\n         edge = delOutEdge.wingedEdge;\n         outEdge = delOutEdge;\n      } else {\n         edge = this.edges[this.free.edges.pop()];\n         outEdge = edge.left;\n      }\n      outEdge.origin = begVert;\n      outEdge.pair.origin = endVert;\n      this.affected.edges.add( edge );\n   } else {\n      // initialized data.\n      edge = new WingedEdge(begVert, endVert);\n      edge.index = this.edges.length;\n      this.edges.push( edge );\n      outEdge = edge.left;\n      //this.affected.edges.add( edge );\n   }\n\n   return outEdge;\n};\n\n// todo: ?binary search for delPolygon, then use splice. a win? for large freelist yes, but, I don't think it a common situation.\nMeshAllocator.prototype.allocPolygon = function(halfEdge, numberOfVertex, delPolygon) {\n   let polygon;\n   if (this.free.faces.length > 0) {\n      if (typeof delPolygon !== \"undefined\") {\n         const index = delPolygon.index;   // remove delOutEdge from freeEdges list\n         this.free.faces = this.free.faces.filter(function(element) {\n            return element !== index;\n         });\n         polygon = delPolygon;\n      } else {\n         polygon = this.faces[ this.free.faces.pop() ];\n      }\n      polygon.halfEdge = halfEdge;\n      polygon.numberOfVertex = numberOfVertex;\n      polygon.update();\n      polygon.visible = true;  // make sure it visible.\n      this.affected.faces.add( polygon );\n   } else {\n      polygon = new Polygon(halfEdge, numberOfVertex);\n      polygon.index = this.faces.length;\n      this.faces.push( polygon );\n   }\n   return polygon;\n};\n\n// recycled\n// insert the index number in reverse order. smallest last.\nMeshAllocator.prototype._insertFreeList = function(val, array) {\n   var l = 0, r = array.length - 1;\n   while (l <= r) {\n      //let m = (l + r) >>> 1; /// equivalent to Math.floor((l + h) / 2) but faster\n      let m = l + ((r-l) >>> 1); // avoid overflow. \n      let comparison = val - array[m];\n      if (comparison > 0) {\n         r = m - 1;\n      } else if (comparison < 0) {\n         l = m + 1;\n      } else {\n         break; // should no happened.\n      }\n   }\n   array.splice(l, 0, val);\n};\nMeshAllocator.prototype.freeVertex = function(vertex) {\n   vertex.outEdge = null;\n   //vertex.vertex.fill(0.0);\n   // assert !freeVertices.has(vertex);\n   //this.free.vertices.push( vertex );\n   this._insertFreeList(vertex.index, this.free.vertices);\n   this.affected.vertices.add( vertex );\n};\n\nMeshAllocator.prototype.freeHEdge = function(edge) {\n   const pair = edge.pair;\n   edge.face = null;\n   pair.face = null;\n   edge.origin = null;\n   pair.origin = null;\n   // link together for a complete loop\n   edge.next = pair;\n   pair.next = edge;\n   // assert !this.free.edges.has( edge.wingedEdge );\n   //this.free.edges.push( edge.wingedEdge );\n   this._insertFreeList(edge.wingedEdge.index, this.free.edges);\n   this.affected.edges.add( edge.wingedEdge );\n};\n\nMeshAllocator.prototype.freePolygon = function(polygon) {\n   polygon.halfEdge = null;\n   polygon.numberOfVertex = 0;\n   // assert !freeFaces.has( polygon );\n   //this.free.faces.push( polygon );\n   this._insertFreeList(polygon.index, this.free.faces);\n   this.affected.faces.add( polygon );\n};\n\nMeshAllocator.prototype.freeAll = function(polygons, wEdges, vertices) {\n   function compare(a, b) {return b-a;}\n   for (let polygon of polygons) {\n      this.free.faces.push(polygon.index);\n      polygon.halfEdge = null;\n      polygon.numberOfVertex = 0;\n   }\n   this.free.faces.sort(compare);\n   for (let wEdge of wEdges) {\n      this.free.edges.push(wEdge.index);\n      wEdge.left.face = null;\n      wEdge.left.origin = null;\n      wEdge.right.face = null;\n      wEdge.right.face = null;\n      wEdge.left.next = wEdge.right;\n      wEdge.right.next = wEdge.left;\n   }\n   this.free.edges.sort(compare);\n   for (let vertex of vertices) {\n      this.free.vertices.push(vertex.index);\n      vertex.outEdge = null;\n   }\n   this.free.vertices.sort(compare);\n}\n\n\nMeshAllocator.prototype.getVertices = function(index) {\n   return this.vertices[index];\n}\n\n// update for affected (vertex, edge, and polygon)\nMeshAllocator.prototype.clearAffected = function() {\n   this.affected.vertices.clear();\n   this.affected.edges.clear();\n   this.affected.faces.clear();\n};\nMeshAllocator.prototype.addAffectedWEdge = function(wEdge) {\n   this.affected.edges.add(wEdge);\n};\nMeshAllocator.prototype.addAffectedFace = function(polygon) {\n   this.affected.faces.add(polygon);\n};\nMeshAllocator.prototype.addAffectedVertex = function(vertex) {\n   this.affected.vertices.add(vertex);\n};\nMeshAllocator.prototype.addAffectedEdgeAndFace = function(vertex) {\n   this.affected.vertices.add(vertex);\n   const self = this;\n   vertex.eachOutEdge( function(halfEdge) {\n      self.affected.edges.add(halfEdge.wingedEdge);\n      if (halfEdge.face !== null) {\n         self.affected.faces.add(halfEdge.face);\n     }\n   });\n};\n\n\n// \n// changed - so Vertex, WingedEdge, and Polygon is allocated from meshAllocator. So different \n// Models on the same DraftBench can use the same Allocation. Merging becomes easier.\n//\nvar WingedTopology = function(allocator) {\n   this.alloc = allocator;\n   this.vertices = new Set;\n   this.faces = new Set;\n   this.edges = new Set;\n};\n\n// act as destructor\nWingedTopology.prototype.free = function() {\n   this.alloc.freeAll(this.faces, this.edges, this.vertices);\n   this.faces = new Set;\n   this.edges = new Set;\n   this.vertices = new Set;\n};\n\n// merge - should we check alloc is the same?\nWingedTopology.prototype.merge = function(geometryGenerator) {\n   const self = this;\n   this.vertices = new Set(function* () {yield* self.vertices; for (let geometry of geometryGenerator()) {yield* geometry.vertices;}}());\n   this.edges = new Set(function* () {yield* self.edges; for (let geometry of geometryGenerator()) {yield* geometry.edges;}}());\n   this.faces = new Set(function* () {yield* self.faces; for (let geometry of geometryGenerator()) {yield* geometry.faces;}}());\n};\n\n// separate - separate out non-connected geometry.\nWingedTopology.prototype.separateOut = function() {\n   const traversed = new Set;\n   const separate = [];\n   let faces;\n\n   function oneRing(srcPolygon) {\n      for (let hEdge of srcPolygon.hEdges()) {  // don't use oneRing. extra set operation.\n         const polygon = hEdge.pair.face;\n         if ((polygon !== null) && !traversed.has(polygon)) {\n            traversed.add(polygon);\n            faces.add(polygon);\n            oneRing(polygon);\n         }\n      }\n   };\n\n   for (let polygon of this.faces) {\n      if (!traversed.has(polygon)) {\n         traversed.add(polygon);\n         let geometry = new WingedTopology(this.alloc);\n         faces = geometry.faces;              // ready for geometry.\n         faces.add(polygon);\n         oneRing(polygon);\n         // ok, got one separated\n         separate.push( geometry );\n      }\n   }\n\n   if (separate.length > 1) {\n      // we have the face list. now rebuild vertex and edge lists.\n      for (let mesh of separate) {\n         for (let polygon of mesh.faces) {\n            for (let hEdge of polygon.hEdges()) {\n               mesh.vertices.add( hEdge.origin );\n               mesh.edges.add( hEdge.wingedEdge );\n            }\n         }\n      }\n      return separate; \n   } else {\n      return null;\n   }\n};\n\nWingedTopology.prototype.detachFace = function(faceSet) {\n   const vertices = new Set;\n   const edges = new Set;\n   for (let polygon of faceSet) {\n      this.faces.delete(polygon);\n      for (let hEdge of polygon.hEdges()) {\n         vertices.add(hEdge.origin);\n         this.vertices.delete(hEdge.origin);\n         edges.add(hEdge.wingedEdge);\n         this.edges.delete(hEdge.wingedEdge);\n      }\n   }\n\n   return {vertices: vertices, edges: edges};\n};\n\nWingedTopology.prototype.sanityCheck = function() {\n   let sanity = true;\n   // first check vertex for error.\n   for (let [index, vertex] of this.vertices.entries()) {\n      if (vertex.isLive()) {\n         if (vertex.outEdge.origin !== vertex) {\n            console.log(\"vertex \" + index + \" outEdge is wrong\");\n            sanity = false;\n         } else {\n            // manual find prev. \n            var start = vertex.outEdge;\n            var edge = start;\n            let prev = null;\n            let iterationCount = 0;    // make sure, no infinite loop\n            if (edge) {\n               do { // ccw ordering\n                  if (edge.pair.next === start) {\n                     prev = edge.pair;\n                     break;\n                  }\n                  edge = edge.pair.next;   // my pair's tail is in too. \n                  iterationCount++;\n               } while (edge && (edge !== start) && (iterationCount < 101));\n            }\n            if (prev === null) {\n               console.log(\"vertex \" + index + \" is broken\");\n               sanity = false;\n            }\n         }\n      }\n   }\n   // now check polygon\n   return sanity;\n};\n\nWingedTopology.prototype.addAffectedWEdge = function(wEdge) {\n   this.alloc.addAffectedWEdge(wEdge);\n};\n\nWingedTopology.prototype.addAffectedFace = function(polygon) {\n   this.alloc.addAffectedFace(polygon);\n};\n\nWingedTopology.prototype.addAffectedVertex = function(vertex) {\n   this.alloc.addAffectedVertex(vertex);\n};\n\nWingedTopology.prototype.clearAffected = function() {\n   this.alloc.clearAffected();\n};\n\nWingedTopology.prototype.addAffectedEdgeAndFace = function(vertex) {\n   this.alloc.addAffectedEdgeAndFace(vertex);\n};\n\nWingedTopology.prototype._createPolygon = function(halfEdge, numberOfVertex, delPolygon) {\n   const polygon = this.alloc.allocPolygon(halfEdge, numberOfVertex, delPolygon);\n   this.faces.add(polygon);\n   return polygon;\n};\n\n// return vertex index\nWingedTopology.prototype.addVertex = function(pt, delVertex) {\n   const vertex = this.alloc.allocVertex(pt, delVertex);\n   this.vertices.add(vertex);\n   return vertex;\n};\n\nWingedTopology.prototype._createEdge = function(begVert, endVert, delOutEdge) {\n   const outEdge = this.alloc.allocEdge(begVert, endVert, delOutEdge);\n   this.edges.add(outEdge.wingedEdge);\n   return outEdge;\n};\n// recycled\nWingedTopology.prototype._freeVertex = function(vertex) {\n   if (this.vertices.delete(vertex)) {\n      this.alloc.freeVertex(vertex);\n   }\n};\n\nWingedTopology.prototype._freeEdge = function(edge) {\n   if (this.edges.delete(edge.wingedEdge)){\n      this.alloc.freeHEdge(edge);\n   }\n};\n\nWingedTopology.prototype._freePolygon = function(polygon) {\n   if (this.faces.delete(polygon)) {\n      this.alloc.freePolygon(polygon);\n   }\n};\n\n\nWingedTopology.prototype.getExtent = function(min, max) {\n   //min[0] = min[1] = min[2] = Number.MAX_VALUE;\n   //max[0] = max[1] = max[2] = Number.MIN_VALUE;\n   for (let vertex of this.vertices) {\n      const pt = vertex.vertex;\n      for (let i = 0; i < 3; ++i) {\n         if (pt[i] > max[i]) {\n            max[i] = pt[i];\n         } else if (pt[i] < min[i]) {\n            min[i] = pt[i];\n         }\n      }\n   }\n};\n\n\n// return winged edge ptr because internal use only.\nWingedTopology.prototype.addEdge = function(begVert, endVert, delOutEdge) {\n   // what to do with loop edge?\n   // what to do with parallel edge?\n\n   // initialized data.\n   var edge = this._createEdge(begVert, endVert, delOutEdge).wingedEdge;\n\n   // Link outedge, splice if needed\n   if (!begVert.linkEdge(edge.left, edge.right)) {\n      // release the edge\n      this._freeEdge(edge.left);\n      return null;\n   }\n   // Link inedge, splice if needed\n   if (!endVert.linkEdge(edge.right, edge.left)) {\n      begVert.unlinkEdge(edge.left, edge.right);\n      // release the endge\n      this._freeEdge(edge.right);\n      return null; \n   }\n\n   // return outEdge.\n   return edge.left;\n};\n\nWingedTopology.prototype.findFreeInEdge = function(inner_next, inner_prev) {\n   // inner_prev is guaranteed to be boundary, so if link correctly, should be \n\n   // search a free gap, free gap will be between boundary_prev and boundary_next\n   var boundary_prev = inner_next.pair;\n   do {\n      do {\n         boundary_prev = boundary_prev.next.pair;\n      } while (!boundary_prev.isBoundary());\n\n      // ok ?\n      if (boundary_prev !== inner_prev) {\n         return boundary_prev;\n      }\n   } while (boundary_prev !== inner_next.pair);\n   \n   // check for bad connectivity. somewhere, there is no free inedge anywhere.\n   console.log(\"WingedTopology.addFace.findFreeInEdge: patch re-linking failed\");\n   return null;\n};\n\n\n\nWingedTopology.prototype.spliceAdjacent = function(inEdge, outEdge) {\n   if (inEdge.next === outEdge) {   // adjacency is already correct.\n      return true;\n   }\n\n   const b = inEdge.next;\n   const d = outEdge.prev();\n\n   // Find a free incident half edge\n   // after 'out' and before 'in'.\n   const g = this.findFreeInEdge(outEdge, inEdge);\n\n   if (g === null) {\n      console.log(\"WingedTopology.spliceAjacent: no free inedge, bad ajacency\");\n      return false;\n   } else if (g === d) {\n      inEdge.next = outEdge;\n      d.next = b;\n   } else {\n      const h = g.next;\n\n      inEdge.next = outEdge;\n      //out.half_->previous_ = in.half_;\n\n      g.next = b;\n      //b.half_->previous_ = g.half_;\n\n      d.next = h;\n      //h.half_->previous_ = d.half_;\n   }\n   return true;\n};\n\n// failed addPolygon. free and unlink edges.\nWingedTopology.prototype._unwindNewEdges = function(halfEdges) {\n   for (let halfEdge of halfEdges) {\n      let pair = halfEdge.pair;\n      halfEdge.origin.unlinkEdge(halfEdge, pair);\n      pair.origin.unlinkEdge(pair, halfEdge);\n      this._freeEdge(halfEdge);\n   }\n};\n\n// passed in an array of vertex index. automatically create the required edge.\n// return polygon index.\n// add proper handling for non-manifold. (2017/05/28)\n// add checking for complex polygon. (2017/05/29)\nWingedTopology.prototype.addPolygon = function(pts) {\n   var halfCount = pts.length;\n   if (halfCount < 3) { // at least a triangle\n      return -1;\n   }\n\n   var i, nextIndex;\n   // builds WingEdge if not exist\n   var halfLoop = [];\n   var newEdges = [];\n   const complex = new Set;\n   for (i =0; i < halfCount; ++i) {\n      nextIndex = i + 1;\n      if (nextIndex == halfCount) {\n         nextIndex = 0;\n      }\n\n      var v0 = this.alloc.getVertices(pts[i]);\n      var v1 = this.alloc.getVertices(pts[nextIndex]);\n      var edge = this.findHalfEdge(v0, v1);\n      if (edge === null) { // not found, create one\n         edge = this.addEdge(v0, v1);\n         if (edge === null) {\n            this._unwindNewEdges(newEdges);\n            return null;\n         }\n         newEdges.push(edge);\n         complex.add(edge.wingedEdge);\n      } else if (!edge.isBoundary()) { // is it free? only free can form a chain.\n         this._unwindNewEdges(newEdges);\n         // This half-edge would introduce a non-manifold condition.\n         console.log(\"non-manifold condition, no boundary\");\n         return null;\n         // should we rewinded the newly created winged edge? currently nay.\n      } else {\n         // check if the wingedEdge already included.\n         if (complex.has(edge.wingedEdge)) {\n            this._unwindNewEdges(newEdges);\n            // complex polygon that cannot be handle properly with halfEdge structure.\n            console.log(\"complex polygon detected\");\n            return null;\n         }\n         complex.add(edge.wingedEdge);\n      }\n\n      halfLoop.push( edge );\n   }\n\n   // Try to reorder the links to get proper orientation.\n   for (i = 0;i < halfCount;++i) {\n      nextIndex = i + 1;\n      if (nextIndex == halfCount) {\n         nextIndex = 0;\n      }\n\n      if (!this.spliceAdjacent(halfLoop[i], halfLoop[nextIndex])) {\n         this._unwindNewEdges(newEdges);\n         // The polygon would introduce a non-manifold condition.\n         console.log(\"non-manifold condition, cannot splice\");\n         return null;\n      }\n   }\n\n   // Create and link the polygon\n   var newPolygon = this._createPolygon(halfLoop[0], pts.length);\n\n   // Link half-edges to the polygon.\n   for (i = 0;i < halfCount; ++i) {\n      halfLoop[i].face = newPolygon;\n   }\n\n   return newPolygon;\n};\n\n// utility for addPolygon.\nWingedTopology.prototype.findHalfEdge = function(v0, v1) {\n   // v0 = start, v1 = end.\n  //assert(_start_vh.is_valid() && _end_vh.is_valid());\n\n  return v0.findOutEdge( function(edge, _vertex) {\n            if (edge.destination() === v1) {\n               return true;\n            }\n            return false;\n         });\n};\n\n\n\n// to split a face into 2 faces by insertEdge, delOutEdge and delPolygon optional.\nWingedTopology.prototype.insertEdge = function(prevHalf, nextHalf, delOutEdge, delPolygon) {\n   // assert(prevHalf.face === nextHalf.face);\n   // assert(prevHalf.next !== _nextHalf);      // we want to split face, not adding edge\n   const v0 = prevHalf.destination();\n   const v1 = nextHalf.origin;\n   const oldPolygon = prevHalf.face;\n\n   // create edge and link together.\n   const outEdge = this._createEdge(v0, v1, delOutEdge);\n   const inEdge = outEdge.pair;\n   const nextPrev = prevHalf.next;           // save for later use\n   const prevNext = nextHalf.prev();\n   prevHalf.next = outEdge;\n   outEdge.next = nextHalf;\n   prevNext.next = inEdge;\n   inEdge.next = nextPrev;\n  \n   //now set the face handles\n   const newPolygon = this._createPolygon(outEdge, 4, delPolygon);  // readjust size later.\n   outEdge.face = newPolygon;\n   let size = 0;\n   newPolygon.eachEdge( function(halfEdge) {\n      ++size;\n      halfEdge.face = newPolygon;\n   });\n   newPolygon.numberOfVertex = size;\n\n   // inEdge is oldPolygon\n   inEdge.face = oldPolygon;\n   if (oldPolygon) {\n      if (oldPolygon.halfEdge.face === newPolygon) {\n         //  pointed to one of the halfedges now assigned to newPolygon\n         oldPolygon.halfEdge = inEdge;\n      }\n      size = 0;\n      oldPolygon.eachEdge( function(halfEdge) {\n         ++size;\n      });\n      oldPolygon.numberOfVertex = size;\n      this.addAffectedFace( oldPolygon );\n   }\n\n   // adjustOutEdge for v0, v1. point to boundary so, ccw work better?\n   return outEdge;\n}\n\n//\n// insert a new outEdge at (origin), oldOut push out to newOrigin.\n//\nWingedTopology.prototype.splitEdge = function(outEdge, pt, delOut) {\n   const inEdge = outEdge.pair;\n   const outPrev = outEdge.prev();\n   const inNext = inEdge.next;\n   const vOrigin = outEdge.origin;\n   const vOut = vOrigin.outEdge;\n\n   //add the new edge\n   const vertex = this.addVertex(pt);\n   const newOut = this._createEdge(vOrigin, vertex, delOut);\n   const newIn = newOut.pair;\n   // fixe the halfedge connectivity\n   newOut.next = outEdge;\n   inEdge.next = newIn;\n  \n   outPrev.next = newOut;\n   newIn.next = inNext;\n  \n   newOut.face = outEdge.face;\n   newOut.face.numberOfVertex++;\n   newIn.face = inEdge.face;\n   newIn.face.numberOfVertex++;\n\n   // fix vertex\n   outEdge.origin = vertex;\n   vertex.outEdge = newIn;\n  \n   if (vOut === outEdge) {\n      vOrigin.outEdge = newOut;\n   }\n   this.addAffectedWEdge( outEdge.wingedEdge );     // edge changed.\n   // return the newOut\n   return newOut;\n};\n\n\n\n// used by bevel\nWingedTopology.prototype.doubleEdge = function(inEdge) {\n   const prev = inEdge.prev();\n\n   // reassign pointer\n   const newOut = this._createEdge(inEdge.destination(), inEdge.origin);\n   const newIn = newOut.pair;\n   newOut.next = inEdge;\n   newIn.next = inEdge.next;\n   inEdge.next = newOut;\n   prev.next = newIn;\n\n   // reassign polygon\n   newIn.face = inEdge.face;\n   if (inEdge.face.halfEdge === inEdge) {\n      newIn.face.halfEdge = newIn;\n   }\n   this.addAffectedFace(newIn.face);\n   const newPolygon = this._createPolygon(newOut, 2);\n//   newOut.face = newPolygon;\n//   inEdge.face = newPolygon;\n\n   return newOut;\n};\n// create new edge, but no new vertex.\nWingedTopology.prototype.simpleSplit = function(inEdge) {\n   // check(inEdge.destination() !== inEdge.next.origin)\n   const outEdge = this._createEdge(inEdge.destination(), inEdge.next.origin);\n   // now break it up.\n   outEdge.next = inEdge.next;\n   inEdge.next = outEdge;\n   // outEdge.pair.next have to wait \n   outEdge.face = inEdge.face;\n   outEdge.face.numberOfVertex++;\n\n   return outEdge; \n};\n// prepare adding vertex\nWingedTopology.prototype.prepVertex = function(inStart, outStop, adjacentRed, vertexLimit, slideEdge, origin) {\n   if (!origin) {\n      origin = outStop.origin;\n   }\n   const pts = vertexLimit.get(origin);\n   let inEdge = inStart;\n   let notDone = true;\n   let outEdge;\n   do {\n      outEdge = inEdge.next;\n      outEdge.origin = origin;\n      inEdge = outEdge.pair;\n      if (notDone) {\n         pts.push(inEdge);\n         if (!adjacentRed.has(outEdge.wingedEdge)) { // white edge, definite walk along this edge\n            notDone = false;\n            pts.length = 0;      // make sure we only have one.\n            pts.push(inEdge);\n         }\n      }\n   } while (outEdge !== outStop);\n   if (slideEdge) {\n      for (let hEdge of pts) {\n         slideEdge.add(hEdge);   // \n      }\n   }\n};\nWingedTopology.prototype.prepVertexAdd = function(inStart, outStop, adjacentRed, vertexLimit, slideEdge) {\n   const origin = this.addVertex(inStart.destination().vertex);\n   vertexLimit.set(origin, []);\n   this.prepVertex(inStart, outStop, adjacentRed, vertexLimit, slideEdge, origin);\n   return origin;\n}\nWingedTopology.prototype.isSplitEdgeSelected = function(origin, dest, adjacentRed) {\n   for (let vertex of [origin, dest]) {\n      let count = 0;\n      let redCount = 0;\n      for (let hEdge of vertex.edgeRing()) {\n         count++;\n         if (adjacentRed.has(hEdge.wingedEdge)) {\n            redCount++;\n         }\n      }\n      if (count !== 3) { // (count > 3) { // equal 3 or 4\n         return false;\n      } else if (redCount !== 2) {\n         return false;\n      }\n   }\n   return true;\n}\n// nice explanation.\n// https://stackoverflow.com/questions/35378378/multi-edge-bevel-on-half-edge-structure\n//\n// We can split the operation into two conceptual steps. First, double the red edges. Second, explode the vertices incident to at least one red edge.\n//\n// The first step can be accomplished one edge at a time. Given a red edge e, create another edge e'. For one half edge of e, \n// insert one half edge of e' as the next half-edge with the same head in clockwise order. For the other half edge of e, \n// insert the other half edge of e' as the next half edge with the same head in counterclockwise order.\n//\n// The second step can be accomplished one vertex at a time. Given a vertex v incident to at least one red edge, \n// group the half edges with head v as follows. Break that circular list (1) between every adjacent pair of red half edges that arose from the same original edge \n// (2) between every adjacent pair of white edges (adjacent means that the two half edges are next/previous in clockwise/counterclockwise order). \n// For each break, create a new edge. Splice everything together.\n//\nWingedTopology.prototype.bevelEdge = function(wingedEdges) {   // wingedEdges(selected) is a set\n   const ret = {vertices: [], halfEdges: [], collapsibleWings: new Set, selectedFaces: new Set};\n   const vertices = new Set;\n   const vertexLimit = new Map;\n   const adjacentRed = new Map;\n   const slideEdge = new Set;      // halfEdge, where we will slide the bevel edge\n   const twoEdgeVertexHack = new Set;\n   // double selected edge, and add face. \n   for (let wingedEdge of wingedEdges) {\n      const outEdge = this.doubleEdge(wingedEdge.left);   // add edge and faces\n      ret.selectedFaces.add(outEdge.face);\n      vertices.add( outEdge.origin );\n      vertices.add( outEdge.destination() );\n      //ret.halfEdges.push(wingedEdge.left);    // start of new face. also can be use for undo.\n      // we create a new tag.\n      adjacentRed.set(wingedEdge, outEdge.wingedEdge);\n      adjacentRed.set(outEdge.wingedEdge, wingedEdge);\n      ret.collapsibleWings.add(outEdge.wingedEdge);\n   }\n\n   // for every vertex, add edge and chamfer vertex for 1)adjacent red edges, 2) adjacent white edges.\n   for (let vertex of vertices) {\n      ret.vertices.push(vertex);       // affected vertex original\n      vertexLimit.set(vertex, []);\n      let edgeInsertion = [];\n      const start = vertex.outEdge;    // walk the ring\n      let current = start;\n      do {\n         let next = current.pair.next;  // save \n         // check if current && prev are the same color edge, (white,white, red,red)\n         if (adjacentRed.has(current.wingedEdge)) {\n            if (adjacentRed.get(current.wingedEdge) === next.wingedEdge) {  // original red+expansion pair.\n               edgeInsertion.push( current.pair ); // insertion point\n            }\n         } else if (!adjacentRed.has(next.wingedEdge)) {   // (white, white) pair\n            edgeInsertion.push( current.pair );\n         }\n         current = next;\n      } while(current !== start);   // save the last pair (end, start) for special processing.\n      // real expandsion of vertex, and edge\n      let insertion;\n      let prevOut;\n      let firstOut;\n      for (let nextStop of edgeInsertion) {\n         if (insertion) {\n            const origin = this.prepVertexAdd(insertion, nextStop.pair, adjacentRed, vertexLimit, slideEdge);\n            let out = this.simpleSplit(insertion);\n            origin.outEdge = out.pair;\n            ret.vertices.push( origin );\n            ret.halfEdges.push( out.pair );\n            if (prevOut) {\n               out.pair.next = prevOut.pair;\n            } else {\n               firstOut = out;\n            }\n            prevOut = out;\n         }\n         insertion = nextStop;\n      }\n      // last edge\n      if (edgeInsertion.length === 1) {   // must be splitEdge, special case. needs to create an extra triangle face.\n         // create another edge\n         const splitOut = insertion.next.pair.next;\n         const outEdge = this.doubleEdge(splitOut.pair); // now we have 4 edge to expand, won't get into strange shape\n         adjacentRed.set(splitOut.wingedEdge, outEdge.wingedEdge);\n         adjacentRed.set(outEdge.wingedEdge, splitOut.wingedEdge);\n         ret.selectedFaces.add(outEdge.face);\n         const orig = this.prepVertexAdd(insertion, splitOut, adjacentRed, vertexLimit);\n         //adjacentRed.delete(splitOut.wingedEdge);\n         //adjacentRed.delete(outEdge.wingedEdge);\n         const edge = this.simpleSplit(insertion);\n         orig.outEdge = edge.pair;\n         ret.vertices.push( orig );\n         ret.halfEdges.push( edge.pair );\n         // remember to fix the last edge\n         const hEdge = edge.pair;\n         hEdge.next = outEdge;\n         splitOut.pair.next = hEdge;\n         // fix the face pointer\n         hEdge.face = outEdge.face;\n         hEdge.face.numberOfVertex++;\n         // this vertexLimit will limit to outer ring\n         let pts = vertexLimit.get(vertex);\n         pts.push(outEdge.pair);\n         pts.push(insertion.pair.next.pair);\n         pts = vertexLimit.get(orig);\n         pts[0] = pts[0].prev(); // readjust\n      } else if (edgeInsertion.length === 2) {   // 2 edges, so they should be sharing the same edge.\n         const inStart = edgeInsertion[0];\n         // breakup the insertion point, to reuse the lone edge\n         let hEdge = inStart.next.pair;\n         hEdge.next = insertion.next;\n         insertion.next = hEdge;\n         // fix the face ptr\n         hEdge.face = insertion.face;\n         hEdge.face.numberOfVertex++;\n         this.addAffectedFace(hEdge.face);\n         // fix the vertexLimit.\n         const pts = vertexLimit.get(hEdge.next.origin); // to limit the original vertex\n         if (!this.isSplitEdgeSelected(hEdge.next.origin, hEdge.origin, adjacentRed)) {\n            const red = [];\n            // we move along non-selected edge\n            do { hEdge = hEdge.next.pair; red.push(hEdge); } while (adjacentRed.has(hEdge.wingedEdge));\n            if (hEdge !== insertion.next) {\n               pts.push( hEdge );\n               slideEdge.add(hEdge );\n            } else { // reselect all.\n               red.pop();\n               for (let hEdge of red) {pts.push(hEdge);slideEdge.add(hEdge);}\n            }\n         } else {  // adjust vertex, a lot of hacks.\n            const hEdge2 = hEdge.next.pair;\n            let prev = hEdge2.prev(); pts.push( prev ); slideEdge.add(prev);\n            let temp = hEdge2.next.next.pair; pts.push(temp); slideEdge.add(temp);\n            // readjust original\n            const pts2 = vertexLimit.get(hEdge.origin);\n            prev = pts2[0].prev(); pts2[0] = prev; slideEdge.add(prev);\n            temp = pts2[1].pair.next.pair; pts2[1] = temp; slideEdge.add(temp);\n            twoEdgeVertexHack.add(hEdge.origin).add(hEdge.destination());\n         }\n      } else { // normal expansion\n         // add the last one, simple split\n         // check(insertion.destination !== insertion.next.origin);\n         this.prepVertex(insertion, edgeInsertion[0].pair, adjacentRed, vertexLimit, slideEdge);\n         const edge = this.simpleSplit(insertion);\n         ret.halfEdges.push(edge.pair);\n         // create a new innerface, and fix the edge to point to it\n         edge.pair.next = prevOut.pair;\n         firstOut.pair.next = edge.pair;\n         const polygon = this._createPolygon(edge.pair, edgeInsertion.length);\n         ret.selectedFaces.add( polygon );\n      }\n   }\n   // compute vertexLimit magnitude, and expanding direction. (reuse normal), \n   // now (vertexLimit - vertex) = direction. \n   ret.vertexLimit = Number.MAX_SAFE_INTEGER;       // magnitude\n   ret.position = new Float32Array(ret.vertices.length*3);     // saved the original position\n   ret.direction = new Float32Array(ret.vertices.length*3);    // also add direction.\n   let i = 0;\n   const pt = vec3.create();  // temporary\n   for (let vertex of ret.vertices) {\n      const position = ret.position.subarray(i, i+3);\n      const direction = ret.direction.subarray(i, i+3);\n      const hEdges = vertexLimit.get(vertex);\n      let avg = 1.0;\n      if (twoEdgeVertexHack.has(vertex)) {\n         avg = 0.4;\n      }\n      for (let hEdge of hEdges) {\n         vec3.copy(pt, hEdge.origin.vertex);\n         vec3.copy(position, vertex.vertex);\n         vec3.sub(pt, pt, position);\n         let average = avg;\n         if (slideEdge.has(hEdge.pair)) { // yep, we can only go as far as half point.\n            average = 0.5;\n         } \n         ret.vertexLimit = Math.min(vec3.length(pt)*average, ret.vertexLimit);\n         vec3.normalize(pt, pt);\n         vec3.add(direction, direction, pt);\n      }\n      if (avg == 0.4) {\n         vec3.normalize(direction, direction);\n      }\n      i+=3;\n   }\n\n   // we needs faces, we needs\n   return ret;\n};\n\n//\n// bevel Vertex. create new edge between each vertex's outEdge, which is n. will create (n-1) vertex, and one face, for each \n// selected vertex.\nWingedTopology.prototype.bevelVertex = function(vertices) {\n   const ret = {vertices: [], halfEdges: [], selectedFaces:[], };\n\n   const slideHEdges = new Set;\n   for (let vertex of vertices) {\n      let prevOut = vertex.outEdge;\n      let prevBevel;\n      let outEdge = prevOut.pair.next;\n      let count = 0;\n      ret.vertices.push(vertex);\n      slideHEdges.add(outEdge);\n      while (outEdge !== vertex.outEdge) { // splice between outTarget and inEdge. add a new Vertex\n         const origin = this.addVertex(outEdge.origin.vertex);\n         ret.vertices.push(origin);\n         outEdge.origin = origin;\n         origin.outEdge = outEdge;\n         slideHEdges.add(outEdge);\n         const outNext = outEdge.pair.next;     // save the next Out\n         let outBevel = this.simpleSplit(prevOut.pair);  // the newly create bevel edge\n         ret.halfEdges.push(outBevel.pair);\n         //origin.outEdge = outBevel.pair;\n         ++count;\n         if (prevBevel) {  // innerEdge connect together.\n            outBevel.pair.next = prevBevel.pair;\n         }\n         prevBevel = outBevel;\n         // check(outEdge.next === nextOut);\n         prevOut = outEdge;\n         outEdge = outNext;\n      }\n      // fixed the inner edge then add face.\n      if (count > 1) {  // add the last edge\n         let lastBevel = this.simpleSplit(prevOut.pair);\n         ret.halfEdges.push(lastBevel);   // reverse direction. so collapse will do the right thing.\n         lastBevel.pair.next = prevBevel.pair; \n         const firstBevel = vertex.outEdge.pair.next;\n         firstBevel.pair.next = lastBevel.pair;   // innerEdge loop connected.\n         const polygon = this._createPolygon(firstBevel.pair, count+1);\n         ret.selectedFaces.push(polygon);\n      } else { // weird case of 2 edge vertex\n\n      }\n   }\n\n   // compute moveLimit.\n   ret.vertexLimit = Number.MAX_SAFE_INTEGER;       // magnitude\n   ret.position = new Float32Array(ret.vertices.length*3);     // saved the original position\n   ret.direction = new Float32Array(ret.vertices.length*3);    // also add direction.\n   let i = 0;\n   for (let vertex of ret.vertices) {\n      const position = ret.position.subarray(i, i+3);\n      const direction = ret.direction.subarray(i, i+3);\n      vec3.copy(position, vertex.vertex);\n      vec3.sub(direction, vertex.outEdge.destination().vertex, position);\n      if (slideHEdges.has(vertex.outEdge.pair)) {  // half length because we are sharing the expansion.\n         ret.vertexLimit = Math.min(vec3.length(direction)*0.5, ret.vertexLimit);\n      } else {\n         ret.vertexLimit = Math.min(vec3.length(direction), ret.vertexLimit);  // the full length.\n      }\n      vec3.normalize(direction, direction);\n      i += 3;\n   }\n\n   // results\n   return ret;\n};\n\n\n\nWingedTopology.prototype.extrudeContours = function(edgeLoops) {\n   // extrude face. connect(outer, inner) loop.\n   let extrudeContours = [];\n   for (let contour of edgeLoops) {\n      for (let edge of contour) {\n         let polygon = [];\n         polygon.push( edge.inner.origin.index );\n         polygon.push( edge.outer.origin.index );\n         polygon.push( edge.outer.destination().index );\n         polygon.push( edge.inner.destination().index );\n         this.addPolygon( polygon );\n         extrudeContours.push( this.findHalfEdge(edge.inner.origin, edge.outer.origin) );\n      }\n   }\n\n   return extrudeContours;\n};\n\n// Similar to findFaceGroup\nWingedTopology.prototype.findEdgeGroup = function(selectedWingedEdge) {\n   const processWingedEdge = new Set(selectedWingedEdge);\n   let wingedEdgeGroup = null;\n   function processNeighbors(wingedEdge) {\n      processWingedEdge.delete(wingedEdge);\n      wingedEdgeGroup.add(wingedEdge);\n      for (let neighborWinged of wingedEdge.oneRing()) {\n         if (processWingedEdge.has(neighborWinged)) {\n            processNeighbors(neighborWinged);\n         }\n      }\n   };\n\n   let list = [];\n   for (let wingedEdge of processWingedEdge) {\n      wingedEdgeGroup = new Set;\n      processNeighbors(wingedEdge);\n      list.push( wingedEdgeGroup );\n   }\n\n   return list;\n};\n\n\n//\n// similar to findContours. but return a list of faces.\n//\nWingedTopology.findFaceGroup = function(selectedPolygon) {\n   const processPolygon = new Set(selectedPolygon);\n   let faceGroup = null;\n\n   function processNeighbors(polygon) {\n      processPolygon.delete(polygon);\n      faceGroup.add(polygon);\n      polygon.eachVertex( (vertex) => {   // polygon sharing the same vertex will be group together\n         vertex.eachOutEdge( (outEdge) => {\n            const face = outEdge.pair.face;\n            if (processPolygon.has(face)) {\n               // depth first search\n               processNeighbors(face);\n            }\n          });\n      });\n   };\n\n   let list = [];\n   for (let polygon of processPolygon) {\n      faceGroup = new Set;\n      processNeighbors(polygon);\n      list.push( faceGroup );\n   }\n\n   return list;\n}\n\n\n\nWingedTopology.findContours = function(selectedPolygon) {\n   const contourEdges = new Set;\n   const edgeLoops = [];\n   // find all contourEdges to extrude\n   for (let polygon of selectedPolygon) {\n      polygon.eachEdge( function(outEdge) {\n         if (!contourEdges.has(outEdge) && !selectedPolygon.has(outEdge.pair.face)) {\n            const edgeLoop = [];\n            let currentIn = outEdge;\n            do {\n               // this edge is contour. now walk cwRing to find the next edges.\n               let nextIn = currentIn.next.pair;\n               while (nextIn !== currentIn) {\n                  if (!selectedPolygon.has(nextIn.face)) { // yup, find the other contour\n                     break;\n                  }\n                  nextIn = nextIn.next.pair;\n               }\n               const edge = {outer: currentIn, inner: null};\n               edgeLoop.push( edge );\n               contourEdges.add(currentIn);       // checkIn the contour edge.\n               // we cw walk over to the next contour edge.\n               currentIn = nextIn.pair;\n            } while (currentIn !== outEdge);      // check if we come full circle\n            edgeLoops.push( edgeLoop );\n         }\n      } );\n   }\n\n   return edgeLoops;\n};\n\n\n// weld innerLoop to outerLoop. both side must null face. \nWingedTopology.prototype.weldContour = function(edgeLoop) {\n   let edgePrev = edgeLoop[edgeLoop.length-1]\n   for (let i = 0; i < edgeLoop.length; ++i) {\n      const edge = edgeLoop[i];\n      if (edgePrev.inner.next !== edge.inner) { // check for contour tht don't have interpose edge\n         const end = edge.inner;\n         let current = edgePrev.inner.next;\n         edgePrev.outer.next = current;\n         let prev;\n         do {\n            current.origin = edge.outer.origin;\n            prev = current.pair;\n            current = prev.next;\n         } while (current !== end);\n         prev.next = edge.outer;\n      }\n      edge.outer.face = edge.inner.face;\n      if (edge.inner.face.halfEdge === edge.inner) {\n         edge.outer.face.halfEdge = edge.outer;\n      }\n\n      edgePrev = edge;\n      this.addAffectedFace(edge.outer.face);\n   }\n\n   // now we can safely release memory\n   for (let edge of edgeLoop) {\n      edge.restore = {origin: edge.inner.origin, pt: vec3.clone(edge.inner.origin.vertex), hEdge: edge.inner};\n      // remove vertex, and edge.\n      this._freeVertex(edge.inner.origin);\n      this._freeEdge(edge.inner);\n\n   }\n};\n\n\nWingedTopology.prototype._liftLoop = function(edgeLoop) {\n   // lift loop\n   let edge0 = edgeLoop[edgeLoop.length-1];\n   // lift the face edge from outer to inner.\n   for (let j = 0; j < edgeLoop.length; ++j) {\n      let edge1 = edgeLoop[j];\n      // lift edges from outer, and connect to inner\n      let outerNext = edge0.outer.next;\n      if (outerNext !== edge1.outer) {\n         // lift begin to end\n         let outer1Prev = edge1.outer.prev();\n         edge0.outer.next = edge1.outer;\n         edge0.inner.next = outerNext;\n         outer1Prev.next = edge1.inner;\n         // reset all vertex\n         let inner = outerNext;\n         do {\n            if (inner.origin.outEdge === inner) {\n               inner.origin.outEdge = edge1.outer;\n            }\n            inner.origin = edge1.inner.origin;\n            inner = inner.pair.next;\n         } while (inner !== edge1.inner);\n      }\n      edge0 = edge1;       // move edge post\n      // setup the faces.\n      edge1.inner.face = edge1.outer.face;\n      edge1.outer.face = null;\n      if (edge1.inner.face.halfEdge === edge1.outer) {\n         edge1.inner.face.halfEdge = edge1.inner;\n      }\n      this.addAffectedFace(edge1.inner.face);\n   }\n   return edgeLoop;\n};\n// lift edges from outerLoop to innerLoop. null the face between inner and outerface\nWingedTopology.prototype.liftContour = function(edgeLoop) {\n   if (edgeLoop.length === 0) {   // should not happened, but. Should we check ( < 4) too?\n      return edgeLoop;\n   }\n\n   let firstVertex = this.addVertex(edgeLoop[0].outer.origin.vertex);\n   let fromVertex = firstVertex; \n   for (let i = 0; i < edgeLoop.length; ++i) {\n      let outerEdge = edgeLoop[i].outer;\n      let toVertex;\n      if (i == (edgeLoop.length-1)) {  // the last one loopback\n         toVertex = firstVertex;\n      } else {\n         toVertex = this.addVertex(outerEdge.destination().vertex);\n      }\n      edgeLoop[i].inner = this.addEdge(fromVertex, toVertex);\n      fromVertex = toVertex;\n   }\n\n   return this._liftLoop(edgeLoop);\n};\nWingedTopology.prototype.restoreContour = function(edgeLoop) {\n   if (edgeLoop.length === 0) {   // should not happened, but. Should we check ( < 4) too?\n      return edgeLoop;\n   }\n\n   // restore\n   for (let edge of edgeLoop) { // restore vertex\n      this.addVertex(edge.restore.pt, edge.restore.origin);\n   }\n   let prev;\n   for (let i = 0; i < edgeLoop.length; ++i) { // restore edge\n      const edge = edgeLoop[i];\n      const edgeNext = edgeLoop[(i+1)%edgeLoop.length];\n      const current = this._createEdge(edge.restore.origin, edgeNext.restore.origin, edge.restore.hEdge); // destination = next.origin\n      edge.restore.origin.outEdge = current;\n      if (prev) {\n         prev.next = current;\n         current.pair.next = prev.pair;\n      }\n      prev = current;\n   }\n   // connect last to first\n   prev.next = edgeLoop[0].inner;\n   edgeLoop[0].inner.pair.next = prev.pair;\n\n   return this._liftLoop(edgeLoop);\n};\n\n\n// lift edges from outerLoop to innerLoop.\nWingedTopology.prototype.liftContours = function(edgeLoops) {\n   for (let edgeLoop of edgeLoops) {\n      this.liftContour(edgeLoop);\n   }\n\n   return edgeLoops;\n};\n\n\n// insert a new edge, for undo purpose\nWingedTopology.prototype._liftEdge = function(outLeft, inRight, fromVertex, delEdge) {\n   const beg = outLeft.prev();\n   const endOut = inRight.next;\n   const outEdge = this._createEdge(fromVertex, outLeft.origin, delEdge);\n   const inEdge = outEdge.pair;\n   inRight.next = outEdge;\n   outEdge.next = endOut;\n   inEdge.next = outLeft;\n   beg.next = inEdge;\n   fromVertex.outEdge = outEdge;\n   // lift edges up from left to right.\n   let currentOut = outLeft;\n   do {\n      if (currentOut.origin.outEdge === currentOut) {\n         currentOut.origin.outEdge = endOut; // or inEdge a safer choice? \n      }\n      currentOut.origin = fromVertex;\n      this.addAffectedWEdge( currentOut.wingedEdge );\n      currentOut = currentOut.pair.next;\n   } while (currentOut !== outEdge);\n   outEdge.face = inRight.face;\n   if (outEdge.face) {\n      outEdge.face.numberOfVertex++;\n      this.addAffectedFace(outEdge.face);\n   }\n   inEdge.face = outLeft.face;\n   if (inEdge.face) {\n      inEdge.face.numberOfVertex++;\n      this.addAffectedFace(inEdge.face);\n   }\n}\n\n\nWingedTopology.prototype._collapseEdge = function(halfEdge) {\n   const next = halfEdge.next;\n   const prev = halfEdge.prev();\n\n   const pair = halfEdge.pair;\n   const pairNext = pair.next;\n   const pairPrev = pair.prev();\n\n   const fromVertex = halfEdge.origin;\n   const toVertex = pair.origin;\n\n   // halfedge -> vertex\n   let current = pairNext;\n   while (current !== halfEdge) {\n      current.origin = toVertex;\n      this.addAffectedWEdge(current.wingedEdge);\n      current = current.pair.next;\n   }\n\n   // reconnect \n   prev.next = next;\n   pairPrev.next = pairNext;\n\n   // adjust face\n   let face = halfEdge.face;\n   if (face) {\n      if (face.halfEdge === halfEdge) {\n         face.halfEdge = next;\n      }\n      face.numberOfVertex--;\n      this.addAffectedFace(face);\n   }\n   face = pair.face;\n   if (face) {\n      if (face.halfEdge === pair) {\n         face.halfEdge = pairNext;\n      }\n      face.numberOfVertex--;\n      this.addAffectedFace(face);\n   }\n   // adjust vertex\n   if (toVertex.outEdge === pair) {\n      toVertex.outEdge = next;\n   }\n\n   // delete stuff\n   this._freeEdge(halfEdge);\n   this._freeVertex(fromVertex);\n\n   // undo collapseEdge\n   return {hEdge: halfEdge, pairNext: pairNext, prev: prev, vertex: fromVertex};\n};\n\n// undo of  _collapseLoop.\nWingedTopology.prototype._restoreLoop = function(halfEdge, delEdge, delPolygon) {\n   const prev = halfEdge.prev();\n   const outEdge = this._createEdge(halfEdge.destination(), halfEdge.origin, delEdge);\n   const inEdge = outEdge.pair;\n\n   // fix connection\n   prev.next = inEdge;\n   inEdge.next = halfEdge.next;\n   halfEdge.next = outEdge;\n   outEdge.next = halfEdge;\n\n   // fix face\n   inEdge.face = halfEdge.face;\n   const newPolygon = this._createPolygon(outEdge, 2, delPolygon);\n   halfEdge.face = newPolygon;   // unnecessary, already update\n   outEdge.face = newPolygon;    // unnecessary, already update.\n\n   // fix face.outEdge\n   if (inEdge.face.halfEdge === halfEdge) {\n      inEdge.face.halfEdge = inEdge;\n   }\n};\nWingedTopology.prototype._collapseLoop = function(halfEdge, collapsibleWings) {\n   if (collapsibleWings && !collapsibleWings.has(halfEdge.wingedEdge)) {   // if not collapsible, move to next.\n      halfEdge = halfEdge.next;  // need not check, if both are collapsible, either one are ok.\n   }\n   const next = halfEdge.next;\n   const pair = halfEdge.pair;\n   const nextPair = next.pair;\n\n   // is it a loop ?//assert ((next_halfedge_handle(h1) == h0) && (h1 != o0));\n\n   // fix halfEdge.next connectionh\n   next.next = pair.next;\n   pair.prev().next = next;\n\n   // fix halfEdge.face\n   let polygon = pair.face;\n   next.face = polygon;\n\n   // fix vertex.outEdge;\n   if (halfEdge.origin.outEdge === halfEdge) {\n      halfEdge.origin.outEdge = nextPair;   // adjustOutgoing();\n   }\n   if (pair.origin.outEdge === pair) {\n      pair.origin.outEdge = next;      // adjustOutgoingEdge();\n   }\n\n   // fix face.halfEdge\n   if (polygon.halfEdge === pair) {\n      polygon.halfEdge = next;\n   }\n\n   // delete stuff\n   const delPolygon = halfEdge.face;\n   this._freePolygon(halfEdge.face);\n   this._freeEdge(halfEdge);\n   \n   // restoreLoop\n   return {next: next, hEdge: halfEdge, polygon: delPolygon};\n};\n\n\nWingedTopology.prototype.collapseEdge = function(halfEdge, collapsibleWings) {\n   const next = halfEdge.next;\n   const pair = halfEdge.pair;\n   const pairNext = pair.next;\n\n   // remove edge\n   const undo = this._collapseEdge(halfEdge);\n\n   // remove loops(2 side polygon)\n   if (next.next.next === next) {\n      undo.leftLoop = this._collapseLoop(next.next, collapsibleWings);\n   }\n   if (pairNext.wingedEdge.isLive() && (pairNext.next.next === pairNext)) {   // add wingedEdge.isLive() to guard (--) edges.\n      undo.rightLoop = this._collapseLoop(pairNext, collapsibleWings);\n   }\n   return undo;\n};\n\nWingedTopology.prototype.restoreCollapseEdge = function(undo) {\n   if (undo.rightLoop) {\n      this._restoreLoop(undo.rightLoop.next, undo.rightLoop.hEdge, undo.rightLoop.polygon);\n   }\n   if (undo.leftLoop) {\n      this._restoreLoop(undo.leftLoop.next, undo.leftLoop.hEdge, undo.leftLoop.polygon);\n   }\n   // undo collapseEdge\n   this._liftEdge(undo.pairNext, undo.prev, this.addVertex(undo.vertex.vertex, undo.vertex), undo.hEdge);\n};\n\n\n// fixed the halfEdge relation only.\nWingedTopology.prototype._removeEdge = function(outEdge, inEdge) {\n   const outPrev = outEdge.prev();\n   const outNext = outEdge.next;\n   const inPrev = inEdge.prev();\n   const inNext = inEdge.next;\n   \n   outPrev.next = inNext;\n   inPrev.next = outEdge.next;\n\n   //correct vertex.outEdge if needed.\n   if (outEdge.origin.outEdge === outEdge) {\n      outEdge.origin.outEdge = outPrev.pair;\n   }\n   if (inEdge.origin.outEdge === inEdge) {\n      inEdge.origin.outEdge = inPrev.pair;\n   }\n   return {outPrev: outPrev, outNext: outNext, outEdge: outEdge}; // changed to restore outEdge\n}\n// won't work with potentially \"dangling\" vertices and edges. Any doubt, call dissolveEdge\nWingedTopology.prototype.removeEdge = function(outEdge) {\n   let inEdge = outEdge.pair;\n   if (inEdge.face === null && outEdge.face !== null) {   // switch side\n      inEdge = outEdge;\n      outEdge = inEdge;\n      /*if (inEdge.face === null) {\n         console.log(\"error, both side of the edges are null faces\");\n         return null;\n      }*/\n   }\n\n   //fix the halfedge relations\n   const remove = this._removeEdge(outEdge, inEdge);\n  \n   //deal with the faces\n   const delFace = outEdge.face;    // the other side is boundary, after removal becomes boundary too.\n   const face = inEdge.face;\n\n   if (face !== null) {\n      if (face.halfEdge === inEdge) { //correct the halfedge handle of face if needed\n         face.halfEdge = remove.outPrev;\n      }\n   // make sure everye connect edge point to the same face.\n      face.numberOfVertex = 0;\n      for (let hEdge of face.hEdges()) {\n         ++face.numberOfVertex;\n         hEdge.face = face;\n      }\n      this.addAffectedFace(face);\n   }\n\n   if (delFace !== null) {    // guaranteed to be non-null, but maybe later use case will change, (yes, makeHole needs to be both-null. 2018-08-28)\n      this._freePolygon(delFace);\n      remove.delFace = delFace;\n   }\n   this._freeEdge(outEdge);\n\n   // return undo function\n   return remove;\n   //return face;   // return the remaining face handle\n};\nWingedTopology.prototype.restoreRemoveEdge = function(undo) {\n   this.insertEdge(undo.outPrev, undo.outNext, undo.outEdge, undo.delFace);\n};\n\n\n\nWingedTopology.prototype.dissolveEdge = function(outEdge, collapsibleWings) {\n   // check next only connect to outEdge? \n   const inEdge = outEdge.pair;\n   if (outEdge.next.pair.next === inEdge) {\n      return this.collapseEdge(inEdge, collapsibleWings);   // collapse inward\n   } else if (inEdge.next.pair.next === outEdge) {\n      return this.collapseEdge(outEdge, collapsibleWings);  // collapse outward\n   } else {\n      return this.removeEdge(outEdge);    // normal dissolve\n   }\n};\n\nWingedTopology.prototype.restoreDissolveEdge = function(undo) {\n   if (undo.outPrev) {\n      this.restoreRemoveEdge(undo);\n   } else {\n      this.restoreCollapseEdge(undo);\n   }\n};\n\n\n\n// selectedVertex. search the nearest edge on the same face.\n// 2 ways to determine if vertex is edge. 1)prev, next edges are not parallel. 2) vertex has only 2 wingededges, and share the same faces.\n// we decided to use the 2nd way temporary. After everything is debugged, switch to first method because it more robust.\nWingedTopology.prototype.connectVertex = function(selectedVertex) {\n   // first collect face from vertex.\n   const selectedFace = new Map();\n   for (let vertex of selectedVertex) {\n      vertex.eachOutEdge( function(edge) {\n         let val = 1;\n         if (selectedFace.has(edge.face)) {\n            val = selectedFace.get(edge.face) + 1;\n         }\n         selectedFace.set(edge.face, val);\n      });\n   }\n\n   // corner. \n   const faceList = [];\n   let edges = [];       // each face's edges\n   // second (group vertex) that have the same faces as same edgeGroup.\n   for (let [polygon, faceCount] of selectedFace) {\n      if (faceCount > 1) {\n         // at least 2 vertex selected.\n         let prevEdgeNumber = -1;\n         let edgeNumber = -1;\n         let outEdge = polygon.halfEdge;\n         // find first corner.\n         while (outEdge.origin.valence == 2) {\n            outEdge = outEdge.next;\n         }\n         // ok, first corner.\n         const firstCorner = outEdge;\n         do {\n            let valence = outEdge.origin.valence;\n            prevEdgeNumber = edgeNumber;\n            if (valence != 2) {        // we should really check for straight line.\n               edgeNumber++;\n            }\n            if (selectedVertex.has(outEdge.origin)) {\n               const obj = {prevEdgeNumber: prevEdgeNumber, edgeNumber: edgeNumber, outEdge: outEdge};\n               edges.push( obj );\n            }\n            outEdge = outEdge.next;\n         } while (outEdge !== firstCorner);\n         //update first edges number\n         const edge = edges[0];\n         if (edge.prevEdgeNumber == -1) {\n            edge.prevEdgeNumber = edgeNumber;\n         }\n         // save to face list\n         faceList.push( edges );\n         edges = [];\n      }\n   }\n\n\n   const edgeList = [];\n   // the real meat, connect vertex.\n   for (let edges of faceList) {\n      // check for special case. one interior selected vertex per edge. update. includeing zero selected vertex per edge.\n      let specialCase = true;\n      let prevEdgeNumber = -1;\n      for (let [_i, edge] of edges.entries()) {\n         if ( (edge.prevEdgeNumber !== edge.edgeNumber) || (prevEdgeNumber == edge.edgeNumber) ) {   // corner or more than 1 vertex on same Edge.\n            specialCase = false;\n            break;\n         }\n         prevEdgeNumber = edge.edgeNumber;\n      }\n      if (specialCase) {\n         if (edges.length === 2) {  // connect 2 edges will have a 2 side polygon, so just connect one edge. last to first, first to last is the same edge.\n            edgeList.push( this.insertEdge(edges[0].outEdge.prev(), edges[1].outEdge));\n         } else {\n            const edge0Prev = edges[0].outEdge.prev();\n            for (let i = 0; i < edges.length; ++i) {\n               let origin = edges[i];\n               let destination;\n               let edge;\n               if ( (i+1) < edges.length) {\n                  destination = edges[i+1];\n                  edge = this.insertEdge(origin.outEdge.prev(), destination.outEdge);\n               } else { // connect last to first.\n                  edge = this.insertEdge(origin.outEdge.prev(), edge0Prev.next);\n               }\n               edgeList.push( edge );\n            }\n         }\n      } else {\n         // walk from beginning++, and end--.\n         let i = edges.length-1;\n         let j = 0;\n         do {\n            let origin = edges[i];\n            let destination = edges[j];\n            if (origin.edgeNumber != destination.prevEdgeNumber) {\n               const edge = this.insertEdge(origin.outEdge.prev(), destination.outEdge);\n               edgeList.push( edge );\n               i--;\n            }\n            j++;     // move to next destination.\n         } while (j < i);\n      }\n   }\n   // return insertEdge list.\n   return edgeList;\n};\n\n\nWingedTopology.prototype.removePolygon = function(polygon) {\n   for (let hEdge of polygon.hEdges()) {\n      hEdge.face = null;\n   }\n   // put into freeList.\n   this._freePolygon(polygon);\n};\n/*function isCorner(outEdge) {\n   const prev = outEdge.prev();\n   const a = vec3.create();\n   vec3.sub(a, outEdge.destination().vertex, outEdge.origin.vertex); \n   const b = vec3.create();\n   vec3.sub(b, prev.origin.vertex, prev.destination().vertex);\n   const cosTheta = vec3.dot(a, b) / (vec3.len(a) + vec3.len(b));\n   // none straight line is corner; cos 180 === -1. cos 0 === 1.\n   return cosTheta > -0.992;   // ~< 175 degree. is a corner.\n}*/\n\nWingedTopology.prototype.dissolveVertex = function(vertex) {\n   // now free the vertex.\n   const self = this;\n   const pt = new Float32Array(3);\n   vec3.copy(pt, vertex.vertex);\n   if (vertex.isIsolated()) {\n      this._freeVertex(vertex);\n      return {pt: pt, vertex: vertex};\n   } else {\n      this.addAffectedEdgeAndFace(vertex);\n      let count = 0;\n      const firstIn = vertex.outEdge.pair;\n      let lastIn;\n      // slide edge, move edge down like collapse edge, without the collapsing.\n      let outEdge;    // outEdge for new Polygon\n      vertex.eachInEdge( function(inEdge) {\n         //inEdges.unshift( inEdge );\n         const nextOut = inEdge.next;\n         outEdge = inEdge.pair;\n         if (nextOut.face.halfEdge === nextOut) {\n            nextOut.face.halfEdge = inEdge;   // reassigned outEdge.\n         }\n         --nextOut.face.numberOfVertex;\n         inEdge.next = nextOut.next;      // slide down the next Edge.\n         nextOut.next = outEdge;\n         outEdge.origin = nextOut.pair.origin; // reassign new vertex\n         count++;\n         lastIn = inEdge;\n      });\n      // remove loop edge.\n      const polygon = this._createPolygon(outEdge, count);\n      const undoCollapseLoop = [];\n      let vertexOutEdge = vertex.outEdge;\n      outEdge = vertex.outEdge;\n      do {\n         let inEdge = outEdge.pair;\n         outEdge = outEdge.next;\n         if (inEdge.next.next === inEdge) {  // 2 edge loop, not polygon, now collapse it.\n            if (inEdge.pair === vertexOutEdge) {\n               vertexOutEdge = inEdge.next;  // \n            }\n            undoCollapseLoop.unshift( this._collapseLoop(inEdge) );   // collapse inward\n         } else {\n            //inEdge.pair.face = polygon;      // already assigned in _createPolygon.\n         }\n      } while (outEdge !== vertexOutEdge);\n      // free vertex\n      this._freeVertex(vertex);\n      return {polygon: polygon, pt: pt, vertex: vertex, undoCollapseLoop: undoCollapseLoop, lastIn: lastIn, firstIn: firstIn};\n   }\n};\nWingedTopology.prototype.restoreDissolveVertex = function(undo) {\n   if (undo.polygon) {\n      // reallocated free vertex\n      const vertex = this.addVertex(undo.pt, undo.vertex);\n      // undo collapse loop\n      for (let loop of undo.undoCollapseLoop) {\n         this._restoreLoop(loop.next, loop.hEdge, loop.polygon);\n      }\n      // reattach edges to vertex\n      let inEdge = undo.lastIn;\n      let lastIn = undo.lastIn.next.pair;\n      let prevIn = undo.firstIn;\n      do {\n         let outEdge = inEdge.pair;\n         outEdge.origin = vertex;\n         let prevOut = prevIn.pair;\n         prevOut.next = inEdge.next;\n         inEdge.next = prevOut;\n         prevOut.face = inEdge.face;  \n         ++prevOut.face.numberOfVertex;\n         // ready for next.\n         prevIn = inEdge;\n         inEdge = outEdge.next.pair;\n      } while (inEdge !== lastIn);\n      vertex.outEdge = undo.firstIn.pair;\n      // free polygon\n      this._freePolygon(undo.polygon);\n      // selected vertex\n      this.addAffectedEdgeAndFace(vertex);\n   } else { // isolated vertex\n      this.addVertex(undo.pt, undo.vertex);\n   }\n   return undo.vertex;\n};\n\n//\n// bridge the 2 faces. and \n//\nWingedTopology.prototype.bridgeFace = function(targetFace, sourceFace, deltaCenter) {\n   const ret = {target: {face: targetFace, hEdge: targetFace.halfEdge}, source: {face: sourceFace, hEdge: sourceFace.halfEdge} };\n   // get the 2 faces vertices\n   const targetHEdges = [];\n   const sourceHEdges = [];\n   for (let hEdge of targetFace.hEdges()) {\n      targetHEdges.push( hEdge );\n      hEdge.face = null;   // remove face reference\n   }\n   // move source to target\n   for (let hEdge of sourceFace.hEdges()) {\n      const point = vec3.clone(hEdge.origin.vertex);\n      vec3.add(point, point, deltaCenter);\n      sourceHEdges.unshift( {hEdge: hEdge, delta: point} );  // reverse direction.\n      hEdge.face = null;   // remove face reference\n   }\n   // project origin's vertices  to target's plane? skip it for now\n   // find the smallest length combined.\n   let index = -1;\n   let len = Number.MAX_SAFE_INTEGER;\n   const temp = vec3.create();\n   for (let i = 0; i < sourceFace.numberOfVertex; ++i) {\n      // add up th length\n      let currentLen = 0;\n      for (let j = 0; j < targetHEdges.length; ++j) {\n         vec3.sub(temp, targetHEdges[j].origin.vertex, sourceHEdges[j].delta);\n         len += vec3.length(temp);\n      }\n      if (currentLen < len) {\n         len = currentLen;\n         index = i;\n      }\n      sourceHEdges.push( sourceHEdges.shift() );  // rotate \n   }\n   // hopefully -1 works well enough with splice and unshift.\n   sourceHEdges.unshift.apply( sourceHEdges, sourceHEdges.splice(index-1, sourceHEdges.length ) ); // rotate to desired location.\n   // remove face, and bridge target[0] at the source index\n   this._freePolygon(targetFace);\n   this._freePolygon(sourceFace);\n   let hEdgePrev = null;\n   const hEdges = [];\n   for (let i = 0; i < targetHEdges.length; ++i) {  // create new Edge, new Face.\n      const hEdge = this.addEdge(sourceHEdges[i].hEdge.origin, targetHEdges[i].origin);\n      if (hEdgePrev) {  // added the face\n         this._createPolygon(hEdgePrev, 4);\n      }\n      hEdges.push( hEdge );\n      hEdgePrev = hEdge;\n   }\n   this._createPolygon(hEdgePrev, 4);\n\n   ret.hEdges = hEdges;\n   return ret;\n}\n\nWingedTopology.prototype.undoBridgeFace = function(bridge) {\n   for (let hEdge of bridge.hEdges) {\n      this.removePolygon(hEdge.face);  // free face first\n   }\n   for (let hEdge of bridge.hEdges) {\n      this._removeEdge(hEdge, hEdge.pair); // remove edge later.\n   }\n   // now, get the 2 face back\n   this._createPolygon(bridge.target.hEdge, bridge.hEdges.length, bridge.target.face);\n   this._createPolygon(bridge.source.hEdge, bridge.hEdges.length, bridge.source.face);\n};\n\n//\n// insetFace.\n//\nWingedTopology.prototype.findInsetContours = function(polygonSet) {\n   // find contour.\n   const edgeLoops = [];\n   for (let polygon of polygonSet) {\n      const edgeLoop = [];\n      for (let hEdge of polygon.hEdges()) {\n         const edge = {outer: hEdge, inner: null};\n         edgeLoop.push(edge);\n      }\n      edgeLoops.push( edgeLoop );\n   }\n\n   return edgeLoops;\n};\n\n\n\nWingedTopology.prototype._liftDanglingEdge = function(hEdge, destVert) {\n   const next = hEdge.next;\n   const danglingOut = this._createEdge(next.origin, destVert);\n   destVert.outEdge = danglingOut.pair;\n   hEdge.next = danglingOut;\n   danglingOut.pair.next = next;\n   danglingOut.face = danglingOut.pair.face = hEdge.face;   // assigned face, but don't update number of vertex.\n   return danglingOut;\n};\n//\n// insert a dangling corner edge at hEdge.next position.\nWingedTopology.prototype.liftCornerEdge = function(hEdge, percent = 0.2) {\n   const pt = vec3.create();\n   const vector = vec3.create();\n   // lift destination corner vertex\n   let next = hEdge.next;\n   vec3.lerp(pt, next.origin.vertex, next.destination().vertex, percent);\n   vec3.sub(vector, hEdge.origin.vertex, hEdge.destination().vertex);\n   vec3.scale(vector, vector, percent);\n   vec3.add(pt, pt, vector);\n   let destVert = this.addVertex(pt);\n   // fixup the new fence End\n   let danglingOut = this._liftDanglingEdge(hEdge, destVert);\n\n   return danglingOut;\n};\n//\n// fix up insertOut.destination() at inEdge.destination().\n//\n/*WingedTopology.prototype._insertEdge = function(begHalf, endHalf, delPolygon) {\n   const v0 = begHalf.destination();\n   const v1 = endHalf.destination();\n   const oldPolygon = begHalf.face;\n\n   // create edge and link together\n   const outEdge = this._createEdge(v0, v1);\n   const inEdge = outEdge.pair;\n   inEdge.next = begHalf.next;\n   outEdge.next = endHalf.next;\n   begHalf.next = outEdge;\n   begHalf.next = inEdge;\n  \n   //now set the face handles\n   const newPolygon = this._createPolygon(outEdge, 4, delPolygon);  // readjust size later.\n\n   // inEdge is oldPolygon\n   inEdge.face = oldPolygon;\n   if (oldPolygon.halfEdge.face === newPolygon) { //  pointed to one of the halfedges now assigned to newPolygon\n      oldPolygon.halfEdge = inEdge; // should add to restore list.\n   }\n   oldPolygon.update();\n   this.addAffectedFace( oldPolygon );\n\n   // adjustOutEdge for v0, v1. point to boundary so, ccw work better?\n   return outEdge;\n}*/\n//\n// extrudeEdge.\n//  \nWingedTopology.prototype.extrudeEdge = function(startFenceHEdge, finishFenceHEdge) {\n   const lift = [];\n   const extrude = [];\n   // \n   let sFenceOut = startFenceHEdge;\n   let current = startFenceHEdge.next;\n   let next = current.next;\n   const pt = vec3.create();\n   while (next !== finishFenceHEdge) {\n      // lift destination corner vertex\n      let fFenceIn = this.liftCornerEdge(current);   // at destination() of current\n      lift.push(fFenceIn.pair);\n      // extrude paralle edge.\n      let extrudeOut = this.insertEdge(fFenceIn, sFenceOut);\n      extrude.push( extrudeOut );\n      // move to nextEdge\n      sFenceOut = fFenceIn.pair;\n      current = next;\n      next = next.next;\n   }\n   // connect to the last one. \n   let extrudeOut = this.insertEdge(next, sFenceOut);\n   extrude.push( extrudeOut );\n\n   // return created halfEdges\n   return {extrude: extrude, lift: lift};\n};\n\n\nWingedTopology.prototype.slideToPrev = function(outEdge, prevPrev) {\n   if (!prevPrev) {\n      prevPrev = outEdge.prev().prev();\n   } else {\n      // check(prevPrev.next.next === outEdge)\n   }\n   const prev = prevPrev.next;\n   const inEdge = outEdge.pair;\n\n   if (outEdge.face.numberOfVertex <= 3) {   // collapseLoop already.\n      const result = {inEdge: outEdge, delFace: outEdge.face, inNext: outEdge.next, inPrev: outEdge.prev()};\n      this.this.removeEdge(outEdge);\n      return result;\n   }\n\n   // fix up th pointer\n   prev.next = inEdge.next;\n   inEdge.next = prev;\n   prevPrev.next = outEdge;\n\n   // fix up the faces.\n   if (outEdge.origin.outEdge === outEdge) {\n      outEdge.origin.outEdge = prev.next;  // we will be no longer using origin;\n   }\n   outEdge.origin = prev.origin;\n\n   // reassign face\n   if (prev.face.halfEdge === prev) {\n      prev.face.halfEdge = inEdge;\n   }\n   prev.face = inEdge.face;\n   ++inEdge.face.numberOfVertex;\n   --outEdge.face.numberOfVertex;\n\n   // for slideToNext\n   return {inEdge: inEdge};\n};\n\n\n// slide dow\nWingedTopology.prototype.slideToNext = function(inEdge) {\n   if (inEdge.face.numberOfVertex <= 3) {   // collapseLoop if slide, just remove the edge, simpler\n      const result = {inEdge: inEdge, delFace: inEdge.face, inNext: inEdge.next, inPrev: inEdge.prev()};\n      this.removeEdge(inEdge);   // todo: removeEdge should return result, instead of closure.\n      return result;\n   }\n\n   // Fix up the pointer and face.\n   const outEdge = inEdge.pair;\n   const next = inEdge.next;\n   const prev = outEdge.prev();\n\n   prev.next = next;\n   inEdge.next = next.next;\n   next.next = outEdge;\n\n   if (outEdge.origin.outEdge === outEdge) {\n      outEdge.origin.outEdge = next;  // we will be no longer using origin;\n   }\n   outEdge.origin = inEdge.next.origin;\n   this.addAffectedWEdge(outEdge.wingedEdge);\n\n   // reassign face.\n   if (next.face.halfEdge === next) {\n      next.face.halfEdge = inEdge;\n   }\n   inEdge.face = next.face;\n   next.face = outEdge.face; \n   ++outEdge.face.numberOfVertex;      // accounting.\n   --inEdge.face.numberOfVertex;       // oops, needs ot collapse edge\n   this.addAffectedFace( outEdge.face );\n   this.addAffectedFace( inEdge.face );\n\n   return {prevPrev: prev, outEdge: outEdge};   // for slideToPrev\n};\nWingedTopology.prototype.undoSlideToNext = function(result) {\n   if (result.delFace) {   // yep, removeEdge, so now restore.\n      this.insertEdge(result.inPrev, result.inNext, result.inEdge, result.delFace);\n   } else {\n      this.slideToPrev(result.outEdge, result.prevPrev);\n   }\n};\n\n\n//\n// insertFan - inside polygon, adds polygon fan with fanLists(Set)\n//\nWingedTopology.prototype.insertFan = function(polygon, fanLists) {\n   //const \n   \n   // get polygon centroid.\n   const centroid = vec3.create();\n   polygon.getCentroid(centroid);\n   let destVert = this.addVertex(centroid);\n\n   const fan = [];\n   let lastOut;\n   for (let hEdge of polygon.hEdges()) {  // walk in order.\n      if (fanLists.has(hEdge)) { // only in the list, we do fanEdge.\n         if (lastOut !== undefined) {\n            lastOut = this.insertEdge(hEdge, lastOut.pair);\n            fan.unshift(lastOut.pair);\n         } else { // liftCorner Edge for first Fan.\n            lastOut = this._liftDanglingEdge(hEdge, destVert);\n            fan.unshift( lastOut ); // lastOut, not lastOut.pair will guarantee dissolve correctly.\n         }\n      }\n   }\n\n   return fan;\n};\n\n\n// \n// invert() - invert the normal of all polygon. usefull when import meshes that use cw-order polygon.\n//\nWingedTopology.prototype.invert = function() {\n   const reverse = [];\n   for (let polygon of this.faces) {\n      for (let hEdge of polygon.hEdges()) {\n         reverse.push( {hEdge: hEdge.next.pair, next: hEdge.pair} );\n      }\n   }\n   // got the reversed list, now reverse the edge.\n   for (let {hEdge, next} of reverse) {\n      hEdge.next = next;\n   }\n   // now swap the polygon pointer.\n   for (let wEdge of this.edges) {\n      let swapPoly = wEdge.left.face;\n      if (swapPoly.halfEdge === wEdge.left) {\n         swapPoly.halfEdge = wEdge.right;\n      }\n      wEdge.left.face = wEdge.right.face;\n      if (wEdge.left.face.halfEdge === wEdge.right) {\n         wEdge.left.face.halfEdge = wEdge.left;\n      }\n      wEdge.right.face = swapPoly;  // done swapping.\n   }\n};\n\n//\n// flip() - flip vertex around center with particular axis only\n//\nWingedTopology.prototype.flip = function(pivot, axis) {\n   const axisX2 = pivot[axis] * 2;\n   for (let vertex of this.vertices) {\n      vertex.vertex[axis] = axisX2 - vertex.vertex[axis];  // == center[axis] - (vertex.vertex[axis]-center[ais])\n         this.addAffectedEdgeAndFace(vertex);               // optimiztion: addAllAffected() functions.\n      }\n};\n\n\nWingedTopology.prototype.makeHole = function(polygon) {\n   // turn polygon into hole, \n   let ret = {hEdge: polygon.halfEdge, face: polygon, dissolveEdges: []};\n   for (let hEdge of polygon.hEdges(true)) {\n      hEdge.face = null;\n      const pairEdge = hEdge.pair;\n      if (pairEdge.face === null) { \n         ret.dissolveEdges.unshift( this.dissolveEdge(hEdge) );   // in any doubt, use dissolveEdge. I am stupid\n      }\n   }\n   this._freePolygon(polygon);\n   return ret;\n};\n\nWingedTopology.prototype.undoHole = function(hole) {\n   for (let dissolve of hole.dissolveEdges) {\n      if (!hole.face.isLive()) {\n         dissolve.delFace = hole.face;\n      }\n      this.restoreDissolveEdge(dissolve);\n   }\n   if (!hole.face.isLive()) {\n      return this._createPolygon(hole.hEdge, 4, hole.face);\n   } else {\n      return hole.face;\n   }\n};\n\n\n\n\n\n//# sourceURL=webpack:///./js/wings3d_wingededge.js?");

/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n//# sourceURL=webpack:///./node_modules/indexof/index.js?");

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var indexOf = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n//# sourceURL=webpack:///./node_modules/vm-browserify/index.js?");

/***/ }),

/***/ 0:
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./js/app.js ./js/wings3d_bodymads.js ./js/wings3d_boundingvolume.js ./js/wings3d_camera.js ./js/wings3d_draftbench.js ./js/wings3d_edgemads.js ./js/wings3d_facemads.js ./js/wings3d_gl.js ./js/wings3d_guidetutor.js ./js/wings3d_hotkey.js ./js/wings3d_i18n.js ./js/wings3d_importexport.js ./js/wings3d_interact.js ./js/wings3d_mads.js ./js/wings3d_model.js ./js/wings3d_multimads.js ./js/wings3d_render.js ./js/wings3d_shaderprog.js ./js/wings3d_similar.js ./js/wings3d_triangulate.js ./js/wings3d_ui.js ./js/wings3d_uitree.js ./js/wings3d_undo.js ./js/wings3d_util.js ./js/wings3d_vertexmads.js ./js/wings3d_view.js ./js/wings3d_wingededge.js ./js/wings3d.js ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n__webpack_require__(/*! ./js/wings3d_bodymads.js */\"./js/wings3d_bodymads.js\");\n__webpack_require__(/*! ./js/wings3d_boundingvolume.js */\"./js/wings3d_boundingvolume.js\");\n__webpack_require__(/*! ./js/wings3d_camera.js */\"./js/wings3d_camera.js\");\n__webpack_require__(/*! ./js/wings3d_draftbench.js */\"./js/wings3d_draftbench.js\");\n__webpack_require__(/*! ./js/wings3d_edgemads.js */\"./js/wings3d_edgemads.js\");\n__webpack_require__(/*! ./js/wings3d_facemads.js */\"./js/wings3d_facemads.js\");\n__webpack_require__(/*! ./js/wings3d_gl.js */\"./js/wings3d_gl.js\");\n__webpack_require__(/*! ./js/wings3d_guidetutor.js */\"./js/wings3d_guidetutor.js\");\n__webpack_require__(/*! ./js/wings3d_hotkey.js */\"./js/wings3d_hotkey.js\");\n__webpack_require__(/*! ./js/wings3d_i18n.js */\"./js/wings3d_i18n.js\");\n__webpack_require__(/*! ./js/wings3d_importexport.js */\"./js/wings3d_importexport.js\");\n__webpack_require__(/*! ./js/wings3d_interact.js */\"./js/wings3d_interact.js\");\n__webpack_require__(/*! ./js/wings3d_mads.js */\"./js/wings3d_mads.js\");\n__webpack_require__(/*! ./js/wings3d_model.js */\"./js/wings3d_model.js\");\n__webpack_require__(/*! ./js/wings3d_multimads.js */\"./js/wings3d_multimads.js\");\n__webpack_require__(/*! ./js/wings3d_render.js */\"./js/wings3d_render.js\");\n__webpack_require__(/*! ./js/wings3d_shaderprog.js */\"./js/wings3d_shaderprog.js\");\n__webpack_require__(/*! ./js/wings3d_similar.js */\"./js/wings3d_similar.js\");\n__webpack_require__(/*! ./js/wings3d_triangulate.js */\"./js/wings3d_triangulate.js\");\n__webpack_require__(/*! ./js/wings3d_ui.js */\"./js/wings3d_ui.js\");\n__webpack_require__(/*! ./js/wings3d_uitree.js */\"./js/wings3d_uitree.js\");\n__webpack_require__(/*! ./js/wings3d_undo.js */\"./js/wings3d_undo.js\");\n__webpack_require__(/*! ./js/wings3d_util.js */\"./js/wings3d_util.js\");\n__webpack_require__(/*! ./js/wings3d_vertexmads.js */\"./js/wings3d_vertexmads.js\");\n__webpack_require__(/*! ./js/wings3d_view.js */\"./js/wings3d_view.js\");\n__webpack_require__(/*! ./js/wings3d_wingededge.js */\"./js/wings3d_wingededge.js\");\nmodule.exports = __webpack_require__(/*! ./js/wings3d.js */\"./js/wings3d.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js_./js/wings3d_bodymads.js_./js/wings3d_boundingvolume.js_./js/wings3d_camera.js_./js/wings3d_draftbench.js_./js/wings3d_edgemads.js_./js/wings3d_facemads.js_./js/wings3d_gl.js_./js/wings3d_guidetutor.js_./js/wings3d_hotkey.js_./js/wings3d_i18n.js_./js/wings3d_importexport.js_./js/wings3d_interact.js_./js/wings3d_mads.js_./js/wings3d_model.js_./js/wings3d_multimads.js_./js/wings3d_render.js_./js/wings3d_shaderprog.js_./js/wings3d_similar.js_./js/wings3d_triangulate.js_./js/wings3d_ui.js_./js/wings3d_uitree.js_./js/wings3d_undo.js_./js/wings3d_util.js_./js/wings3d_vertexmads.js_./js/wings3d_view.js_./js/wings3d_wingededge.js_./js/wings3d.js?");

/***/ })

/******/ });